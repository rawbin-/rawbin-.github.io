---
layout: post
title: "IO模型 同步 异步 阻塞 非阻塞"
categories: [Web开发,前端开发]
tags: [IO模型]
---

阻塞I/O特点是调用I/O操作之后一定要等到系统内核层面完成所有操作之后，调用才返回。比如读取磁盘文件操作，系统内核在完成磁盘寻到、读取数据、复制数据到内存操作之后，这个调用才结束。

阻塞I/O造成CPU等待I/O，浪费等待时间，CPU闲置不能得到充分利用。



非阻塞I/O调用后会立即返回一个文件描述符，调用方的数据再通过文件描述符获取。非阻塞I/O返回后，CPU可以用来处理其他事物，CPU利用率明显提高。

非阻塞I/O返回的是当前的调用状态，为了获取完整的数据，程序需要重复调用I/O操作来确认数据是否操作完成。这种重复判断操作是否完成的技术叫轮询。

轮询的方式

满足了非阻塞I/O确保获取完整数据的需求，从应用程序的角度看，还是同步的效果，应用程序还是需要等待I/O完全返回，在返回之前需要一直等待。等待过程中要么遍历文件描述符，要么休眠等待事件发生。

+ read
  + 最原始、性能最低的方式
  + 通过重复调用来检查I/O状态来完成完整的数据读取。
  + 在得到最终数据前，CPU有效利用率不高（状态检查绝大部分是无效CPU）。
+ select
  + 在read的基础上的一种改进方案
  + 通过文件描述符上的事件状态来进行判断
  + 采用一个1024长度的数组来存储状态，最低可同时维护1024个文件描述符(I/O操作状态)
+ pull
  + 比起select来说更加优化
  + 采用链表的方式突破数组长度的限制
  + 避免不需要的检查
  + 在文件描述符较多的情况下性能较低（链表的查询效率低）
+ epoll
  + 是Linux下效率最高的I/O事件通知机制
  + 利用了事件通知，执行回调的方式而不是遍历查询，所以CPU有效利用率高
  + 在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒
  + 休眠过程中CPU还是闲置的，利用率还是不够高
+ kqueue
  + 类似于epoll
  + 仅在FreeBSD系统下实现

更理想的非阻塞异步I/O

+ 应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，直接处理下一个任务
+ 在I/O完成后通过信号或者回调将数据传输给应用程序。
+ Linux 原生提供的（AIO）就是这种方式
+ AIO仅支持内核I/O中的O_DIRECT方式读取，无法利用系统缓存

NodeJS的异步I/O方式

+ 使用多线程的方式，通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来熟悉数据获取
+ 让一个线程进行计算处理，通过线程间的通信将I/O的到的数据进行传递
+ 通过线程池和轮询的方式实现异步I/O的效果
+ NodeJS在Windows下的异步I/O使用Windows自带的IOCP异步I/O方案
+ Windows IOCP 调用异步方法，等待I/O完成的通知，执行回调，无需轮询。







操作系统内核对于I/O操作只有阻塞和非阻塞两种方式。

单线程同步I/O会因为阻塞I/O导致硬件资源得不到更优的使用；多线程编程模型也因为编程中的死锁、状态同步问题经常出问题。





### 参考资料

1. 《深入浅出Node.js》
2. 《Netty 权威指南》第二版
3. 《深入剖析Nginx》
4. 《Unix环境高级编程》第三版
5. 《Windows核心编程》第五版
6. 《操作系统概念》第七版
7. [聊聊Linux 五种IO模型](http://www.jianshu.com/p/486b0965c296)
8. [高性能IO模型浅析](http://www.cnblogs.com/fanzhidongyzby/p/4098546.html)
9. [也谈IO模型](http://www.importnew.com/22019.html)