{"meta":{"title":"技术人生","subtitle":"","description":"","author":"小淼焱","url":"http://rawbin-.github.io","root":"/"},"pages":[],"posts":[{"title":"Chrome数组排序那些事","slug":"structure-algorithm/2019-01-01-chrome-array-sort","date":"2022-03-02T03:12:58.573Z","updated":"2022-03-02T03:12:58.574Z","comments":true,"path":"structure-algorithm/2019-01-01-chrome-array-sort/","link":"","permalink":"http://rawbin-.github.io/structure-algorithm/2019-01-01-chrome-array-sort/","excerpt":"","text":"前言v8源码 可以在github上面直接下，早期的ArraySort 是用JS来实现的，整合了插入排序和快速排序两种算法，在10以下就用插入，以上就用快排。后来更换了算法和实现方式，到目前为止(20211125) 最新的数组排序还是 使用的TimSort这个算法，看起来是从Python那学来的。 详情可以参考这里，也有一些过程内容可以译文 或者 原版V8开发博客 解决的问题就一个，排序稳定性问题 先看看这里面的几个算法排序算法集锦排序算法对比评估时间复杂度空间复杂度稳定性正确性易维护性","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"http://rawbin-.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"前端中后台管理系统选型和开发","slug":"dev-env/2022-01-14-fe-managent-dev","date":"2022-03-02T03:12:58.572Z","updated":"2022-03-02T03:12:58.572Z","comments":true,"path":"dev-env/2022-01-14-fe-managent-dev/","link":"","permalink":"http://rawbin-.github.io/dev-env/2022-01-14-fe-managent-dev/","excerpt":"","text":"选型设计结论诉求 对于后台管理系统 UI设计一次定型，符合业界设计风格，不需要太个性化的设计 侧重业务流程、效率，不过分关注UI 相似流程和交互占比大，有通用模式可以提取，在大量系统中可以大大提效 表单、列表、通用流程展示、数据看板等都是最常用的通用业务模式 设计对于管理系统模板/框架来说 具有通用的流程结构、登录注册，菜单、路由、权限校验等等 经过业界项目的洗礼，能够适用或者通用 对于通用业务模式 模式可以通过配置化生成 相似模式可以通过简单配置来实现，将代码量降到最低，同时会大大降低联调、测试等工作量 增加模式配置的灵活性 支持各种布局方式 支持详细的属性设置 支持校验规则自定义 支持元素之间联动 支持事件的自定义 实现选型后台管理系统模板/框架React ant-design/ant-design-proVue vueComponent/ant-design-vue-pro配置化表单 alibaba/formily 表单设计器这部分可以根据实现定位各取所长 比如偏重开发的部分，可以有更多更详细的配置，可以通过写代码的方式来配置或者配置中可以写代码 比如偏重运营的部分，那么vform666/variant-form中的内置配置模板就值得参考采纳 实现思路上可以先偏重开发部分，暴露对应的接口，然后在此基础上偏重运营部分，让偏运营部分可以快速简单做绝大部分的事情，而偏开发部分可以作为增强的高级功能，让配置实现一切 现有的后台管理系统模板[[React]]系列ant-design/ant-design-pro Ant Design 中后台管理系统 yezihaohao/react-admin React + Antd´marmelab/react-admin React+Material UI zuiidea/antd-admin antd + umijs NLRX-WJC/react-antd-admin-template[[Vue]] 系列iczer/vue-antd-admin Ant Design Pro的Vue实现版本 vueComponent/ant-design-vue-pro 基于Ant Design of Vue 的版本 chuzhixin/vue-admin-better 支持vue2 element-ui，vue2 element-plus 支持vue3 ant-design-vue 支持PC，平板，手机 hooray/fantastic-adminhooray/one-step-admin 支持Vue2 和 Vue3 支持PC端和移动端 PanJiaChen/vue-element-admin Vue+ElementUI vbenjs/vue-vben-admin Vue3+vite+TS hooray/fantastic-admin 支持Vue2 和 Vue3 支持PC和移动端 iview/iview-adminArmour/vue-typescript-admin-template配置化或动态化表单业界的内容 动态表单引擎，向低代码迈出最关键的一步 动态表单 支持的语言表示 hyperhype/hyperscript HyperJSON 切入点 通用的工具无法适配大部分业务场景，或者说配置量太大 需要针对业务场景进行专门的封装和定制，这样就可以业务人员快速开发和切入 前期对齐业务模型，后期只需要在业务模型的基础上进行配置即可 表单设计模式 业界已有实现都支持系列alibaba/formily 官网 支持React/ReactNative/Vue2/Vue3/ 支持表单设计器，基于alibaba/designable 支持多种布局 支持PC和移动端 有详细的组件属性配置和校验规则配置入口 [[React]] 系列alibaba/formily 官网 支持React/ReactNative/Vue2/Vue3/ 支持表单设计器，基于alibaba/designable 支持多种布局 支持PC和移动端 有详细的组件属性配置和校验规则配置入口 alibaba/x-render 由原来的form-render升级而来 目前有chart-render,form-render,table-render json-schema baidu/amis 支持原生JavaScript和[[React]] 通过JSON配置字段type映射到具体的组件上，剩下的都当做组件的属性传入 自定义组件支持函数，函数通过转成字符串传人 [[Vue]] 系列alibaba/formily 官网 支持React/ReactNative/Vue2/Vue3/ 支持表单设计器，基于alibaba/designable 支持多种布局 支持PC和移动端 有详细的组件属性配置和校验规则配置入口 vform666/variant-form 支持栅格布局 支持详细的配置，校验，事件属性配置（写代码） 有表单模板，可参考 支持PC，Pad和H5 xaboy/form-create 官网 支持vue2，vue3 支持 iview, view-design,elementUI, ant-design-vue 有表单设计器，代码 xaboy/form-create-designer 支持栅格布局 支持PHP JakHuang/form-generator 有可视化设计器 可分组，无专门的布局 有较丰富的文档 fuchengwei/vue-form-create 有可视化设计器 支持栅格布局 可配置表单校验规则 GavinZhuLei/vue-form-making 分为MakingForm 和 GenerateForm 布局和控件相对较全，支持多端布局 可以为表单添加动作 二次开发需要商业授权，基础款的功能较少 didi/epage 有可视化设计器 控件较少，布局只支持栅格 每个组件设置的内容很精细 sscfaith/avue-form-design 支持的控件相对较多，布局可以分组，没有专门的布局 表单设计 流程设计 lljj-x/vue-json-schema-form 支持vue2 ElementUI, vue2 iView3 支持vue3 Element Plus, vue3 Antdv 有专门的活动页面编辑器 lljj-x/vjsf-demo-editor 有可视化设计，布局限制较多","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"管理系统","slug":"管理系统","permalink":"http://rawbin-.github.io/tags/%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"自动化表单","slug":"自动化表单","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A1%A8%E5%8D%95/"}]},{"title":"nginx SPA 多环境和多项目配置参考","slug":"nginx/2018-11-11-nginx-mutiple-spa","date":"2022-03-02T03:10:53.410Z","updated":"2022-03-02T03:10:53.411Z","comments":true,"path":"nginx/2018-11-11-nginx-mutiple-spa/","link":"","permalink":"http://rawbin-.github.io/nginx/2018-11-11-nginx-mutiple-spa/","excerpt":"","text":"需求场景线上环境配置 线上环境一个项目一个配置，也就是行业各种推荐的nginx配置，如下 这样有M个项目就写M个配置就OK，频次不高12345location /projectName/ &#123; root path/to/projectName; index index.html; try_files $uri $uri/ /projectName/index.html;&#125; 测试环境配置 测试环境不太一样，只有一台机器 在这一台机器上面通过目录的方式划分出N个环境（也就是对应N个目录） 在每一套环境上面，分出M个项目来，同一个项目可能再不同时间会部署到不同的环境（比如原来的环境被占用了） 测试环境需要N*M个配置来处理类似的需求，这样就有点蛋疼了，尤其是在nginx配置上面 解决方案诉求 根据前面的场景，针对每个环境每个项目去写对应的配置，已经不太现实 我们希望写一套配置针对一个环境的多个项目通用，不用重复配置 最好是一套配置将不同环境的多个项目都搞定这样就更舒心了 解法 经探索，搞出来一套配置12345location ~* ^/(env1|env2|envx|envtest)\\/(\\w+)/ &#123; root /usr/local/var/www; index index.html index.htm; # 这个地方不写分号在我的nginx版本不报错 try_files $uri $uri/ /$1/$2/index.html;&#125; 适用场景 上面这套配置，适用于如下的目录结构 123456789101112131415161718192021222324-----env1-----------projectA-----------------------index.html-----------------------static------------------------------css------------------------------js-----------projectB-----------------------index.html-----------------------static------------------------------css------------------------------js-----env2-----------projectA-----------------------index.html-----------------------static------------------------------css------------------------------js-----------projectB-----------------------index.html-----------------------static------------------------------css------------------------------js#....此处省略更多..... 相关操作Nginx相关配置变更 这个上面已经讲过啦 SPA 项目配置调整 如果使用的是hash模式，本身相对简单直接能兼容 如果是history模式的话，需要关注路由在nginx找不到的问题，需要重定向到对应的index.html就行，上面nginx部分已经做了 本地dev-server也有找不到路径的问题 项目部分还需要做一些配置，以适配目录的部署，也就是history的baseName，下面是一个相对通用的解决 React Router 或者 Vue Router使用如下方式进行获取 123456789101112131415161718const getBasePath = () =&gt; &#123; // 任意目录部署需要指定容器目录 `xxx/index.html` const parentDirectory = &#x27;xxx/&#x27; const path = location.pathname const identifierIndex = path.lastIndexOf(parentDirectory) // 这里可以自定义处理规则 if (identifierIndex === -1) &#123; // 比如这里兼容原有的直接部署到环境根目录的情况 const secondSlashIndex = path.indexOf(&#x27;/&#x27;, 1) if (secondSlashIndex !== -1) &#123; // 存在 `/aa/` `/aa/bb`等情况，那就用一级目录 return path.slice(0, secondSlashIndex + 1) &#125; else &#123; return path // 不存在上面情况就只有一级目录或者直接根目录，那就直接用 &#125; &#125; return path.slice(0, identifierIndex + parentDirectory.length)&#125; jenkins配置调整 基本不需要大调整 但如果是使用了 Publish over SSH，这里参数化有一些问题 我这里遇到的就是参数化不生效，直接变量给到的没有被支持，看起来代码是被先解析了一道，同时字符串截取也没生效 12345678910111213141516# 代码写成这样的hostEnvValue=$&#123;hostEnv%-*&#125;echo &#x27;$hostEnv=&#x27;$hostEnvecho &#x27;$hostEnvValue=&#x27;$hostEnvValueecho &#x27;$hostEnvValue=&#x27;$&#123;hostEnv%-*&#125;# 控制台输出的代码是这样的hostEnvValue=$&#123;hostEnv%-*&#125;echo &#x27;envx-justtest=&#x27;envx-justtestecho &#x27;$hostEnvValue=&#x27;$hostEnvValueecho &#x27;$hostEnvValue=&#x27;$&#123;hostEnv%-*&#125;# 控制台输出的内容是这样的envx-justtest=envx-justtest$hostEnvValue=$hostEnvValue= 简单用一个变量周转一下就好了 123456789101112131415161718192021222324252627# 代码写成这样tmpHostEnv=$hostEnvhostEnvValue=$&#123;tmpHostEnv%-*&#125;echo $tmpHostEnvecho $hostEnvValueecho &#x27;$hostEnv=&#x27;$hostEnvecho &#x27;$tmpHostEnv=&#x27;$tmpHostEnvecho &#x27;$hostEnvValue=&#x27;$hostEnvValueecho &#x27;$hostEnvValue=&#x27;$&#123;hostEnv%-*&#125;# 控制台输出的代码tmpHostEnv=envx-justtesthostEnvValue=$&#123;tmpHostEnv%-*&#125;echo $tmpHostEnvecho $hostEnvValueecho &#x27;envx-justtest=&#x27;envx-justtestecho &#x27;$tmpHostEnv=&#x27;$tmpHostEnvecho &#x27;$hostEnvValue=&#x27;$hostEnvValueecho &#x27;$hostEnvValue=&#x27;$&#123;hostEnv%-*&#125;# 控制台输出envx-justtestenvxenvx-justtest=envx-justtest$tmpHostEnv=envx-justtest$hostEnvValue=envx$hostEnvValue= 这样一切就正常了 相关参考调试nginx的方法 有时候规则多了，不知道到底匹配哪一个， 比如一方面涉及到规则优先级，另一方面又涉及到正则本身太强大不容易控制 可以直接在规则里面写return123456location ~* ^/(env1|env2|envx|envtest)\\/(\\w+)/ &#123; root /usr/local/var/www; index index.html index.htm; # 这个地方不写分号在我的nginx版本不报错 return 200 &quot;这个是xxx规则&quot;; try_files $uri $uri/ /$1/$2/index.html;&#125; 安装echo模块并echo，简单理解为console 这个最好先把配置的响应类型改一下，不用流，不然直接就下载了，有点讨厌 123456789default_type text/plain; # 这一行放到http合适的地方location ~* ^/(env1|env2|envx|envtest)\\/(\\w+)/ &#123; root /usr/local/var/www; index index.html index.htm; # 这个地方不写分号在我的nginx版本不报错 echo -n $1; echo $2 try_files $uri $uri/ /$1/$2/index.html;&#125; 直接开启nginx的调试模式 如果说上面的是小打小闹，这个就是放大招 首先要安装或者配置可调试的nginx 服务器上直接源码编译开启调试选项就ok MacOS上可以简单用brew实现 在离目标最近的合适位置，开启调试 1error_log logs/error.log debug; 开启调试模式后，可以看到如下日志,瞬间瞎了的眼都亮了 123456789101112131415161718192021222324252627282930313233342020/12/30 18:35:00 [debug] 98824#0: *36 rewrite phase: 12020/12/30 18:35:00 [debug] 98824#0: *36 test location: &quot;/&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 test location: &quot;manage/&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 test location: &quot;admin/&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 test location: &quot;50x.html&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 test location: ~ &quot;^/(271|272|envx|envtest)/&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 using configuration &quot;^/(271|272|envx|envtest)/&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 http cl:-1 max:10485762020/12/30 18:35:00 [debug] 98824#0: *36 rewrite phase: 32020/12/30 18:35:00 [debug] 98824#0: *36 post rewrite phase: 42020/12/30 18:35:00 [debug] 98824#0: *36 generic phase: 52020/12/30 18:35:00 [debug] 98824#0: *36 generic phase: 62020/12/30 18:35:00 [debug] 98824#0: *36 generic phase: 72020/12/30 18:35:00 [debug] 98824#0: *36 access phase: 82020/12/30 18:35:00 [debug] 98824#0: *36 access phase: 92020/12/30 18:35:00 [debug] 98824#0: *36 post access phase: 102020/12/30 18:35:00 [debug] 98824#0: *36 generic phase: 112020/12/30 18:35:00 [debug] 98824#0: *36 try files handler2020/12/30 18:35:00 [debug] 98824#0: *36 http script var: &quot;/271/index.html&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 trying to use file: &quot;/271/index.html&quot; &quot;/usr/local/var/www/271/index.html&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 http script var: &quot;/271/index.html&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 trying to use dir: &quot;/271/index.html&quot; &quot;/usr/local/var/www/271/index.html&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 http script copy: &quot;/&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 http script capture: &quot;271&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 http script copy: &quot;/index.html&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 trying to use file: &quot;/271/index.html&quot; &quot;/usr/local/var/www/271/index.html&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 internal redirect: &quot;/271/index.html?&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 rewrite phase: 12020/12/30 18:35:00 [debug] 98824#0: *36 test location: &quot;/&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 test location: &quot;manage/&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 test location: &quot;admin/&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 test location: &quot;50x.html&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 test location: ~ &quot;^/(271|272|envx|envtest)/&quot;2020/12/30 18:35:00 [debug] 98824#0: *36 using configuration &quot;^/(271|272|envx|envtest)/&quot; MacOS开启nginx调试 首先一定要安装nginx-full 才可以定制，nginx这个包我没玩起来过 执行如下命令等操作完成，就可以玩前面的配置和验证了 1234brew install nginx-full --with-echo-module --with-debug ## 第一次~brew reinstall nginx-full --with-echo-module --with-debug ## 老司机专用","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"服务配置","slug":"前端开发/Web开发/服务配置","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"前后端分离","slug":"前后端分离","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"name":"nginx","slug":"nginx","permalink":"http://rawbin-.github.io/tags/nginx/"},{"name":"history mode","slug":"history-mode","permalink":"http://rawbin-.github.io/tags/history-mode/"},{"name":"spa","slug":"spa","permalink":"http://rawbin-.github.io/tags/spa/"}]},{"title":"Puppeteer 应用实战","slug":"dev-tools/2018-12-13-puppeteer-review","date":"2022-03-02T03:10:53.408Z","updated":"2022-03-02T03:10:53.408Z","comments":true,"path":"dev-tools/2018-12-13-puppeteer-review/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2018-12-13-puppeteer-review/","excerpt":"","text":"相关参考 2017年那会刚好写个几篇关于Headless Chrome的内容，链接能会变，搜’Web自动化之Headless Chrome’ Web自动化之Headless Chrome概览 Web自动化之Headless Chrome开发工具库 Web自动化之Headless Chrome编码实战 Web自动化之Headless Chrome测试框架集成 Web自动化之Headless Chrome开发工具库更新——更高层级的API 刚开始的时候，只是Chrome 支持 Headless 模式，还没有puppeteer，后来有了也是一个小婴儿，还有很长一段路要走，现在近五年过去了，puppeteer 目前是10.x 的版本，已经完全可以独挡一面了，所有带着这个话题，来重新认识一下Headless Chrome之Puppeteer。","categories":[],"tags":[{"name":"puppeteer","slug":"puppeteer","permalink":"http://rawbin-.github.io/tags/puppeteer/"},{"name":"js","slug":"js","permalink":"http://rawbin-.github.io/tags/js/"},{"name":"headless chrome","slug":"headless-chrome","permalink":"http://rawbin-.github.io/tags/headless-chrome/"}]},{"title":"TypeScript简明参考指南","slug":"language/2019-01-03-typescript-ref","date":"2021-12-31T08:34:57.416Z","updated":"2021-12-31T11:09:28.256Z","comments":true,"path":"language/2019-01-03-typescript-ref/","link":"","permalink":"http://rawbin-.github.io/language/2019-01-03-typescript-ref/","excerpt":"","text":"类型系统相关界定/定义类型定义 类型别名的声明（type alias） 接口声明（interface） 类声明（class） 枚举声明（emum） 指向类型的导入声明（import ） 值的定义 变量声明（let,const,var 声明） 包含值的名称空间或者模块的声明（namespace,module） 枚举声明（emun） 类声明（class） 指向值的导入声明（import） 函数声明（function） 类型分类简单类型 类型字面量（数字，字符串） object string number boolean bigint symbol Function null undefined unknown never void any X[] 基础类型X的数组 [X,Y] 基础类型的元组 any 任意类型 复合类型 对象类型（object） 联合类型（union） 类型别名（type alias） 接口类型（interface） 枚举类型（enum） 交集类型（intersection） 泛型（generics）&lt;Type&gt; 数组类型Array&lt;Type&gt; 只读数组ReadOnlyArray&lt;Type&gt; 内置实用类型 Partial&lt;Type&gt; 所有属性可选 Required&lt;Type&gt;所有属性必选 ReadOnly&lt;Type&gt;所有属性只读 Record&lt;Keys,Type&gt; 用Keys限制的key和用Type限制的value的对象类型 Pick&lt;Type,Keys&gt; 从Type中选择Keys中的字段作为key的对象 Omit&lt;Type,Keys&gt;从Type中移除Keys中的字段剩下的作为字段作为属性的对象 Exclude&lt;Type,ExcludedUnion&gt;从Type中排出不能赋值给ExcludedUnion剩下的 Extract&lt;Type,Union&gt;从Type中取能赋值给Union的 NonNullable&lt;Type&gt;排除null和undefined Parameters&lt;Type&gt;从函数Type参数中取 ConstructorParameters&lt;Type&gt;从构造函数Type参数中获取 ReturnType&lt;Type&gt;从函数Type返回值获取 InstanceType&lt;Type&gt;从构造函数Type获取实例类型 ThisParameterType&lt;Type&gt;取函数类型的this参数的类型，没有的话就用unknown OmitThisParameter&lt;Type&gt; 从Type中删除this参数，没有就用Type，有就重新生成一个函数类型 ThisType&lt;Type&gt;使用了noImplicitThis要打开，标注this Uppercase&lt;StringType&gt; Lowercase&lt;StringType&gt; Capitalize&lt;StringType&gt; Uncapitalize&lt;StringType&gt; 类型应用函数中应用参数中应用 可调用参数Function 函数类型表达式 (a: string) =&gt; boolean 函数类型别名 type OneFunType = (a: string) =&gt; boolean 调用签名（call signatures） 1234567type DescribableFunction = &#123; description: string; (someArg: number): boolean;&#125;;function doSomething(fn: DescribableFunction) &#123; console.log(fn.description + &quot; returned &quot; + fn(6));&#125; 构造签名（construct signature） 1234567891011type SomeConstructor = &#123; new (s: string): SomeObject;&#125;;function fn(ctor: SomeConstructor) &#123; return new ctor(&quot;hello&quot;);&#125;interface CallOrConstruct &#123; new (s: string): Date; (n?: number): number;&#125; 泛型函数 123function firstElement&lt;Type&gt;(arr: Type[]): Type | undefined &#123; return arr[0];&#125; 函数重载 this声明 123interface DB &#123; filterUsers(filter: (this: User) =&gt; boolean): User[];&#125; 工厂方法中用使用 new 关键字一起声明 123function create&lt;Type&gt;(c: &#123; new (): Type &#125;): Type &#123; return new c();&#125; 类中应用代码组织模块 module导出 export export let/const/var/interface/class/ XX export &#123;XX,YY&#125; export &#123;XX as YY&#125; from &#39;in-module.ts&#39; export default XX export * as XX from &#39;in-module.ts&#39; export = XX 导入 import import &#123;XX&#125; from &#39;in-module.ts&#39; import &#123;XX as YY&#125; from &#39;in-module.ts&#39; import * as XX from &#39;in-module.ts&#39; import &#39;in-module.ts&#39; import type &#123;XX&#125; from &#39;in-module.ts&#39; import XX = require(&#39;../in-module.ts&#39;) 名称空间 namespacenamespace XXX&#123;&#125; 可以实现 在模块内对模块进行逻辑分区 跨模块对名称空间内的内容进行合并","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://rawbin-.github.io/tags/TypeScript/"},{"name":"编程语言","slug":"编程语言","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"排列组合算法那些事","slug":"structure-algorithm/2019-01-01-algorithm-combination-permutation","date":"2021-12-31T02:37:59.950Z","updated":"2021-12-31T02:37:59.950Z","comments":true,"path":"structure-algorithm/2019-01-01-algorithm-combination-permutation/","link":"","permalink":"http://rawbin-.github.io/structure-algorithm/2019-01-01-algorithm-combination-permutation/","excerpt":"","text":"前言是有些时间没有真正跟算法打交道了，除了学习理论的过程，在实践中能用到算法的地方确实少，但这个要考,本着在哪里跌倒就在哪里躺下然后再爬起来的原则，我们来看看这里面相关的问题。 参考书籍 《组合数学 第五版》 相关代码: js代码 python代码 组合对于任意的集合A 比如[1,2,3,4,5,6] 和集合B比如[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;],限制类型主要是消除整数元素的特殊性，增加实现代码的可扩展性和实用性 生成包含R个元素的组合或者生成R子集1需求: 生成集合A和集合B的3元子集 算法一 全集筛选法这只能算一种思路，但不那么有效。 先生成幂集，也就是所有的子集，这个也是《组合数学》上给出的方法，用n个二进制位来表示n个元素是否存在，而这n个二进制位从全0到全1的组合刚好是n个元素的幂集的组合。 然后从幂集中选择长度为r的子集，得到的就是r子集。 1234567891011121314import &#123;combinationsAll&#125; from &quot;./combinations-all.mjs&quot;;export function combinations(baseList,subSetLen)&#123; if(!Array.isArray(baseList))&#123; return &#125; if(baseList.length &lt; subSetLen)&#123; return &#125; const allCombinations = combinationsAll(baseList) return allCombinations.filter(item =&gt; &#123; return item.length === subSetLen &#125;)&#125; 算法二 字典序生成法参考《组合数学》中【生成r子集】部分，算法如下： 假定集合为[1,2,…n] 初始条件，设第一个r子集 a1a2…ar=12…r 当a1a2…ar 不等于 (n-r+1)(n-r+2)…n的时候，执行如下操作 确定最大的整数 k 使得ak + 1 &lt;= n 且 ak + 1 不是 a1,a2…ar中的一个 用r子集 a1…ak-1(ak+1)(ak+2)…(ak+r-k+1) 替换 a1a2…ar 这个算法看起来有点离散哈，但他是利用在字典序中求一个序列的直接后继得到所有的r序列，所以避免了【算法一 全集筛选法】中的多余计算的问题。这里面k可以理解为r前序变后继的过程中要变化的位置的索引起始值，它的最大值为r(最后一个元素变)，最小值为1(第一个元素变)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 获取最大的K，也就是要变化的位置// a[k] + 1 &lt;= maxEl, a[k] 不在 prevList中const getMaxKPosition = (prevList, maxEl, subSetLen) =&gt; &#123; let maxK = subSetLen let maxKValue = prevList[maxK - 1] + 1 while (prevList.includes(maxKValue) || maxKValue &gt; maxEl)&#123; maxK-- maxKValue = prevList[maxK - 1] + 1 &#125; console.log(maxK) return maxK&#125;const getNextCombination = (prevList,maxK,subSetLen) =&gt; &#123; let nextList = [...prevList] if(maxK === subSetLen)&#123; nextList[maxK - 1] = nextList[maxK - 1] + 1 &#125;else&#123; nextList[maxK - 1] = nextList[maxK - 1] + 1 for(let i = maxK; i &lt; subSetLen; i++)&#123; nextList[i] = nextList[i - 1] + 1 &#125; &#125; return nextList&#125;function combinationsDict(baseLen, subSetLen)&#123; if(baseLen &lt; subSetLen)&#123; return &#125; const baseList = [] for(let i = 1; i &lt;= baseLen; i++)&#123; baseList.push(i) &#125; let prevList = baseList.slice(0,subSetLen) let lastList = baseList.slice(baseLen - subSetLen) const resultList = [ prevList ] let maxEl = baseList[baseLen - 1] let maxK = getMaxKPosition(prevList,maxEl,subSetLen) while (prevList.join() !== lastList.join())&#123; prevList = getNextCombination(prevList,maxK,subSetLen) resultList.push(prevList) maxK = getMaxKPosition(prevList,maxEl,subSetLen) &#125; return resultList&#125;export function combinations(baseList, subSetLen)&#123; const indicateList = combinationsDict(baseList.length,subSetLen) return indicateList.map((itemList,itemListIndex) =&gt; &#123; return itemList.map((item,index) =&gt; &#123; return baseList[item - 1] &#125;) &#125;)&#125;console.log(combinationsDict(6,3))console.log(combinations([1,2,3,4,5,6],3))console.log(combinations([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;],3)) 算法三 递归加入法算组合的时候的直接思路 先选一个 再从剩下的中选r-1个 将先选的那一个和每一个r-1的组合组合起来，就是r子集，以此类推 1234567891011121314151617181920export function combinations(baseList,subSetLength)&#123; if(!Array.isArray(baseList))&#123; return &#125; if(subSetLength === 1)&#123; return baseList.map(baseItem =&gt; [baseItem]) &#125; const resultList = [] baseList.forEach((baseItem,baseIndex) =&gt; &#123; const lessCombi = combinations(baseList.slice(baseIndex + 1),subSetLength - 1) lessCombi.forEach((lessCombiItem,lessCombiIndex) =&gt; &#123; resultList.push([baseItem,...lessCombiItem]) &#125;) &#125;) return resultList&#125; 算法四 非递归加入法也是算组合的时候的直接思路： 先选一个 再从没选过的剩下的里面选一个，以此类推直到选够 为了避免重复，按字典序选择，同时选的时候把最后面的空位要留出来 比如说，[1,2,3,4,5,6] 中选三个的话，那么第一个只能选到4，剩下的5和6 不能选，选了就凑不够三个了，还要回过头来选前面的，这样会造成重复 同样的选第n个的时候，序列小的不能选，一定是被选过的，因为是按字典序选的 因为是组合，所以这里按字典序只能选比当前集合中最大的还要大的。 123456789101112131415161718192021222324252627282930export function combinations(baseList,subSetLength)&#123; if(!Array.isArray(baseList))&#123; return &#125; if(subSetLength &gt; baseList.length)&#123; return &#125; // 先选一个的选法 let baseSelection = baseList.reduce((result, item ,index ) =&gt; &#123; if(index &lt;= baseList.length - subSetLength)&#123; result.push([item]) &#125; return result &#125;,[]) for(let i = 1; i &lt; subSetLength; i++)&#123; baseSelection = baseSelection.reduce((result,baseSeleItem) =&gt; &#123; const maxIndexInBase = baseList.indexOf(baseSeleItem[baseSeleItem.length - 1]) const options = baseList.slice(maxIndexInBase + 1) options.forEach(optionItem =&gt; &#123; result.push([...baseSeleItem,optionItem]) &#125;) return result &#125;, []) &#125; return baseSelection;&#125; 算法五 字典序生成法-生成器版-参考答案这个是经过【举一反三】里面的源码学习，造的仿Python的版本，可以看到用Python写起来其实更加的简洁， 1234567891011121314151617181920212223242526272829303132333435363738394041424344function* combinationDict(baseListLength,subSetLength)&#123; const delta = baseListLength - subSetLength let indicator = [...Array(subSetLength).keys()] // 初始指示器 [0,1,2...subSetLength-1] let firstChangeIndex = subSetLength - 1 // 从左到右第一个要变化索引的位置 yield indicator while (true)&#123; // 默认从最后一位开始变化 for(firstChangeIndex = subSetLength; firstChangeIndex--;)&#123; if(indicator[firstChangeIndex] !== firstChangeIndex + delta)&#123; break &#125; &#125; // 咱们这里也用一个循环穿透来判断， if(firstChangeIndex &lt; 0)&#123; break &#125; indicator[firstChangeIndex] += 1 for(let i = firstChangeIndex + 1, len = indicator.length; i &lt; len; i++)&#123; indicator[i] = indicator[i - 1] + 1 &#125; yield indicator &#125;&#125;export function* combinations(baseList,subSetLength)&#123; if(!Array.isArray(baseList))&#123; return &#125; if(baseList.length &lt; subSetLength)&#123; return &#125; const indicatorGen = combinationDict(baseList.length,subSetLength) while (true)&#123; const &#123;value,done&#125; = indicatorGen.next() if(!done)&#123; yield value.map(itemIndex =&gt; &#123; return baseList[itemIndex] &#125;) &#125;else&#123; break &#125; &#125;&#125; Python 简单实现(利用标准库)itertools参考文档中文, 英文 python代码地址 1234567from itertools import combinationsimport stringsetA = range(1,7) # [1,2,3,4,5,6]setB = list(string.ascii_uppercase[0:6]) # [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;]print(list(combinations(setA,3)))print(list(combinations(setB,3))) 生成幂集1需求: 生成集合A和集合B的所有可能的子集 算法一 二进制位图法这个也是《组合数学》上给出的方法，用n个二进制位来表示n个元素是否存在，而这n个二进制位从全0到全1的组合刚好是n个元素的幂集的组合。 1234567891011121314151617181920export function combinationsAll(baseList)&#123; if(!Array.isArray(baseList))&#123; return &#125; const totalCount = Math.pow(2,baseList.length) let resultList = [[]] for(let i = 1; i &lt; totalCount; i++)&#123; const flagList = i.toString(2).split(&#x27;&#x27;).reverse() // 转成二进制字符串 let tmpResult = [] flagList.forEach((item,index) =&gt; &#123; if(item === &#x27;1&#x27;)&#123; tmpResult.push(baseList[index]) &#125; &#125;) resultList.push(tmpResult) &#125; return resultList&#125; Python 简单实现(利用标准库)itertools参考文档中文, 英文 python代码地址 1234567891011121314from itertools import combinationsimport stringsetA = range(1,7) # [1,2,3,4,5,6]setB = list(string.ascii_uppercase[0:6]) # [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;]resultA = []resultB = []for i in range(len(setA) + 1): resultA += combinations(setA,i)print(resultA)for i in range(len(setB) + 1): resultB += combinations(setB,i)print(resultB) 排列对于任意的集合A 比如[1,2,3,4,5,6] 和集合B比如[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;],限制类型主要是消除整数元素的特殊性，增加实现代码的可扩展性和实用性 生成一个指定集合的全排列算法一 递归插入法这里恰好能用上在《组合数学》中提到的插入法，因为这里的方法是依赖于递归的思路，n+1元排列是基于n元排列来生成的，而如果是生成r排列的话，我们还不能用这样的方法，因为这样生成了多余的结果，还需要剔除，自然不是我们算法想要实现的结果。这里刚好需要所有的结果，何乐不为呢？算法思想也很简单： 可以直接生成一个n元排列，比如0元排列，1元排列 对于n+1元排列即是在n元排列的所有可能位置插入所有可能的元素 怎么理解呢，0元排列就是一个空集,有一个可能插入的位置来形成排列，所以1元排列就是在0元排列的那唯一一个可能插入的位置插入各个可能的元素，也就得到的所有1元排列(也是只有一个元素的子集)，而对于1元排列来说，有两个可能插入的位置(元素左边和右边)，这样除去自身外的所有可能元素分别插入左边和右边即可得到2元排列，以此类推 或者换个描述方式，基本就是我们做排列的时候的思路: 先取一个 再将剩下n-1进行全排列 然后将先取的那个插入到剩下n-1全排列可能的位置上，形成n的排列，以此类推 1234567891011121314151617181920212223export function permutations(baseList)&#123; if(!Array.isArray(baseList))&#123; return &#125; if(baseList.length &lt;= 1)&#123; return [baseList]; &#125; const lessPermutation = permutations(baseList.slice(1)) const firstEl = baseList[0] const resultList = [] lessPermutation.forEach(lessPermuItem =&gt; &#123; // n + 1 个可插入的位置 for(let i = 0, len = lessPermuItem.length; i &lt;= len; i++)&#123; const tempResult = [...lessPermuItem] tempResult.splice(i,0, firstEl) resultList.push(tempResult) &#125; &#125;) return resultList&#125; 算法二 非递归插值法 先取一个排好 然后再从剩下的里面取一个，插入到已经排好的可插入的位置（每个元素的前后），以此类推，直到排列个数够为止 为了避免重复，选择元素的时候，只能选择比当前排列中最大索引还要大的元素 1234567891011121314151617181920212223242526272829303132333435363738export function permutations(baseList)&#123; if(!Array.isArray(baseList))&#123; return &#125; // 一元子集 let baseSubSet = baseList.map(item =&gt; &#123; return [item] &#125;) for(let i = 1, len = baseList.length; i &lt; len; i++)&#123; baseSubSet = baseSubSet.reduce((result, subsetItem,index) =&gt; &#123; const candidates = baseList.filter((baseItem, baseIndex) =&gt; &#123; // 当前集合中元素的最大元素的索引之后的元素 const maxIndex = subsetItem.reduce((result,item) =&gt; &#123; const indexInBase = baseList.indexOf(item); return indexInBase &gt; result?indexInBase: result &#125;,0) return baseIndex &gt; maxIndex &#125;) if(!candidates.length)&#123; return result &#125; // 插入位置为n + 1, 一个元素可以有两个插入位置（前后） for(let i = subsetItem.length + 1; i--;)&#123; candidates.forEach(candiItem =&gt; &#123; let tmpItem = [...subsetItem] tmpItem.splice(i,0,candiItem) result.push(tmpItem) &#125;) &#125; return result &#125;,[]) &#125; return baseSubSet&#125; 算法三 位置移动法这个也是《组合数学》【生成排列】部分提到的方法，为了解决插值法需要一次生成所有排列的问题，这里希望一次生成一个排列，也就是我们实现过程中使用生成器的玩法了，算法内容： 给定一个整数k,我们赋予它一个方向，即在这个证书的上方画出一个指向有或者向左的箭头，考虑[1,2,…n]的一个排列，其中的每一个整数都给定一个方向。如果一个整数k的箭头指向一个与其相邻但比它要小的整数，那么称这个整数k是可移动的。这里可以得出1始终是不能移动的（因为不管是哪个方向，都没有比它小的数），除了下面两种情况，整数n总是可以移动的（很明显）： n是第一个整数，而它的箭头指向左边 n是最后一个整数，而它的箭头指向右边 设置一开始，所有的整数方向都向左 当存在一个可移动的整数时，完成下面的事情： 求出最大的可移动数m 交换m和它的箭头所指向的与它相邻的整数 交换所有满足p &gt; m的整数p上的箭头的方向 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980export function* permutationsDict(baseListLength)&#123; // 初始化方向全部向左 const indictor = [...Array(baseListLength).keys()].map(item =&gt; &#123; return &#123; value: item, direction: false, // false 左边，true，右边，反向的时候直接取非 movable: item &gt; 0 // 左边第一个不能动 &#125; &#125;) yield indictor.map(item =&gt; item.value) // 存在可移动时候循环 while (indictor.some(item =&gt; item.movable))&#123; // 求最大的可移动数 const maxMovable = indictor.filter(item =&gt; item.movable).reduce((result,item,itemIndex) =&gt; &#123; return result.value &gt; item.value ? result: item &#125;,&#123;value: -1&#125;) // 从indicator里面找到的索引才是真实的 const maxMovableIndex = indictor.findIndex((item)=&gt; &#123; return item.value === maxMovable.value &#125;) // 交换相同方向上的相邻两个 if(maxMovable.direction === false)&#123; // 向左边 [indictor[maxMovableIndex - 1],indictor[maxMovableIndex]] = [indictor[maxMovableIndex],indictor[maxMovableIndex - 1]] // 左边第一个不能移动 if(maxMovableIndex - 1 === 0)&#123; maxMovable.movable = false &#125; &#125;else&#123; // 向右边 [indictor[maxMovableIndex + 1],indictor[maxMovableIndex]] = [indictor[maxMovableIndex],indictor[maxMovableIndex + 1]] if(maxMovableIndex + 1 === baseListLength - 1)&#123; maxMovable.movable = false &#125; &#125; //重置方向 indictor.filter(item =&gt; item.value &gt; maxMovable.value).map(item =&gt; &#123; // 这里不会出现 value 为0的，因为有过滤条件 item.direction = !item.direction item.movable = true return item &#125;) // 重新判定受影响的movable indictor.reduce((item1,item2,item2Index) =&gt; &#123; // 可移动的定义 // 在首尾，除了向左在第一个和向右在最后一个都可移动 // 在中间，比在当前方向上的相邻元素值大即为可移动 if(item1.direction === true)&#123; // 向右 item1.movable = item1.value &gt; item2.value &#125; if(item2.direction === false)&#123; // 向左 item2.movable = item2.value &gt; item1.value &#125; return item2 &#125;) yield indictor.map(item =&gt; item.value) &#125;&#125;export function* permutations(baseList)&#123; if(!Array.isArray(baseList))&#123; return &#125; const permuGen = permutationsDict(baseList.length) while (true)&#123; const &#123;value, done&#125; = permuGen.next() if(!done)&#123; yield value.map(item =&gt; baseList[item]) &#125;else&#123; break &#125; &#125;&#125; 算法四 位置交换法 从Python标准库中学来的 记录每一位可变的次数，通过类似进位的方式，当前位遍历完成后，重置当前位的可变更次数，并开始变更左边一位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function* permutationsDict(baseListLength,subLength)&#123; let indicator = [...Array(baseListLength).keys()] // 初始指示器 [0,1,2...subLength-1] let helper = [...Array(subLength).keys()].map(item =&gt; baseListLength - item) // 记录从左到右每一位可变的次数 yield indicator.slice(0,subLength) while (true)&#123; let i = subLength for(;i--;)&#123; helper[i]-- if(helper[i] === 0)&#123; // 重置当前位的变更过程到初始状态 const changed = [...indicator.slice(i+1),...indicator.slice(i,i+1)] indicator.splice(i,changed.length,...changed) helper[i] = baseListLength - i &#125;else&#123; let j = helper[i]; [indicator[i],indicator[baseListLength - j]] = [indicator[baseListLength - j], indicator[i]] yield indicator.slice(0,subLength) break &#125; &#125; if(i &lt; 0)&#123; // 循环透出，表示从右到左的所有位的可变更次数都为0，也就是都过了一遍了，即结束 break &#125; &#125;&#125;export function* permutationsR(baseList,subLength = baseList.length)&#123; if(!Array.isArray(baseList))&#123; return &#125; if(baseList.length &lt; subLength)&#123; return; &#125; const permuGen = permutationsDict(baseList.length,subLength) while (true)&#123; const &#123;value ,done&#125; = permuGen.next() if(done)&#123; break &#125;else&#123; yield value.map(item =&gt; baseList[item]) &#125; &#125;&#125; Python 简单实现(利用标准库)itertools参考文档中文, 英文 python代码地址 1234567from itertools import permutationsimport stringsetA = range(1,7) # [1,2,3,4,5,6]setB = list(string.ascii_uppercase[0:6]) # [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;]print(list(permutations(setA)))print(list(permutations(setB))) 生成包含R个元素的组合或者生成R子集的所有可能排列1需求: 生成集合A和集合B的3元子集的所有可能排列 算法一 直接子集全排列 利用前面的递归插入法可以生成一个集合的全排列 将所有的R子集应用上面的过程 再合并结果就得到了所有的R子集的全排列 12345678910import &#123;combinations&#125; from &quot;./combinations-2.mjs&quot;;import &#123;permutations&#125; from &quot;./permutations.mjs&quot;;export function permutationsR(baseList, subSetLength)&#123; const combinationsR = combinations(baseList,subSetLength) return combinationsR.reduce((result,item) =&gt; &#123; result.push(...permutations(item)) return result &#125;,[])&#125; 算法二 位置交换法 从Python 标准库里面学来的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function* permutationsDict(baseListLength,subLength)&#123; let indicator = [...Array(baseListLength).keys()] // 初始指示器 [0,1,2...subLength-1] let helper = [...Array(subLength).keys()].map(item =&gt; baseListLength - item) // 记录从左到右每一位可变的次数 yield indicator.slice(0,subLength) while (true)&#123; let i = subLength for(;i--;)&#123; helper[i]-- if(helper[i] === 0)&#123; // 重置当前位的变更过程到初始状态 const changed = [...indicator.slice(i+1),...indicator.slice(i,i+1)] indicator.splice(i,changed.length,...changed) helper[i] = baseListLength - i &#125;else&#123; let j = helper[i]; [indicator[i],indicator[baseListLength - j]] = [indicator[baseListLength - j], indicator[i]] yield indicator.slice(0,subLength) break &#125; &#125; if(i &lt; 0)&#123; // 循环透出，表示从右到左的所有位的可变更次数都为0，也就是都过了一遍了，即结束 break &#125; &#125;&#125;export function* permutationsR(baseList,subLength = baseList.length)&#123; if(!Array.isArray(baseList))&#123; return &#125; if(baseList.length &lt; subLength)&#123; return; &#125; const permuGen = permutationsDict(baseList.length,subLength) while (true)&#123; const &#123;value ,done&#125; = permuGen.next() if(done)&#123; break &#125;else&#123; yield value.map(item =&gt; baseList[item]) &#125; &#125;&#125; Python 简单实现(利用标准库)itertools参考文档中文, 英文 python代码地址 1234567from itertools import permutationsimport stringsetA = range(1,7) # [1,2,3,4,5,6]setB = list(string.ascii_uppercase[0:6]) # [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;]print(list(permutations(setA,3)))print(list(permutations(setB,3))) 生成幂集排列1需求：生成集合A和集合B的幂集的所有可能的排列 算法一 循环收集整合法这里恰好能用上在《组合数学》中提到的插入法，因为这里的方法是依赖于递归的思路，n+1元排列是基于n元排列来生成的，而如果是生成r排列的话，我们还不能用这样的方法，因为这样生成了多余的结果，还需要剔除，自然不是我们算法想要实现的结果。这里刚好需要所有的结果，何乐不为呢？算法思想也很简单： 可以直接生成一个n元排列，比如0元排列，1元排列 对于n+1元排列即是在n元排列的所有可能位置插入所有可能的元素 怎么理解呢，0元排列就是一个空集,有一个可能插入的位置来形成排列，所以1元排列就是在0元排列的那唯一一个可能插入的位置插入各个可能的元素，也就得到的所有1元排列(也是只有一个元素的子集)，而对于1元排列来说，有两个可能插入的位置(元素左边和右边)，这样除去自身外的所有可能元素分别插入左边和右边即可得到2元排列，以此类推 那么我们可以搜集每一步的结果的并集即是幂集的全排列 12345678910111213141516171819202122232425262728293031323334353637383940export function permutationsAll(baseList)&#123; if(!Array.isArray(baseList))&#123; return &#125; // 先放入空集 const resultList = [[]] // 一元子集 let baseSubSet = baseList.map(item =&gt; &#123; return [item] &#125;) resultList.push(...baseSubSet) for(let i = 0, len = baseList.length; i &lt; len; i++)&#123; baseSubSet = baseSubSet.reduce((result, subsetItem,index) =&gt; &#123; const candidates = baseList.filter((baseItem, baseIndex) =&gt; &#123; // 当前集合中元素的最大元素的索引之后的元素 const maxIndex = subsetItem.reduce((result,item) =&gt; &#123; const indexInBase = baseList.indexOf(item); return indexInBase &gt; result?indexInBase: result &#125;,0) return baseIndex &gt; maxIndex &#125;) if(!candidates.length)&#123; return result &#125; // 插入位置为n + 1, 一个元素可以有两个插入位置（前后） for(let i = subsetItem.length + 1; i--;)&#123; candidates.forEach(candiItem =&gt; &#123; let tmpItem = [...subsetItem] tmpItem.splice(i,0,candiItem) result.push(tmpItem) &#125;) &#125; return result &#125;,[]) resultList.push(...baseSubSet) &#125; return resultList&#125; 算法二 直接幂集全排列 先利用生成幂集的方法生成幂集 再对每一个幂集生成对应的全排列 整个所有的全排列得到幂集全排列 1234567891011import &#123;combinationsAll&#125; from &quot;./combinations-all.mjs&quot;;import &#123;permutations&#125; from &quot;./permutations.mjs&quot;;export function permutationsAll(baseList)&#123; const allCombinations = combinationsAll(baseList) return allCombinations.reduce((result,item) =&gt; &#123; result.push(...permutations(item)) return result &#125;,[])&#125; Python 简单实现(利用标准库)itertools参考文档中文, 英文 python代码地址 1234567891011121314from itertools import permutationsimport stringsetA = range(1,7) # [1,2,3,4,5,6]setB = list(string.ascii_uppercase[0:6]) # [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;]resultA = []resultB = []for i in range(len(setA) + 1): resultA += permutations(setA,i)print(resultA)for i in range(len(setB) + 1): resultB += permutations(setB,i)print(resultB) 举一反三虽不为我所有，但能为我所用，不会写咋玩？计算机本身就是人类发明的解决计算问题的工具，我们不需要都去搞CPU，不需要都去搞操作系统，我们也不需要都去搞浏览器（前端最常用的工具，我敢说没有之一么），同样的，算法，数据结构，不也是工具么？不知道什么时候，算法给人一种高精尖不可获取的感觉了，是受各大厂面试的影响还是怎么着我不知道，但我觉得可能有点过了。作为开发人员，尤其是前端开发人员来说，这么多年来，真没多少地方真的要特意的去用个什么算法， 如果对一个95%的时间都用不上的工具上纲上线，是不是有点过了？ 但不管什么法，不外乎解决问题的思路，我们的目标不是什么算法，而是解决问题，而算法只是工具或手段。这样一来，我们的焦点重新回到解决问题上来。如果只是为了解决问题，那么用最高效便捷的方法解决了就ok，比如用上面的Python实现。如果项目里面确实要用，那么当然可以自己写，也可以通过转换、引用等的方式来搞。引用的这里不必说了npm i ，这里咱们试试转换。既然有标准库里面的内容，自然是值得借鉴的，当然我这里侧重的不是说它们是权威是大牛写的，而是说既然是标准库一定是经过时间和实践检验的，这才是我们想要的。所以权威和大牛不是重点（人类历史上权威和大牛翻车的已然不在少数），经得住时间和实践验证更可靠。 小目标 把Python标准库里面的排列组合用到咱们JavaScript环境里面来找工具 一开始我想到的是可不可以用WebAssembly ,简单验证了下，一方面兼容性不够好，另一方面工具也不那么好使 然后就找到了直接将Python转JavaScript的工具Transcrypt, 也简单容易上手，当然可能遇到安装包的时候的问题，比如Python版本的问题，这也算Python的基础问题，搞了就完了。 简单安装或者照着文档操作 1pip3 install transcrypt 网络不好也可以直接下载.whl 文件本地安装 1pip3 install Transcrypt-3.9.0-py2.py3-none-any.whl 写点Python代码后面发现这里面的包装可以不用，但作为转换过程的引子或者媒介，辅助把itertools 撬出来。 12345678910111213141516# combinations-permutations-all.pyfrom itertools import combinations,permutationsclass CombPerm: @staticmethod def combinations(*args): return list(combinations(*args)) @staticmethod def permutations(*args): return list(permutations(*args))if __name__ == &#x27;__main__&#x27;: print(CombPerm.combinations([1,2,3,4,5,6],3)) print(CombPerm.permutations([1,2,3,4,5,6],3)) 将Python代码转为JavaScript1transcrypt combinations-permutations-all.py 就会在当前目录下生成对应的JavaScript代码，不过是ES标准的，所以我全部改成了.mjs并替换了相关引用的地方 123456├── __target__| ├── combinations-permutations-all.mjs| ├── combinations-permutations-all.project| ├── itertools.mjs| ├── org.transcrypt.__runtime__.mjs 这里就生成了对应的库文件和我们代码对应的文件，其实只用库文件就OK了 使用新生成的JavaScript版本的库把代码挪到我们想要的地方去，这样就可以直接在JavaScript环境使用Python itertools标准库了 1234├── code-from-python| ├── itertools.mjs| ├── org.transcrypt.__runtime__.mjs| └── test.mjs 12345678910111213141516171819import &#123;permutations,combinations&#125; from &quot;./itertools.mjs&quot;;const combinationsResult = combinations([1,2,3,4,5,6],3)const permutationsResult = permutations([1,2,3,4,5,6],3)// 发现新库的数组多了一个__class__字段，不影响使用，为了不影响打印，这里删掉了combinationsResult.forEach(combiItem =&gt; &#123; delete combiItem.__class__ return combiItem&#125;)permutationsResult.forEach(permuItem =&gt; &#123; delete permuItem.__class__ return permuItem&#125;)console.log(combinationsResult)console.log(permutationsResult) 这样我们就拥有了一套靠谱的经过验证的排列组合的第三方库了。 各种第三方库 基本能想得到的都能找得到 实在找不到，就写一个，让别人能找得到吧 你写的好，我看见了，我写的也好了什么是好？对于一个算法来说，一说到评价标准，我们首先冒出来的就是什么时间复杂度,空间复杂度 对吧，这个也是经常考试的内容，这里咱们不想细说，在另一篇关于Chrome数组排序的里面再说，当然时空复杂度其实对应了一个很重要的标准，那就是实用性。上面我们也写了不少的算法了，都可以作为解决问题的思路，但某些算法或者思路，看起来就像一个玩具，只能用来解题玩玩，一到具体的使用环境就歇菜了，这也就是时空复杂度的要求。当然除了这俩，还有我们默认都具备的特性那就是正确性,还有一个类似的被默认但有可能出岔子的特性是稳定性排序的时候就有用了，Chrome数组排序，多年都存在这个问题，排序不稳定，问题从08年提出，到18年解决，有种十年如一日的感觉。除了这些还有吗？思想很精妙，我们普通人就是没法懂，咋办？思想很简单，写出来的代码我们普通人看不懂，咋办？所有评价算法的标准或者说角度至少可以有如下的内容： 正确性 稳定性/健壮性 时间复杂度 空间复杂度 易读性/易维护性 作为算法或代码是这样的，我们作为打工仔，何尝不是被这样的标准评价的呢？能干活，干活靠谱，考勤要好，干活要快，工资要低，不出岔子，容易相处/服从管理，哈哈，好像突然之间打开了代码和生活之间的通道，让他们融为一体，代码就是生活，生活就是代码。 看看Python标准库排列组合咋写的找呀找呀找源码itertools文档中的说明(Python版本) combinations permutations itertools 在Python源码中的实现(C语言版本) combinations permutations itertools的JavaScript实现 itertools.mjs 就是我们上面搞出来的版本 找到源码开看啦C版本，Python版本，JavaScript版本各有韵味，咱们就找软的(柿子)先捏一捏，倒过来从后到前，由浅入深吧。C语言我现在是感觉是不会了。JavaScript版本的对咱们前端来说看着就有亲近感，但我还想看看Python版本的,因为简单扫了一眼，Python版本的使用了现在各大语言中都大行其道的生成器这个可以在空间复杂度上面有思路的优化，我们要自己写一个版本的话，自然要用上这样的特性（比如通过前序生成后继的时候，空间复杂度可以直接降下来），同时也可以看看有没有办法直接用上一个生成下一个，就像字典序生成的那个一样，当然这是相对理想的YY，也属于特殊场景特殊情况。 说实话我也没啥看源码的方法论，都躺那了，睁开眼睛看呗，不然怎么看，闭着眼睛肯定不行。 找你最喜欢的代码编辑器，把代码敲敲打打，分段分块格式化，先把状态切换过来。 combinationsJavaScript源码1234567891011121314151617export var combinations = function (iterable, r) &#123; let tail = list(iterable); function recurse(tail, molecule, rNext) &#123; for (let index = 0; index &lt; len(tail) - rNext; index++) &#123; let newMolecule = molecule.concat(tail.slice(index, index + 1)); if (rNext) recurse(tail.slice(index + 1), newMolecule, rNext - 1); else result.append(tuple(newMolecule)) &#125; &#125; let result = []; recurse(tail, tail.slice(0, 0), r - 1); return list(result)&#125;; combinationsJavaScript源码解析 做了数据转换（这个因为是Python转过来的缘故），所以可以当做没有 主体就是定义了一个递归函数，然后给了个容器，在递归的过程中把正确的内容塞容器里面 再看这个递归函数 传入了三个参数，第一个是元素列表，第二个是当前临时组合，第三个是还需要迭代的次数（或者说还需要选几个） 执行的过程是 先选一个 如果不够（迭代次数不为0），那就从剩下的里面把剩下的选上（递归） 够了的话就存一个 这里用循环来控制的最终结尾，而我们前面实现的过程中，没关注是否够数，只关注了是否只剩一个元素 permutations JavaScript源码123456789101112131415161718192021222324252627282930313233export var product = function () &#123; let args = [].slice.apply(arguments); if (args.length &amp;&amp; args[args.length - 1].hasOwnProperty(&quot;__kwargtrans__&quot;)) var repeat = args.pop()[&quot;repeat&quot;]; else var repeat = 1; let oldMolecules = [tuple([])]; for (let i = 0; i &lt; repeat; i++) for (let arg of args) &#123; let newMolecules = []; for (let oldMolecule of oldMolecules) for (let atom of arg) newMolecules.append(tuple(oldMolecule.concat(atom))); oldMolecules = newMolecules &#125; return list(oldMolecules)&#125;;export var permutations = function (iterable, r) &#123; if (r == undefined) try &#123; r = len(iterable) &#125; catch (exception) &#123; r = len(list(iterable)) &#125; let aProduct = product(iterable, __kwargtrans__(&#123;repeat: r&#125;)); let result = []; for (let molecule of aProduct) if (len(set(molecule)) == r) result.append(molecule); return list(result)&#125;; permutations Javascript 源码解析 前后格式转化不用说了 先调用了一个product 算出了一个接过来 然后把每一个结果去重，把没有重复的（去重后没元素丢失的）加入最终结果 再来看看这个product笛卡尔积，如果知道笛卡尔积的概念，那就什么都知道了。如果不知道可以调试看看它的结果也就知道了。还是想知道就看看源码，看看这个四重循环都干了啥。 这里其实用笛卡尔积做了可重复元素的全排列，也就是第一个元素从集合A中取，第二个还从A中取，第r个还从A中取，最后得到r的全排列，但这里面有重复元素，所以要去重，去掉有重复的 重复遍数用一个循环没问题；笛卡尔积的参数是多个集合，所以循环集合没有问题；笛卡尔积是要在原有的结果上加内容，所以循环原有结果没问题；最后一个循环就是从每一个集合里面取每一个元素。类似于咱们前面的baseXXX = baseXXX.reduct 这个过程是搞多了，然后再去除多余的，类似于咱们的全集筛选法,只是利用了已有工具快速完成，但算法思路本身效率一般。 combination Python源码1234567891011121314151617181920def combinations(iterable, r): # combinations(&#x27;ABCD&#x27;, 2) --&gt; AB AC AD BC BD CD # combinations(range(4), 3) --&gt; 012 013 023 123 pool = tuple(iterable) n = len(pool) if r &gt; n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) combination Python源码解析 扫一眼可以看到，使用了咱们在【字典序生成法】里面用到了的数据映射的方法，只需要变化位置数组，需要的数据按照标志位从对应源数据中对应位置取就行，这样就可以不用关心数据类型和数据结构了，都可以按整形数处理 同时这里是根据一定的规律生成前序和后继的结果，知道前一个就知道后一个，这样就只计算和存储一个 这里非常巧妙的利用了for-else 穿透条件结束算法 算法解析 比如[1,2,3,4,5,6]中选择，三个数的组合，那么第一个组合是[1,2,3],最后一个组合是[4,5,6] 同时根据我们的思维逻辑，[1,2,3]的下一个是[1,2,4]（这里面默认包含了字典序的，这样不容易出错）这里变化的只是第 i 个元素 而到了[1,2,6]的下一个是[1,3,4]，这时第一个变化的数之后的每一个数都会跟着变，二期是等差递增的，所以就有了j循环 剩下的就是根据下标生成对应的产出，也就是yield语句对应的内容 既然都学了，也可以自己造一个了，参考前面的【字典序生成法-生成器版-参考答案】，可以作为一个参考答案 permutation Python源码12345678910111213141516171819202122232425def permutations(iterable, r=None): # permutations(&#x27;ABCD&#x27;, 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC # permutations(range(3)) --&gt; 012 021 102 120 201 210 pool = tuple(iterable) n = len(pool) r = n if r is None else r if r &gt; n: return indices = list(range(n)) cycles = list(range(n, n-r, -1)) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return permutation Python源码解析 扫一眼可以看到，使用了咱们在【字典序生成法】里面用到了的数据映射的方法，只需要变化位置数组，需要的数据按照标志位从对应源数据中对应位置取就行，这样就可以不用关心数据类型和数据结构了，都可以按整形数处理 这里可以看出做了两件事，一件是全排列，一件是r子集的全排列，可以直接先让r = n 得到一个集合的全排列的算法 算法解析 看起来是交换的思路，这里运用了一个辅助结构来记录当前每一位可变的次数，从左到右排列的每一位可选的次数一次递减，刚好是一个倒序的值 从右边起第一个可变的开始，依次替换可选的值，直到当前位置的可替换值都替换完成，这时候需要类似进位那样变更左边一位了，变更左边一位的同时，右边的可变位数会重置；重置的过程也会重置整个序列，回到本轮开始的状态 看完源码学到啦有了前面的体验，发现我们原来写的算法还有提升空间，相应的问题也解决了，优化版本的代码还是写到前面吧。 同时也发现，标准库的代码也不是都那么的高精尖，也有普通人，这样就放心了，要去对开源库做贡献，现在就去吧。 排列组合还有哪些可以折腾的？如果元素可重复，那么排列组合是一个什么样的情况，是不是笛卡尔积就可以作为一种全排列的思路了？ 可重复元素组合算法一 递归加入法算组合的时候的直接思路 先从n个中选一个 再从n个中选r-1个 将先选的那一个和每一个r-1的组合组合起来，就是r子集，以此类推 重复和不重复元素算法之间差别只是选择r-1 子集的范围 123456789101112131415161718192021export function combinationsRepeat(baseList,subSetLength)&#123; if(!Array.isArray(baseList))&#123; return &#125; if(subSetLength === 1)&#123; return baseList.map(baseItem =&gt; [baseItem]) &#125; const resultList = [] baseList.forEach((baseItem,baseIndex) =&gt; &#123; const lessCombi = combinationsRepeat(baseList.slice(baseIndex),subSetLength - 1) lessCombi.forEach((lessCombiItem,lessCombiIndex) =&gt; &#123; resultList.push([baseItem,...lessCombiItem]) &#125;) &#125;) return resultList&#125; 可重复元素全排列算法一 笛卡尔积 r个相同集合，按顺序每个取一个，有多少种取法 12345678910111213141516function production(argList, repeat = 1)&#123; let base = argList.map(item =&gt; [item]) for (let i = 0; i &lt; repeat - 1; i++)&#123; base = argList.reduce((result,argItem) =&gt; &#123; base.forEach(baseItem =&gt; &#123; result.push([...baseItem,argItem]) &#125;) return result &#125;,[]) &#125; return base&#125;export function permutationsRepeat(baseList)&#123; return production(baseList,baseList.length)&#125; 算法二 递归排列法 将每一个元素与r-1个元素的全排列进行排列，形成新的r排列，以此类推 有元素重复，不能用插入法，也不能直接用数组元素个数来判断，所以需要加个长度来结束递归 1234567891011121314151617181920export function permutationsRepeat(baseList, subPermuLength = baseList.length)&#123; if(!Array.isArray(baseList))&#123; return &#125; if(subPermuLength === 1)&#123; return baseList.map(baseItem =&gt; [baseItem]) &#125; const lessPermutation = permutationsRepeat(baseList,subPermuLength - 1) const resultList = [] // 因为有重复，所以这里不能用插入，而要用拼接 baseList.forEach(baseItem =&gt; &#123; lessPermutation.forEach(lessItem =&gt; &#123; resultList.push([baseItem,...lessItem]) &#125;) &#125;) return resultList&#125; 简单总结排列组合的几类需求 求一个集合的r 子集，也就是从n个里面选r个的选法，这个是组合 求一个集合的所有子集，也就是幂集，是r从0到n的r子集的并集，这也是组合 求一个集合的r子集的全排列，也就是从n个里面选r个的每一个选法的全排列的并集，这当然是排列 求一个集合的所有子集的全排列，也就是幂集的全排列，是r从0到n的r子集的全排列并集，这当然也是排列 对于所有的排列组合，元素可重复和不可重复，是两种不同的场景，所以上面的场景可翻倍 实现/求解方式 从上面的例子可以看出来，不同的场景都可以有不同的处理方式，也有些方式感觉就像是为某些场景量身定制的一样 可以有几个原子实现，其他实现可以基于此来实现 求集合的r子集的方法，用此即可求幂集 求集合的r排列的方法，用此即可求幂集的全排列 求集合的全排列的方法，用此配合求r子集的方法，可以求r全排列，也可以求幂集全排列 可以利用生成器的思想，做到随用随取 具体问题具体分析","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://rawbin-.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rawbin-.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排列","slug":"排列","permalink":"http://rawbin-.github.io/tags/%E6%8E%92%E5%88%97/"},{"name":"组合","slug":"组合","permalink":"http://rawbin-.github.io/tags/%E7%BB%84%E5%90%88/"}]},{"title":"chrome浏览器下音视频autoplay的情况记录","slug":"browser/2018-12-13-chrome-autoplay","date":"2021-12-31T02:37:59.949Z","updated":"2021-12-31T02:37:59.949Z","comments":true,"path":"browser/2018-12-13-chrome-autoplay/","link":"","permalink":"http://rawbin-.github.io/browser/2018-12-13-chrome-autoplay/","excerpt":"","text":"常见的几个错误在chromium源码中列出来了 12345678const char kWarningUnmuteFailed[] = &quot;Unmuting failed and the element was paused instead because the user &quot; &quot;didn&#x27;t interact with the document before. https://goo.gl/xX8pDD&quot;;const char kErrorAutoplayFuncUnified[] = &quot;play() failed because the user didn&#x27;t interact with the document first. &quot; &quot;https://goo.gl/xX8pDD&quot;;const char kErrorAutoplayFuncMobile[] = &quot;play() can only be initiated by a user gesture.&quot;; 文档 写的相对比较清楚，三个条件 静音的自动播放都可以 带声音的播放有条件 用户在当前域名有交互（点击、触摸等等）的可以自动播 在桌面端的Chrome中，符合用户偏好历史的可以自动播，在 chrome://media-engagement/ 可以看 移动端用户加入首屏的站点或者桌面端已安装的PWA可以自动播 顶层的Frame可以允许子级iframe的带声音自动播放，用iframe的 allow=&quot;autoplay&quot;属性，前提是顶层frame满足带声音播放的条件 检测方法可参考 这个项目（不是很新的） 的DemoPage","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"音视频","slug":"音视频","permalink":"http://rawbin-.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"自动播放","slug":"自动播放","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE/"}]},{"title":"前端页面加载那些事","slug":"security/2018-12-11-web-page-loading","date":"2021-12-31T02:37:59.949Z","updated":"2021-12-31T02:37:59.949Z","comments":true,"path":"security/2018-12-11-web-page-loading/","link":"","permalink":"http://rawbin-.github.io/security/2018-12-11-web-page-loading/","excerpt":"","text":"浏览器对页面的加载主体可以从HTML规范入手，这里是一个入口，也是一个大合集。 页面加载过程参考 URL解析参考 资源请求参考 内容解析HTML解析参考 脚本解析script元素 脚本解析 页面渲染参考","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"页面加载","slug":"页面加载","permalink":"http://rawbin-.github.io/tags/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD/"},{"name":"页面优化","slug":"页面优化","permalink":"http://rawbin-.github.io/tags/%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/"}]},{"title":"前端安全那些事","slug":"security/2018-12-11-fe-security","date":"2021-12-31T02:37:59.949Z","updated":"2021-12-31T02:37:59.949Z","comments":true,"path":"security/2018-12-11-fe-security/","link":"","permalink":"http://rawbin-.github.io/security/2018-12-11-fe-security/","excerpt":"","text":"浏览器安全参考","categories":[],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"http://rawbin-.github.io/tags/CSRF/"},{"name":"XSS","slug":"XSS","permalink":"http://rawbin-.github.io/tags/XSS/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://rawbin-.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"移动端页面真机或模拟器调试方法分场景攻坚","slug":"dev-tools/2018-12-15-mobile-debug-method","date":"2021-12-31T02:37:59.949Z","updated":"2021-12-31T02:37:59.949Z","comments":true,"path":"dev-tools/2018-12-15-mobile-debug-method/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2018-12-15-mobile-debug-method/","excerpt":"","text":"前言废话不多说，磨刀不误砍柴工，欲善其事，先利其器~ 调试场景案例详解内网穿透具体是什么就不介绍了，简单说就是让外网能访问内网 为什么要内网穿透？开发调试过程，要让外网访问内网，比如跟外网服务联调，微信相关开发、公众号，支付宝开发，其他平台第三方对接等等，如何让外网的服务能访问到内网的接口，甚至是本地开发的接口，就很有价值了。 解决联调域名的问题，解决端口映射的问题，接口https协议要求的问题。 如何实现一个下面列举了很多工具，这里以ngrok为例 启动步骤 到ngrok 官网,下载 ngrok 可执行文件 到可执行文件的目录执行./ngrok http 8080 启动成功就可以得到对应的一个域名 123Web Interface http://127.0.0.1:4040Forwarding http://02e2-114-113-63-81.ngrok.io -&gt; http://localhost:8080Forwarding https://02e2-114-113-63-81.ngrok.io -&gt; http://localhost:8080 外网访问https://02e2-114-113-63-81.ngrok.io 就可以访问到本机的8080端口的服务 比如我们启动了weinre或者chii服务，这个时候就可以访问 https://02e2-114-113-63-81.ngrok.io/target.js 访问到本机的8080端口，同时解决了要调试的移动端页面是https 而本机8080启动的是http服务导致无法访问的问题。 如何自己实现一个 可以自己搭建一个ngrok服务器 可以通过一个外网可访问的内网域名，并反向代理到自己的机子对应的服务上，比如咱们测试环境的14机器就可以 HTTPS相关调试安装相关证书 用什么代理就装什么的证书，用Charles就装Charles的，用whistle就装whistle的证书 如果运气好装不上，就换设备换系统，换不了就想办法换成HTTP的，避免这个证书的问题 Android 7以上系统证书安装需要费点劲，先试试能行就行，不行就想其他办法，比如Root手机类似于iOS的越狱 鸿蒙目前没有明确的办法，adb可能好使 资源映射或者数据mock 将特定规则的内容映射到本地devServer 解决需要频繁部署的问题，使用Charles的Map Remote可以搞定或者whistle的匹配规则，原理类似；当然也可以映射到其他机器，比如A环境的接口映射到B环境都行 将特定规则的资源从本地获取（比如数据mock，本地资源替换等等），这个就是Charles的Map Local功能，对于whistle来说还是规则匹配，也可以使用类似的插件 使用场景 端上的网络代理到本机的代理服务上（比如Charles或者whistle），本机代理服务通过各种规则映射到不同的地方 常见场景 SPA资源通过Map Remote打到本地devServer上，避免了需要侵入环境加调试代码的问题，同时可以减少部署 线上资源映射到本地，比如CDN资源需要变更，本地直接测试，不需要多次发布 开发联调数据mock 常用工具数据代理类 Charles whistle Fiddler 各种proxy等等 比如ykit 中的jerryproxy anyproxy 调试辅助综合类 weinre 腾讯 vConsole 微软 vorlonjs Eruda spy-debugger chii 各种浏览器自带调试工具等等 内网穿透 操作常用的有 向日葵，TeamViewer，花生壳，蒲公英等等 开发常用 ngrok系列 ngrok官方 ittun Sunny-Ngrok 小米球-ngrok TunnelNat natapp 其他可用的 lanproxy goproxy 连数据线真机（模拟器）调试(需要app可调试包)Android 端 webview调试 App代码中要打开webview调试 1WebView.setWebContentsDebuggingEnabled(true); Android设备 设置=&gt;打开手机开发者模式(不同手机不一样) Android设备 设置=&gt;打开USB调试 使用可传送数据的数据线（市面上有些数据线被阉割仅可以充电，无法传数据，自然也无法调试）链接需要调试的设备（手机，Pad等），并允许调试 电脑端Chrome浏览器使用chrome://inspect 查看可被调试的应用页面 iOS端App webview调试 iOS 设备设置=&gt;Safari浏览器=&gt;高级=&gt; 打开 网页检查器 电脑端Safari浏览器 偏好设置=&gt;高级=&gt; 显示开发菜单 使用可传送数据的数据线（市面上有些数据线被阉割仅可以充电，无法传数据，自然也无法调试）链接需要调试的设备（手机，Pad等） 电脑端Safari浏览器 开发菜单=&gt;找到对应的设备=&gt;用于开发，并在iOS设备上信任此电脑端 电脑端Safari浏览器 开发菜单=&gt;找到对应设备下的对应页面，使用Safari进行调试 也可以使用其他工具使用Chrome DevTools进行调试 ios-webkit-debug-proxy, 用什么工具都一样，只要满足对应协议提供相应数据就行 鸿蒙 Webview调试 暂时还没有找到~ 腾讯X5系Android Webview调试 使用TBS Studio 进行调试，参考文档 下载安装，按步骤要求操作就行（连接手机需要使用能传输数据的数据线） 其他强制调试型Android 使用 Xposed 和 WebViewDebugHook iOS 类似 GlobalWebInspect 鸿蒙 当前无解 通用的H5调试工具alert——永远的一哥 懂的都懂不多说 console——一家独大 配合各种工具使用 weinre 系列 weinre 早期的思想 spy-debugger 集成weinre 并做功能增强，比如加了自动注入，以及一些相关增强 chii 使用了较新的Web Inspect或者说ChromeDevTools，更好使","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://rawbin-.github.io/tags/iOS/"},{"name":"鸿蒙","slug":"鸿蒙","permalink":"http://rawbin-.github.io/tags/%E9%B8%BF%E8%92%99/"},{"name":"安卓","slug":"安卓","permalink":"http://rawbin-.github.io/tags/%E5%AE%89%E5%8D%93/"},{"name":"Android","slug":"Android","permalink":"http://rawbin-.github.io/tags/Android/"},{"name":"苹果","slug":"苹果","permalink":"http://rawbin-.github.io/tags/%E8%8B%B9%E6%9E%9C/"},{"name":"调试","slug":"调试","permalink":"http://rawbin-.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"移动端","slug":"移动端","permalink":"http://rawbin-.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"页面","slug":"页面","permalink":"http://rawbin-.github.io/tags/%E9%A1%B5%E9%9D%A2/"},{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"http://rawbin-.github.io/tags/HarmonyOS/"}]},{"title":"前端异步那些事","slug":"async/2018-12-11-fe-async","date":"2021-12-31T02:37:59.948Z","updated":"2021-12-31T02:37:59.948Z","comments":true,"path":"async/2018-12-11-fe-async/","link":"","permalink":"http://rawbin-.github.io/async/2018-12-11-fe-async/","excerpt":"","text":"ECMAScript 标准中的异步回调函数这是函数作为一等公民或者一类对象带来的特性，函数可以像对象一样独立使用，可以作为参数和返回值等等。 常见的浏览器的DOM事件，NodeJS中的文件读写等等，都会在回调函数中有一个关键的第一个参数来保留现场和传递流程，比如Event对象，err对象等等。 Promise通过返回Promise对象来实现链式调用，通过链式调用的方式来处理异步的结果，从一定程度上解决了回调地狱（异步回调嵌套太深）的问题，同时也提供了.all,.race等多种实用的方法来解决异步操作中的并行和并发的问题。 Generator作为ESx的特性提供出来，一方面不是必须的（因为ES5照样能搞所有事，这么多年也是这么玩的），另一方面ES6也加入了更多底层或者元编程相关的内容。 生成器几个新的特性： 控制代码内部执行 控制代码内部返回 控制代码内部抛异常 这让我们对代码执行有更多可控的支点，最常用的使用场景就是async/await这个语法糖的异步代码同步写法，一方面让代码逻辑清晰，另一方面也解决了不管是回调函数还是Promise也存在的回调地域问题。 async/await从语法结构上来看是用了同步代码的表达方式支持了异步代码的表达，避免了回调层级深的问题，同时也让流程更加简化清晰。 浏览器中的异步浏览器自身是没有标准的(全靠事实标准)，但实现了很多其他的标准ECMAScript，HTML5，HTTP，DOM，XML等等了，还增加了一些非标准的但作为事实存在的标准，比如conosle。 回调函数 浏览器环境 12function getData(callback)&#123;&#125;getData((data) =&gt; &#123;&#125;) // 传入的参数就是 Node环境 12345678var fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;test.txt&#x27;,(err,data) =&gt; &#123; if(err)&#123; console.log(&#x27;readFile error:&#x27;,err) &#125;else&#123; console.log(&#x27;fileData:&#x27;, data) &#125;&#125;) setTimeout/setInterval这个是属于HTML规范的一部分，但为了兼容开发人员使用习惯，NodeJS环境中也是有实现的。 从规范中可以看到一些信息： setTimeout/setInterval 函数可以有两种重载形式， 当第一个参数为函数的时候，可以传递可选的第二个参数和其他任意参数，第二个参数之后的所有参数都会传递给第一个参数（这个函数）作为参数 当第一个参数为字符串的时候，可以传递可选的第二个参数，其他再多的参数传递都会被忽略 定时器可以嵌套，但嵌套超过5层的嵌套，调用间隔会设置为最少4ms chromium的实现 定时器不能保证都能准确按时执行，可能影响因素是CPU负载，其他任务等等 有对应的clearTimeout/clearInterval清除对应的定时器，参数为setTimout/setInterval的返回值 Promise作为ESx规范的内容，用来获取延迟计算的最终的结果，可以通过链式调用的方式来定义流程。 GeneratorESx规范 async/awaitESx规范 异步I/OHTML页面中的各种资源加载 XMLHTTPRequest(严格说也算I/O)异步数据请求规范 postMessage参考 Server Send Event参考 FetchAPI内置数据请求封装 SCRIPT异步脚本加载脚本加载 脚本解析 其他常见事件 DOM事件监听 ResizeObserver ReportingObserver PerformanceObserver IntersectionObserver MutationObserver NodeJS中的异步回调函数setTimeout/setIntervalPromiseGeneratorasync/await作用和用法跟浏览器类似，都是对ECMAScript的实现，只是明确下这是两种实现，对于非标准的内容可能有差异，比如console ，即使标准的内容也可能有差异，因为是两种实现，有标准不一定都会遵守，这个就涉及到商业化和产品化以及发展历史的事，到现在浏览器对于HTML5还是有不一致的实现，Node对于ECMAScript还是不完全实现或者实现方式不一样等等。 综合说明关于宏任务和微任务宏任务归类 setTimeout setInterval I/O 事件 postMessage setImmediate request.AnimationFrame UI渲染 微任务归类 Promise.then MutationObserver process.nextTick 标准之外在整个Web发展的过程中，浏览器占了很大的比重也起了很关键的作用，从各种各样的浏览器厂商的出现和消失，也可见一班。奇怪的是，虽然浏览器的发展现在越来越趋一化，就连独占鳌头的微软老大也都忍痛割爱易弦更张拥抱开源Chromium，但浏览器目前为止，是没有一个标准的，虽然浏览器实现了很多标准比如ECMAScript，HTML5，HTTP，DOM，XML等，浏览器本身是没有一个标准规范的。 在浏览器发展历程从早期的野蛮生长，到后来的相互学（抄）习（袭），到后来的百花齐放，导致前端开发者苦不堪言，就在十年前，我还在MathEdit项目中处理各种IE6、7、8，Safari，Opera，Firefox以及各种当时的国产浏览器的兼容性问题（那会Chrome貌似还是0.x.y的beta版本），当时处理的方式还是通过UA判断指定的浏览器，这种方法后来被浏览器特性检测取代，但又由于各种浏览器开发商作弊的行为（比如特性检测说是支持某些HTML5的特性，但实际调用的时候没有的这种情况），还是没有一个相对通用的解决办法。 综上，简单总结，浏览器对标准的实现本身具有滞后的特点，同时呢也有对标准实现有差异的地方，因为标准也是有大部分浏览器厂商参与制定的，标准也不一定能被标准实现，比如HTML5就有两个标准不是（分分合合，现在又合好了，参考）。而剩下的非标准的内容，比如宿主环境的API(比如console.log 到底是同步还是异步，不同浏览器可能不一样，浏览器和Node环境可能不一样)，这个就看浏览器厂商的心情和排期了。浏览器兼容性问题对开发者来说已经是好太多了，但这个问题也会是一个常态化存在的问题，原因是上面说到的多方面的。 核心内容解析浏览器中的实现脚本加载script 元素默认为JavaScript，也就是type=text/javascript，除了每一个HTML元素都有的公共属性（当前22个）和公共事件（当前66个）外还有如下特有的属性值（动态修改属性值无效）： src 资源地址 type 脚本类型，早期还有其他的不同的type，比如vbscript,jscript等，现在几乎统一为JavaScript。 省略或者设置为type/javascript表示使用传统的脚本加载方式，这种方式受async和defer配置的影响（在设置了src的情况下）。 设置为module就按ES module的方式加载，此时不受defer属性的影响，但还是受async属性的影响（不管设置没设置src属性）。设置其他值，元素内容会被认为是数据块而不处理。 nomodule 在支持module的浏览环境中禁用module支持 async 脚本准备好就执行，不阻塞加载过程 defer 延迟执行，加载过程完成后统一执行 crossorigin 设定处理跨越的配置，可选值`` integrity 在子资源完整性检查中的完整的元数据 referrerpolicy 元素初始化的资源加载中的资源引用策略 脚本加载的异步 &lt;script&gt; 解析到script后暂停解析，直接加载对应资源，加载完成后执行，执行完成后再继续解析 &lt;script defer&gt; 解析到script后继续解析，并行加载对应资源，等页面解析完成后，执行对应的资源 &lt;script async&gt; 解析到script后继续解析，并行加载相应资源，加载完成后直接执行，执行完之后再继续解析 &lt;script type=module&gt; 解析到script后继续解析，并行加载对应资源，加载完成后并行加载资源所有对应的依赖，等页面解析完成后直接执行 &lt;script type=module async&gt; 解析到script后继续解析，并行加载对应资源，加载完成后并行加载资源所有对应的依赖，依赖加载完成后直接执行，执行完成后再继续解析 脚本动态加载 动态修改script元素的属性无效 如果使用document.write写入的话，会立即执行并阻塞页面解析，使用innerHTML和outterHTML属性的话，脚本不执行 script元素API text 属性获取或者设置当前元素的脚本内容 support 方法判断是否支持classic和module的方法 事件循环规范参考 事件循环是用来协调事件、用户交互、脚本、渲染、网络等等用户代理中的各个事务的机制。不同的地方可能有不同的事件循环。 每一个事件循环可以有一个或者多个事件队列，一个事件队列就是一组任务，虽然说事件队列，但事件队列的访问方式不完全按照队列的访问方式来运作，比如处理一个队列的时候是取第一个可执行的任务来执行，而不是取第一个任务（第一个可能不可执行）。微任务队列不是任务队列。 任务任务分类事件分发一个事件对象到一个事件目标对象，通常由一个【绑定任务】(deticated task)来做，不是所有的事件都用任务队列来分发，也有许多在其他任务中分发。 解析HTML解析器解析文本词法到并处理解析结果，也是一个典型的任务。 回调调用回到函数通常也是一个【绑定任务】 资源调用当一个场景获取了一个资源，如果获取过程是非阻塞的情况，那么接下来在这个资源部分或者全部可用情况下的处理过程，是用一个任务来完成得的 DOM操作变更有些元素用对DOM操作进行响应的任务，比如在元素插入到文档的时候 任务源 DOM操作 用户交互 网络 历史记录 任务的要素 步骤 任务要做的事的先后内容 任务源 用来分组和序列化相关的任务 文档 任务对应的文档，如果在浏览器窗口的事件循环的话 脚本执行 一组用来跟踪任务脚本执行过程的环境配置对象 每一个任务都有一个特定的事件源，每一个事件源都跟一个特定的任务队列绑定。 每个事件循环都有一个当前执行的任务，可以是一个任务或者是null ,初始化是null 也常被用来处理重入。 每个事件循环都有一个微任务队列，初始为空，微任务是一个口语化的对一个用微任务入队算法创建的任务的一个指代。 每个事件循环都有一个微任务检查点的标志位，初始化为false ，通常用来阻断对微任务检查点重入的调用。 每个window事件循环都有一个高精度的时间戳来记录上一次渲染的世界，初始为0。 每个window事件循环都有一个高精度的时间戳来记录上一次空闲周期的开始时间，初始为0。 任务入队（全局任务，元素任务，微任务都类似） 如果没有指定事件循环，就用默认的（从当前调用上下文推断出来的） 如果没有指定文档，就用默认的（从当前调用上下文推断出来的） 创建一个新的任务对象，并设置steps,source,document 字段 设置新任务的脚本执行环境配置对象为空 把新任务追加到根当前任务源关联的任务队列上。 微任务也有可能被转移到常规任务队列中，如果初始化过程，它[spins the event loop] 就会被转移，这也是唯一的一起用事件源,事件文档,脚本执行环境配置对象集，执行微任务检查点的算法会忽略他们。 处理模型事件循环比如从进入执行后一直持续的执行下面的步骤： 设taskQueue为事件循环中一个有至少一个可执行任务的任务队列 设oldestTask 为taskQueue中第一个可执行的任务，并把这个任务从taskQueue中删除 把事件循环当前正执行的任务设置为oldestTask 设taskStartTime为当前的高精度时间 执行oldestTask的步骤 设置事件循环中当前正执行的任务为null 微任务：执行微任务检查点 如果事件循环的微任务检查点标识为true则返回 设微任务检查点标识为true 循环处理直到微任务队列为空 设oldestMicrotask为事件循环的微任务队列的出队结果 设事件循环的当前正执行任务位oldestMicrotask 执行oldestMicrotask 设事件循环当前正执行任务为null 对每一个当前事件循环负责的环境设置对象，通知受拒绝的期约 清理 IndexDB事务 执行ClearKeptObjects() 设置事件循环的微任务检查点标识为false 设hasARenderingOpportunity 为false 设now 为当前的高精度时间，也为任务执行结束时间 执行如下步骤报告任务的执行时间 设置顶级的浏览上下文为空集合 对oldestTask的每一个环节设置对象，追加设置对象的顶级浏览上下文到顶级浏览上下文 报告长时间的任务，传入taskStartTime,now,顶级浏览上下文，oldestTask 更新渲染，如果当前事件循环是window事件循环的话，执行： 设docs为所有的关联代理为当前事件循环的文档对象，除非遇上如下情况，否则可以任意排序： 任意一个文档B的浏览上下文的容器文档为A，那么B需要再A的后面 如果有两个文档A和B的浏览上下文都是另一个容器文档C的子浏览上下文，那么文档A和B在列表中的顺序需要与文档C的节点树的影子包含树顺序一致。 下面这些文档的处理顺序都要按照这个列表中文档的顺序来 渲染时机：从docs中删除浏览上下文没有渲染时机的文档 是否有渲染时机：当用户代理可以展示浏览上下文的内容给用户，考虑到硬件刷新率的限制和性能优化的节流，也要考虑内容是否可展现及时是在视区外 浏览上下文的渲染时机是基于像显示器的刷新率的硬件限制和其他想页面性能或者当前文档是否是visible的的状态共同决定的，渲染时机一般发生在有规律的时间间隔。 本规范没有授权给任何一个选择渲染时机的模型，比如，如果一个浏览器想要达到60Hz的刷新率，那么渲染时机在1s中有60次；如果一个浏览器达没法维持这个刷新率， 它可以降低到30Hz的刷新，而不是偶尔丢帧。类似的，如果一个浏览上下文不可见，那么用户代理可以选择把刷新率降到4Hz或者更低。 如果删完可不渲染的docs还是非空的话，那么设置hasARenderingOpportunity 为true,并且设置事件循环的上次渲染时机的为taskStartTime 非必要渲染：从docs中删除如下条件的文档 用户代理确认更新文档浏览上下文对视觉效果没影响，同时文档的动画动画帧回调为空 从docs中删除用户代理确认因为各种原因要跳过的渲染 对每一个全激活的文档，如果浏览上下文是顶级上下文的话，刷新autofocus 对每一个全激活的文档，执行resize的步骤，传入now作为时间戳 对每一个全激活的文档，执行scroll的步骤，传入now 作为时间戳 对每一个全激活的文档，执行媒体查询和变更报告，传入now作为时间戳 对每一个全激活的文档，更新动画和发送事件，传入now作为时间戳 对每一个全激活的文档，执行全屏的步骤，传入now作为时间戳 对每一个全激活的文档，如果用户代理检测到备用存储关联的CanvasRenderingContext2D或者OffscreenCanvasRenderingContext2D，上下文丢失，那么需要执行上下文丢失的步骤： 设canvas为上下文的canvas属性，如果上下文是CanvasRenderingContext2D或者关联的OffscreenCanvas对象 设上下文的上下文丢失属性为true 重置渲染上下文到默认状态 设shouldRestore为canvas上contextlost的事件触发结果，并设置cancelable属性为true 如果shouldRestore为false，结束步骤 尝试通过上下文的属性及他们与上下文的关联创建一个备用存储，如果失败了结束步骤 设置上下文的上下文丢失属性为false 在canvas上触发一个叫contextrestored的事件 对每一个全激活的文档，执行文档的动画帧回调，传入now作为时间戳 对每一个全激活的文档，执行文档的更新交叉监视，传入now作为时间戳 对每一个docs中的文档调用标记绘制时间算法 对每一个全激活的文档，更新文档和上下文的渲染和用户界面来表达当前的状态 如果下面这些条件都成立的话，那么执行后面的步骤 条件 当前是window event loop 在当前全激活的文档事件循环的任务队列里面没有任务 事件循环的微任务队列为空 hasARenderingOpportunity是false 步骤 设computeDeadline为下面的步骤 设deadline 为事件循环的上一次空闲期开始时间+50，（+50）是为了保证视觉暂停的下限 设hasPendingRenders为false 对每一个当前事件循环的同循环窗口windowInSameLoop执行如下步骤 如果windowInSameLoop的动画帧回调不为空，或者用户代理确认windowInSameLoop可能有没有处理的渲染更新，设置hasPendingRenders为true 设置timerCallbackEstimates为windowInSameLoop的激活计时器的值 对每一个timerCallbackEstimates的 timeouteDeadline，如果timeoutDeadline比deadline小，把timeoutDeadline设置为deadline 如果hasPendingRenders 为 true： 设nextRenderDeadline为事件循环的上一次渲染时机的时间。刷新率跟硬件相关也跟实现相关，比如一个60Hz的刷新率，nextRenderDeadline为大约为上次渲染时机时间之后16.67ms 如果nextRenderDeadline比deadline少，就返回nextRenderDeadline 返回deadline 对当前事件循环的同循环窗口中的每一个窗口，用computeDeadline对窗口执行开始空闲时间的算法 如果这是一个woker事件循环，然后： 如果这个事件循环的代理的单个领域的全局对象是一个受支持的DedicatedWorkerGlobalScope，并且用户代理确认在这个时候更新它的渲染有用的话，就执行如下： 设now为当前的高精度时间 对DedicatedWorkerGlobalScope执行动画帧回调，传入now作为时间戳 更新绑定的worker的渲染来表达当前的状态 如果在事件循环的任务队列里面都没有任务并且WorkerGlobalScope对象的closing标识为true的话，就销毁当前事件循环，终止步骤，继续执行工作脚本的步骤 源码体验chromium中源码在 src/base/message_loop/message_pump_default.cc 中，直接在网页上看可以简单点. 如果要下载下来的话也行，需要准备50G左右的磁盘空间，如果要编译的话占用空间会更多，同时有几个事要做，翻墙的梯子，给shell配梯子，给git配梯子，然后应该就可以一路通过了。 直接看Run方法 1234567891011121314151617181920212223242526272829303132void MessagePumpDefault::Run(Delegate* delegate) &#123; AutoReset&lt;bool&gt; auto_reset_keep_running(&amp;keep_running_, true); for (;;) &#123;#if defined(OS_APPLE) mac::ScopedNSAutoreleasePool autorelease_pool;#endif Delegate::NextWorkInfo next_work_info = delegate-&gt;DoWork(); bool has_more_immediate_work = next_work_info.is_immediate(); if (!keep_running_) break; if (has_more_immediate_work) continue; has_more_immediate_work = delegate-&gt;DoIdleWork(); if (!keep_running_) break; if (has_more_immediate_work) continue; if (next_work_info.delayed_run_time.is_max()) &#123; event_.Wait(); &#125; else &#123; event_.TimedWait(next_work_info.remaining_delay()); &#125; // Since event_ is auto-reset, we don&#x27;t need to do anything special here // other than service each delegate method. &#125;&#125; 从上面代码可以看出 这是一个死循环（所谓的事件循环或者这里的消息循环），进到这里面就要一直执行，直到退出 有能立即执行的任务就立即执行 从上面代码所在目录的文件可以看出 针对不同平台和不同场景消息循环都有些差异化的实现 不同的任务类型可参考 更多内容可以参考chromium文档 像事件循环这样公共的内容代码都在src/base里面，比如任务相关的文档 NodeJS中的实现NodeJS的依赖 NodeJS指南 定时执行 setTimeout(定时器) clearTimeout setInterval(定时器) clearInterval setImmediate clearImmediate 在本轮事件循环的所有I/O操作之后执行 在下一轮事件循环的所有定时器操作之前执行 process.nextTick 在所有Immediate和所有I/O操作之前执行 原子执行，过程不能中断 事件循环 NodeJS初始化事件循环，处理完输入脚本之后，剩下的就是事件循环来处理了 每一个事件阶段都有一个先进先出回调队列，虽说是队列但不一定按队列的形式实现，比如定时器就是找到点的先执行，不一定是队首的元素 当事件循环执行到每个阶段，会在允许情况下执行该阶段的所有操作，然后进入下一个阶段 要么执行完所有在队列里面的回调 要么执行完最大的回调个数限制的回调数 事件循环中的每一个回调（操作）完成后，如果有process.nextTick设定的回调，要立即全部执行完（这个看起来是亲生的，相比setImmediate这个后娘养的来说），再进行下一个回调 事件循环的每个阶段及其执行内容 timers 执行setTimeout和setInterval设定的回调； 只能保证不会提前执行，有可能被其他任务拖延（还没轮到这个阶段，设定的时间已经过去） pending callbacks 执行除timers，check，close callbacks之外的所有回调 idle, prepare 内部使用的阶段 poll timers执行也在这里控制 新的I/O事件的处理，此处可能会阻塞 队列非空，执行当前阶段到最大数量限制或者队列置空 队列为空 如果check不为空，执行check中的全部内容； 如果check为空，等待回调添加，然后立即执行 检查timers中到点的回调，并执行timers阶段 check setImmediate设定的回调（相比起来后娘养的） 在poll完成时执行 close callbacks I/O关闭的回调，比如socket.on(‘close’,’…’) 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ 闲扯淡NodeJS官方文档比较setImmediate个process.nextTick： process.nextTick在当前阶段立即执行 setImmediate在下一轮事件循环的时候尽早执行 如果把tick理解为一次回调的话，就没有那一段说的那个问题了，immediate再快也要等到高优先级的搞完了才到，而tick可以理解为秒针动一次（一个回调） ，一次循环不能为一个tick 源码体验从NodeJS官方文档，可以看到NodeJS是使用libuv来实现事件循环的，对应的源码在src/deps/uv/src/unix/core.c 不同平台也有不同实现 同样的也是看run方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; r = uv__loop_alive(loop); if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; uv__update_time(loop); uv__run_timers(loop); ran_pending = uv__run_pending(loop); uv__run_idle(loop); uv__run_prepare(loop); timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); uv__io_poll(loop, timeout); /* Run one final update on the provider_idle_time in case uv__io_poll * returned because the timeout expired, but no events were received. This * call will be ignored if the provider_entry_time was either never set (if * the timeout == 0) or was already updated b/c an event was received. */ uv__metrics_update_idle_time(loop); uv__run_check(loop); uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it&#x27;s omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; /* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; 可以看到除了跟文档描述一致的处理结构之外，还有不同情况的特殊处理。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"http://rawbin-.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"前端视角切入原生之快速开发——鸿蒙、Android、iOS、Flutter","slug":"cross-platform/2018-12-03-fe-to-native-apps","date":"2021-12-31T02:37:59.948Z","updated":"2021-12-31T02:37:59.948Z","comments":true,"path":"cross-platform/2018-12-03-fe-to-native-apps/","link":"","permalink":"http://rawbin-.github.io/cross-platform/2018-12-03-fe-to-native-apps/","excerpt":"","text":"本次切入侧重点开发调试页面布局，屏幕设备适配路由、页面切换模块化、生命周期网络资源请求本地数据存储上线流程Flutter开发调试 开发工具 参考 调试工具 参考 页面布局，屏幕设备适配 系统不支持自动适配，需要自己封装，比如有类似于flexible的 screenutil 封装。 通用组件库 参考 dart ui material ui 路由、页面切换 路由配置 路由构建 路由跳转 模块化、生命周期网络资源请求 http dart:io httpClient 本地数据存储 简单本地数据存储 shared_preference 上线流程鸿蒙开发调试 到 这里 下载开发工具DevEco-Studio，这里才有Mac版本，学堂里面只有Windows版本， 开发文档 在这里 调试 参考, JS开发用console打日志，Java开发用HiLog打日志 页面布局、屏幕设备适配用JS开发 屏幕宽度720px，参考 使用媒体查询进行适配 参考 通用组件 参考 JS UI 说明 参考 用Java开发 Java UI 说明 参考 Java UI Demo 参考 路由、页面切换用JS开发 使用router路由模块 参考 用Java开发 页面间跳转 参考 页面部件间跳转 参考 模块化用JS开发 使用自定义组件 组件相关属性 参考 组件间通信 参考 用Java开发 页面和页面组件 参考 自定义组件 参考 生命周期用JS开发 组件和App生命周期 参考 用Java开发 页面及页面组件生命周期 参考 网络资源请求用JS开发 使用fetch模块 参考 本地数据存储用JS开发 使用storage模块 参考 用Java开发 简单存储 参考, ，及相关的数据库和文件存储 上线流程用JS开发 编译构建配置 参考 应用发布流程 参考","categories":[],"tags":[{"name":"Native","slug":"Native","permalink":"http://rawbin-.github.io/tags/Native/"},{"name":"iOS","slug":"iOS","permalink":"http://rawbin-.github.io/tags/iOS/"},{"name":"原生","slug":"原生","permalink":"http://rawbin-.github.io/tags/%E5%8E%9F%E7%94%9F/"},{"name":"鸿蒙","slug":"鸿蒙","permalink":"http://rawbin-.github.io/tags/%E9%B8%BF%E8%92%99/"},{"name":"harmonyos","slug":"harmonyos","permalink":"http://rawbin-.github.io/tags/harmonyos/"},{"name":"安卓","slug":"安卓","permalink":"http://rawbin-.github.io/tags/%E5%AE%89%E5%8D%93/"},{"name":"Android","slug":"Android","permalink":"http://rawbin-.github.io/tags/Android/"},{"name":"苹果","slug":"苹果","permalink":"http://rawbin-.github.io/tags/%E8%8B%B9%E6%9E%9C/"},{"name":"Flutter","slug":"Flutter","permalink":"http://rawbin-.github.io/tags/Flutter/"}]},{"title":"前端视角切入原生之语言特性——鸿蒙、Android、iOS、Flutter","slug":"cross-platform/2018-12-04-fe-to-native-languages","date":"2021-12-31T02:37:59.948Z","updated":"2021-12-31T02:37:59.948Z","comments":true,"path":"cross-platform/2018-12-04-fe-to-native-languages/","link":"","permalink":"http://rawbin-.github.io/cross-platform/2018-12-04-fe-to-native-languages/","excerpt":"","text":"Flutter——Dart语言特性 函数是一级对象 支持动态类型，支持类型系统 注释 // 单行注释 /// /**/ 多行注释 变量变量声明 var 关键字定义变量，分号分隔语句。 int a = null; 或int ? a;支持 null初始值 null safe Object 或者 dynamic 用于可变类型 final 或者 const 表示不可修改 late 修饰符表示现在不初始化 num 类型表示 int 或者 double 运算符 ? 变量定义时初始为null ，如int ? a; ? 函数定义时为最后的可选形参(命名形参String ? name和位置形参[int ?b, int ? c]) ?. 属性访问时避免null被取值, 如 obj?.prop ?? 只有前面值为null才起作用 如a ?? = 3; print(null ?? 5); .. 调用方法放弃函数返回值直接返回对象引用，实现类jq的级联效果 typedef 可以重新定义类型 数据结构 列表 List [1,2,3] 集合 Set {1,2,3} 键值对 Map {‘a’:1,’b’:2} 范型 &lt;T&gt; 支持参数限制 &lt;T extends BaseClass&gt; 模块模块定义 函数定义带返回值类型，支持箭头函数 mixin 定义的模块，可以用with 在类之间共享，可以多个 支持类单继承使用extends 和 多接口实现 implements 用类来充当接口，可以用abstract关键字定义抽象类 模块导入 import &#39;dart:math&#39; 导入系统模块 import &#39;package:path/to/file&#39; 导入第三方模块 import &#39;path/to/file&#39; 导入文件 import &#39;path&#39; as xx 异步 Future表达Promise 支持 await-async 异常捕获 rethrow 可以抛出 123456789try&#123;&#125; on IOException catch(e)&#123;&#125; catch (e)&#123; rethrow;&#125; finally&#123;&#125;","categories":[],"tags":[{"name":"Native","slug":"Native","permalink":"http://rawbin-.github.io/tags/Native/"},{"name":"iOS","slug":"iOS","permalink":"http://rawbin-.github.io/tags/iOS/"},{"name":"原生","slug":"原生","permalink":"http://rawbin-.github.io/tags/%E5%8E%9F%E7%94%9F/"},{"name":"鸿蒙","slug":"鸿蒙","permalink":"http://rawbin-.github.io/tags/%E9%B8%BF%E8%92%99/"},{"name":"harmonyos","slug":"harmonyos","permalink":"http://rawbin-.github.io/tags/harmonyos/"},{"name":"安卓","slug":"安卓","permalink":"http://rawbin-.github.io/tags/%E5%AE%89%E5%8D%93/"},{"name":"Android","slug":"Android","permalink":"http://rawbin-.github.io/tags/Android/"},{"name":"苹果","slug":"苹果","permalink":"http://rawbin-.github.io/tags/%E8%8B%B9%E6%9E%9C/"},{"name":"Flutter","slug":"Flutter","permalink":"http://rawbin-.github.io/tags/Flutter/"}]},{"title":"JavaScript模块标准化那些事","slug":"modules/2018-12-11-fe-js-module","date":"2021-12-31T02:37:59.948Z","updated":"2021-12-31T02:37:59.949Z","comments":true,"path":"modules/2018-12-11-fe-js-module/","link":"","permalink":"http://rawbin-.github.io/modules/2018-12-11-fe-js-module/","excerpt":"","text":"CommonJS参考wiki这里说标准也不那么恰当，但在Node.js环境中，比起前面的各种MD来说，又更近了一步，更加统一，以至于体验上会更加规范，但还不是规范，至少可以做到只要是Node，都遵守一致的模块定义，所有使用者也能达成共识。 规范说明（从当前最新Node.js 17.x官方文档而来） 每个单文件被当做一个模块 函数和对象都添加到模块对象的特殊属性 exports的属性上，也就是 exports.xx = yy ，module.exports 也可以赋一个新的值，重新模块的所有内容，也就是module.exports = xx。 模块本地的变量是私有的，因为模块在Node.js 中会被一个叫做模块包装器的函数包裹，（这个函数也就是形参带module,exports…等等的那个函数） 模块系统是在require 模块中实现的 如果直接运行一个模块，require.main 字段被设置为当前运行的模块对象，也就是可以用require.main 来判断当前运行的模块 require.main === module 无法使用require去加载.mjs的模块(.mjs是Node.js 支持 ECMAScript Module的方式，详情见下文) 想要获取确切的require加载的模块的文件名，需要用require.resolve() 它获取的是被加载的模块的绝对路径 模块首次被加载后会被缓存下来，只要路径相同，每次require拿到的都是同一个对象的引用，虽然对象一样，但对象属性可能不一样，这也就是循环引用出现的地方。要让一个模块每次获取的内容不一样，导出一个函数并每次执行那个函数。 不同地方的同一个表达式require(&#39;foo&#39;)可能加载的不是同一个模块，还可能是从node_module中加载的，这个时候要区分的话可以用require(&#39;node:xx&#39;)明确指定从核心模块加载 在大小写敏感的文件系统中，大小写不一样的模块返回的是不同的对象 模块分类 文件模块 如果能加载精确路径就直接加载 没有精确路径，引用路径中带有/,./,../开头的，会和.js，.json,.node组合尝试加载 其他的不是核心模块就是node_modules的模块 目录模块 目录包含package.json上有非null非undefined的main字段值 目录包含index.js或者index.node文件 require函数的几个属性 main当前执行的模块的Module对象 extensions 默认加载的扩展及对应的加载函数.js,.json,.node【已废弃】 cache 当前已加载的模块映射,key为模块绝对路径，value为Module对象 resolve 需要用require.resolve() 它获取的是被加载的模块的绝对路径（比如require(&#39;./xx&#39;) 到底是.js,.json,.node?） 模块加载原理 使用类似如下的包装器，将模块代码在函数范围内执行 这样就可以将模块的作用域隔离开来，不会出现相互影响（如果是全局的话就会） 123(function(exports, require, module, __filename, __dirname) &#123;// Module code actually lives in here&#125;); exports 当前模块导出对象，是module.exports的引用 require函数 main当前执行的模块的Module对象 extensions 默认加载的扩展及对应的加载函数.js,.json,.node 【已废弃】 cache 当前已加载的模块映射,key为模块绝对路径，value为Module对象 resolve 需要用require.resolve() 它获取的是被加载的模块的绝对路径（比如require(&#39;./xx&#39;) 到底是.js,.json,.node?） module当前模块对象 children 当前模块的依赖模块（准确的说当前模块加载前需要加载的模块，有些依赖可能不是第一时间要用） exports 默认是模块系统生成的对象，需要的话可以重新赋值，赋值需要立即执行，放到异步回调里面不好使 filename 模块绝对路径 id 通常是解析的文件名，但不一定，比如你试试看 parent 【已废弃】用module.echildren替代 isPreloading 是否是在预加载阶段 isloaded 是否加载完，或者说是不是在加载阶段 path 一般为模块所在目录绝对路径 paths 模块的查找路径 require 可以简单理解为绑了this的模块 模块加载过程详情可参考模块加载伪代码, [模块解析算法伪代码]（https://nodejs.org/docs/latest-v17.x/api/esm.html#resolver-algorithm-specification require加载模块的规则 举例在Y路径（当前路径），调用require(X) 如果X是核心模块(node源码./lib目录下的)，直接返回，核心模块总是优先加载，可以直接使用require(&#39;node:xxx&#39;)可以跳过require的缓存，直接取系统模块，哪怕缓存中有这个模块也会跳过 如果是X以/开头，从文件系统根路径加载找 如果X以./ 或者/或者../ 开头，先【按文件加载】，找不到就【按目录加载】，还是找不到就抛找不到的异常 如果X以#开头，【加载包导入】 【加载包自身】 【加载node_modules】 抛出找不到的异常 require(X) 加载模块的场景 按文件加载 如果X是个文件，以带后缀的文件全路径加载 如果X.js 是个文件，以JavaScript代码的方式加载 如果X.json是个文件，解析文件内容为JavaScript对象 如果X.node是个文件，以二进制扩展的形式加载（process.dlopen()） 加载索引 如果X/index.js是个文件，以JavaScript代码的方式加载 如果X/index.json是个文件，解析文件内容为JavaScript对象 如果X/index.node是个文件，以二进制扩展的形式加载（process.dlopen()） 【按目录加载】 如果X/package.json是个文件，解析这个文件，并查找main字段 如果不是真值，就【加载索引】； 如果main字段为真值，就以相对路径的方式按【文件加载】，不行再按【索引加载】，还不行就抛出找不到的异常 【加载node_modules】 确定【模块加载路径】 如果路径中已经以node_modules结尾node不动，没有的话Node会拼上node_modules去查找 当前目录找不到就找上一级目录，直到找到模块或者找到文件系统根目录为止 NODE_PATH环境变量可以增加更多的查找路径 Node还会查找其他几个路径 $HOME/.node_modules $HOME/.node_libraries $NODE_PREFIX/lib/node 循环尝试如下加载 【加载包导出】 【按文件加载】 【按目录加载】 【模块加载路径】 把传入的路径，除了node_module外都滤出来，然后加上node_modules,一起作为包查找的路径 【加载包导入】 找到最近的作用域（@xx/），找不到就返回 如果找到SCOPE/package.json 并且imports是null或者undefined 直接返回 找到【包导入解析】的匹配，并【解析ESM匹配】 【加载包导出】 先试着以@scope/xx的组合解析路径 如不不匹配或者路径的package.json文件不存在，直接返回 找到package.json 就解析exports 字段，如果字段是null或者undefined直接返回 找到【包导出解析】，并【解析ESM匹配】 【加载包自身】 找到最近的作用域（@xx/），找不到就返回 如果SCOPE/package.json的exports字段为null或者undefined,直接返回 如果SCOPE/package.json的name字段不是路径的第一段，直接返回 找到【包导出解析】，并【解析ESM匹配】 【解析ESM匹配】 如果是精确加载，就加载全路径 如果不是精确加载，先【按文件加载】，不行再【按目录加载】，还是不行就抛找不到异常 常见的坑循环引用 各种模块相互引用的过程中，如果你看到xxx is not defined但明明就躺那，那么就需要看看是不是循环引用了 模块导出无效123456789exports.a = 1exports.b = 2exports.c = 3exports = &#123;a:1,b:2&#125; // 这个会导出无效，但在当前模块范围内又是有效的module.exports = &#123;a:1,b:2&#125; // c = 3 也无效了// 最佳实践，这样写，明确表示你懂了且确认了module.exports = exports = xxx 如下代码可帮助理解 1234567891011121314function require(/* ... */) &#123; const module = &#123; exports: &#123;&#125; &#125;; ((module, exports) =&gt; &#123; // Module code here. In this example, define a function. function someFunc() &#123;&#125; exports = someFunc; // At this point, exports is no longer a shortcut to module.exports, and // this module will still export an empty default object. module.exports = someFunc; // At this point, the module will now export someFunc, instead of the // default object. &#125;)(module, module.exports); return module.exports;&#125; Module API 区别于前面的module对象，用得少 require(&#39;module&#39;).builtinModules Nodejs内置模块列表 require(&#39;module&#39;).createRequire require(&#39;module&#39;).syncBuiltinESMExports() require(&#39;module&#39;).findSourceMap() require(&#39;module&#39;).syncBuiltinESMExports() ECMAScript Module 规范参考 ES Module规范ES的模块规范是静态化的，这使得模块在编译的过程中就能确定依赖关系和输入输出。这个跟CommonJS和AMD有所区别，他们是运行时才能确定。import &#123;xxx,yyy,zzz&#125; from &#39;pkg&#39; 这样的方式在编译时就能确定依赖关系，可以直接做静态分析，这也是tree shaking的基础。同时因为是静态化的，所以import和export要求在代码的顶层，不能出现在任何块和分支逻辑中。同时代码放在哪里都跟放在文件前面一个效果，可类比JS的变量提升，词法作用域，也都是静态玩法。 ES Module默认是严格模式，严格模式更加可控和安全，也避免了不少问题。 ES Module主要依据export 和 import 两个关键字来实现，一个模块就是一个单独的文件跟CommonJS一致，只有用export导出的内容可以明确被访问到。 模块导入会有缓存，同一个模块多次导入也只会加载一次。 export 用于导出直接导出变量声明 可以单个导出需要的变量 123456// test-export.mjsexport const a = 1export var b = 2export function test()&#123;&#125;export class Person&#123;&#125;export let obj = &#123;&#125; 通过导出对象的形式一次性导出（推荐，集中而且可以重命名） 可以一次性导出所有需要导出的内容 这个时候可以在导出的时候重新指定名称 123456789101112// test-export-all.mjsconst a = 1var b = 2function test()&#123;&#125;class Person&#123;&#125;let obj = &#123;&#125;export &#123; a,b, Person, test as testFunc, obj as exportedObj&#125; 默认导出 上面的导出方式，都要求模块使用方（导入方）知道导出的内容，有时候会带来不便 可以将模块提供的内容直接导出为一个默认对象，作为模块的整体入口 默认导出的可以是对象，函数，类等等变量值 导出的对象名称在模块外不再有效，都是default一个引用入口 123456789101112// test-export-default.mjsconst a = 1var b = 2function test()&#123;&#125;class Person&#123;&#125;let obj = &#123;&#125;export default &#123; // 注意带不带default的区别，区别很大 a,b, Person, test as testFunc, obj as exportedObj&#125; 动态的数据 不像CommonJS导出的数据是一份拷贝，ES Module导出的数据是动态绑定，可以理解为引用，可以感知数据的变化。 1234567export let changing = 123setInterval(() =&gt; &#123; changing += 111&#125;,2000)// 导入changeing 的模块，可以在不同的时候取到不同的值 区别 export 导出的是声明，各种声明 export default导出的是值 import 用于导入导入命名导出的内容 可以选择性的导入部分内容 导入的时候可以重新命名，尤其是在有重名的情况下很有用 导入的名称是只读的，不能对齐进行重新绑定，但可以更改引用值，有点类似于C++的常指针，不可改变指针指向，但可以改变指针值（如果值是可变的话） 1234567import &#123;a,b,test&#125; from &#x27;./test-export.mjs&#x27;import &#123;a,b,Person,test as testFunc,obj as exportedObj&#125;// a = 2 // 报错obj.a = a // ok 但尽量不这样做，否则就跟全局变量污染没区别，到处都在改 直接导入自执行模块 1import &#x27;pkg&#x27; 直接导入所有模块内容12import * as all from &#x27;./test-export.mjs&#x27; // 导人非defaut的所有命名导出console.log(all) 导入模块默认1import moduleDefault as defaultTest from &#x27;./test-export-default.mjs&#x27; 同时导入默认和声明的值1import moduleDefault as defaultTest, &#123;a,b test as testFunc&#125; from &#x27;./test-export-default.mjs&#x27; import + export 组合代理命名导出1234export &#123;a,b as bb&#125; from &#x27;./test-export.mjs&#x27;// 可以简单理解为，但当前模块是无法引用到a,b的import &#123;a,b&#125; from &#x27;./test-export.mjs&#x27;export &#123;a,b as bb&#125; 代理全导出123export * from &#x27;./test-export.mjs&#x27; // 导出非defaut的所有命名导出export * as xxx from &#x27;./test-export.mjs&#x27; 代理默认导出12export &#123;default&#125; from &#x27;./test-export-default.mjs&#x27; //导出默认export &#123;default as mine &#125; from &#x27;./test-export-default.mjs&#x27; //默认导出转命名导出 动态加载import() 前面说到的import 和export都是静态化的，无法处理类似于运行时的逻辑，比如在特定情况下才加载某些模块，这个类似于NodeJS的require是动态的，同时也区别于require因为动态import()是同步的。 适合场景是特定条件下才加载特定的模块，也适合模块路径是动态计算出来的场景。 返回的是一个Promise，对象是整个模块的导出内容，可以用对象结构的方式方便的获得，因为是Promise，自然也可以跟async 函数配合使用或者使用Promise的所有特性。 浏览器环境ES Module的支持指定type字段为module加载ES Module 浏览器会执行异步加载，页面渲染完再执行，类似于defer 如果有多个，按顺序执行 如果加了async属性，会加载完成立即执行，保持原有的行为一致性 模块是在模块自己的作用域执行 1&lt;script type=&quot;module&quot; src=&quot;./es-module.js&quot;&gt;&lt;/script&gt; 也可以进行页面内嵌 1234&lt;script type=&quot;module&quot;&gt;import mymodule from &#x27;./es-module.js&#x27;// do something&lt;/script&gt; 参考文档ESM加载图解 以及 浏览器 ES Module实现规范 Demo环境ES Module支持参考文档ESM加载图解 以及 浏览器 ES Module实现规范 NodeJS环境ES Module支持从官方文档中可以看出，NodeJS从9.x(官方文档入口最早只找到了9.x，可能更早) 开始实验性部分支持ECMASCript Module，到12.x移除了实验特性，正式支持。 NodeJS中明确的ECMAScript Module 以.mjs结尾的文件，这时不管package.json中的配置，优先级最高可以无视其他配置 以.js结尾，且最近的package.json文件中有个根级别的值为module的type属性 带有--input-type=module 给--eval传递的字符串，或者通过管道从STDIN传递给node的字符串 123node --input-type=module --eval &quot;import &#123; sep &#125; from &#x27;path&#x27;; console.log(sep);&quot;echo &quot;import &#123; sep &#125; from &#x27;path&#x27;; console.log(sep);&quot; | node --input-type=module 除了以上三条之外，都是默认的 CommonJS规范的模块 NodeJS中明确的CommonJS 以.cjs结尾的文件，这时不管package.json中的配置，优先级最高可以无视其他配置 以.js结尾，且最近的package.json文件中有个根级别的值为commonjs的type属性 带有--input-type=commonjs 给--eval传递的字符串，或者通过管道从STDIN传递给node的字符串 123node --input-type=module --eval &quot;import &#123; sep &#125; from &#x27;path&#x27;; console.log(sep);&quot;echo &quot;import &#123; sep &#125; from &#x27;path&#x27;; console.log(sep);&quot; | node --input-type=module NodeJS中的包package.json 包是一个带有package.json文件的目录及其子目录，除去那些包含了package.json或者node_modules的子目录 package.json中的type字段值决定了Nodejs如何解析.js文件，如果没有属性或者值为commonjs则解析为CommonJS，如果值为module则解析为 ECMAScript Module 这些区分会在如下场景 直接运行 node xxx 通过import 声明引入 通过import()表达式引入 package.json字段定义下面这些是NodeJS运行时在用的字段，其他字段可能再其他工具像npm, eslint 等工具中使用，但NodeJS会忽略的，比如常用的scripts,dependencies,devDependencies,husky,lint-staged,eslintConfig ,babel等等 name 包名，包管理器用来作为包的名字的字段，也是包内命名导入的时候用的字段 main 在不支持exports的Node版本中或者exports没指定的情况下默认的包加载的模块 packageManager 给corepack 这个包管理器的管理器用的字段，用来作为当前包开发时推荐的包管理器 type 用来指定同时支持CommonJS和ES Module的Node版本加载.js文件的时候的价值方式，为commonjs时是用CommonJS加载，为module时作为ES Module加载。当然在不支持ES Module的版本中无效。 exports 包导出或者条件导出的配置，指定了的话，就会限制哪些内容可以在当前包中能被引用，虽然有些限制，但还是可以通过绝对路径引入打破这种限制 imports 包导入，为包内的的导入指定快捷方式，字段Key要以#开头 NodeJS中包的导入导出 包的入口定义 在package.json中 main字段 一直支持的字段，但没法区分不同的版本 exports字段，对main字段的扩展或增强，而且优先级更高，但为了兼容低版本的Node，main字段还是要写。 但这个字段的引入，原来用package.json引入包的方式没有定义的其他引入就不支持了，所以这个可能是破坏性变更，因为原来main就一个入口，而exports给的是可选的多个入口且只能是这里面给的这些入口，所以如果有其他的入口要暴露，都只能一个一个的都写上。比如像这样: 1234567891011&#123; &quot;name&quot;: &quot;my-mod&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &quot;./lib/index.js&quot;, &quot;./lib&quot;: &quot;./lib/index.js&quot;, &quot;./lib/*&quot;: &quot;./lib/*.js&quot;, &quot;./feature&quot;: &quot;./feature/index.js&quot;, &quot;./feature/*&quot;: &quot;./feature/*.js&quot;, &quot;./package.json&quot;: &quot;./package.json&quot; &#125;&#125; 也可以将exports字段设置为./*这样的，这倒是能够很方便暴露更多的入口，但也失去了这个字段的特性。不但没起到概括包入口的作用，还需要用包的地方明确写清楚绝对全路径 12import feature from &#x27;my-mod/feature&#x27; 就变成了import feature from &#x27;my-mod/feature/index.js&#x27; 这个要求就有点高了 出现上面的情况的原因是这个包检查不是强制的检查，或者没有完全堵死，使用绝对路径还是可以引用任何模块的，但用模糊路径或者包路径就被限制了。所以后续使用exports导出包内容就会类似如下: 1234567891011121314// 单入口&#123; &quot;main&quot;: &quot;./main.js&quot;, &quot;exports&quot;: &quot;./main.js&quot;&#125;// 多入口&#123; &quot;main&quot;: &quot;./main.js&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &quot;./main.js&quot;, &quot;./submodule&quot;: &quot;./src/submodule.js&quot; // 只有这样定义了的，才能用 import submodule from &#x27;xxx/submodule&#x27; &#125;&#125; imports包内部包引入的定义 允许映射外部包 必须以#开头来消除歧义，区分于正常的包引入 1234567891011121314// package.json&#123; &quot;imports&quot;: &#123; &quot;#dep&quot;: &#123; &quot;node&quot;: &quot;dep-node-native&quot;, &quot;default&quot;: &quot;./dep-polyfill.js&quot; &#125; &#125;, &quot;dependencies&quot;: &#123; &quot;dep-node-native&quot;: &quot;^1.0.0&quot; &#125;&#125;import &#x27;#dep&#x27; imports 和 exports 的规则 * 是简单的字符串替换 exports配置快捷方式 123456789&#123; &quot;exports&quot;: &#123; &quot;.&quot;: &quot;./main.js&quot; &#125;&#125;&#123; &quot;exports&quot;: &quot;./main.js&quot;&#125; NodeJS包条件导出条件导出 exports 顾名思义，不同条件不同的导出内容，CommonJS和ECMAScript都支持，举个简单的例子，如果希望通过require和 import获取不同内容的话，可以做如下配置： 123456789// package.json&#123; &quot;main&quot;: &quot;./main-require.cjs&quot;, &quot;exports&quot;: &#123; &quot;import&quot;: &quot;./main-module.js&quot;, &quot;require&quot;: &quot;./main-require.cjs&quot; &#125;, &quot;type&quot;: &quot;module&quot;&#125; 条件导出的规则 import 当用import或则import()导入包的时候适用，或者其他的ECMAScript 模块加载器的顶级导入或者解析操作的时候适用，这个时候会忽略模块的格式（直接用ECMAScript的方式加载）跟require互斥，也就是一码归一码各是各 require当用require加载包的时候的时候适用，虽然也会忽略模块的格式，但模块还是要能用require()加载才行，支持的格式为CommonJS,JSON和原生的扩展，但不支持ECMAScript Module，因为require()支持不了ECMAScript Module，跟import互斥，也就是一码归一码各是各 node NodeJS环境使用的时候适用，可以是CommonJS或者ECMAScript Module，这个条件要写在import 和require之后 node-addons 和node类似，也是在NodeJS环境下适用，这个是用来给原生的C++扩展用的，可以用--no-addons禁用 default 通用的兜底方案，可以是CommonJS和ECMAScript Module，这个条件永远要写在最后，而且一定要带上，为了使其他不支持前面条件的环境也能用，也可以避免其他JS环境为了支持这个包而伪装成支持的环境（比如像改浏览器UA这样的玩法，或者浏览器为了支持某些特性检查直接将检查标识设置为true，但其实没实现，这种对开发小哥来说就坑大了。） 这里面配置Key的顺序很重要，前面的比后面的优先级高。基本是越具体的越靠前面。那么问题来了，作为一个JSON文件，到JavaScript里面就是一个对象，对象的key顺序是咋搞的？先把问题撂这儿，后面我们统一搞搞 条件导出也可以扩展到导出子模块，只要是用上面这些关键字就会被识别，举例如下： 12345678910&#123; &quot;main&quot;: &quot;./main.js&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &quot;./main.js&quot;, &quot;./feature&quot;: &#123; &quot;node&quot;: &quot;./feature-node.js&quot;, &quot;default&quot;: &quot;./feature.js&quot; &#125; &#125;&#125; 这些规则在NodeJS中适用，但在其他的环境中不一定适用 import 和require也还是有些问题，具体看一看下面 自定义导出条件 在运行NodeJS的时候，可以给传包导入导出的自定义解析条件，会在标准条件之后解析，可以传多个 1node --conditions=development --conditions=xxx main.js NodeJS本身只支持import ，require，node，node-addons，default这几个条件，其他的都会被忽略，自定义导出条件要运行的环境自己解析。 导出条件的定义NodeJS支持的条件： browser 实现包括DOM API的浏览器API标准子集的环境 development 只用在开发环境的入口，与production互斥 production 用在生产环境的入口，与development互斥 平台指定的像deno，electron，react-native这样的条件也可以用，但现在还没实现，也不是明确支持的。其他条件也可以通过pull request的方式往里面加，新加的条件有些要求： 条件清晰不含糊，所有实现方能看懂 条件的使用场景以及必要性要清晰 要有充足的既有的实现使用场景 条件之间广义上不能有冲突 条件要通用，不能是公司级别的或者应用级别的 用名称自引用包（感觉没什么卵用）当一个包的package.json中有exports字段，在包内可以用包名引用包导出的内容，没导出的没法引用，带@SCOPE的包也支持。实例如下 123456789101112131415161718192021// package.json&#123; &quot;name&quot;: &quot;a-package&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &quot;./main.mjs&quot;, &quot;./foo&quot;: &quot;./foo.js&quot; &#125;&#125;// ./a-module.mjsimport &#123; something &#125; from &#x27;a-package&#x27;; // Imports &quot;something&quot; from ./main.mjs.// ./a-module.jsconst &#123; something &#125; = require(&#x27;a-package/foo&#x27;); // Loads from ./foo.js.// ./another-module.mjs// Imports &quot;another&quot; from ./m.mjs. Fails because// the &quot;package.json&quot; &quot;exports&quot; field// does not provide an export named &quot;./m.mjs&quot;.import &#123; another &#125; from &#x27;a-package/m.mjs&#x27;; 同时支持CommonJS/ECMAScript Module的包在NodeJS还没支持ECMAScript Module之前，一个常见的玩法让一个包同时支持CommonJS和ES Module是在package.json 中main字段配置CommonJS的支持，在module字段配置ECMAScript Module的支持。这就可以让NodeJS用CommonJS，其他的像打包工具这样的就用ECMAScript Module，因为NodeJS忽略module字段（现在还是忽略的）。 NodeJS现在可以运行ECMAScript Module了，一个包也可以同时支持CommonJS和ECMAScript Module了，可以用不同的标识符比如pkg和pkg/es-module 或者在同一个标识符下用条件导出。现在ECMAScript 不需要转换就可以在NodeJS里面玩了。 同时支持CommonJS和ES Module的风险因为const pkgInstance = require(&#39;pkg&#39;) 和 import pkgInstance from &#39;pkg&#39; 是两个不同的东西（因为NodeJS用两个不同的东西来实现他们了），如果一个包同时支持两种方式的话，可能会有一些怪异的行为，倒不是说同一个应用里面会有两种导入方式（也不是没可能，可能性大大的有，一会儿想用import一会儿想用require，一个人想用import一个人想用require），而是说应用中可能是一种导入方式而在依赖中可能是另外一种导入方式。表现不一样对使用者甚至是模块转义器来说都是个问题。 如何规避或者减少风险可以有如下几种方式，每种方式都有平衡的折中，区分包的运行场景（这个基本是确定的），也就是没有完美的解决办法，但可以满足如下条件的场景，基本绝大部分场景都够用了。 这个包可以通过import和require引用 这个包可以在当前版本的NodeJS里面使用，也可以在老的不支持ES Module的NodeJS版本中使用 这个包main主入口pkg可以被require解析成CommonJS也可以被import解析成ES Module，也可以用pkg/feature引用导出的其他路径 这个包提供了命名的导出，比如import &#123;name&#125; from &#39;pkg&#39;而不是import pkg from &#39;pkg&#39;;pkg.name (不建议export default，因为不利于 tree shaking) 这个包可能被其他的像浏览器这样的 ES Module环境使用 前面这些场景的使用风险都可以被避免或者减少 方法一：使用一个 ES Module 包裹器用CommonJS的方法来写这个包或者转译ES Module到CommonJS，同时搞一个ES Module的包装器来定义命名导出。使用条件导出，这个ES Module包装器用来支持import，CommonJS的入口用来支持require。这样两种导入方式得到的结果是一样的，也就避免了不一致的问题。 缺点明显就是不能完全用ES Module，也就是没法用完全的tree shaking，但可以把它变成优势，比如代码本身不是ES Module的。 12345678910111213141516// ./node_modules/pkg/package.json&#123; &quot;type&quot;: &quot;module&quot;, &quot;main&quot;: &quot;./index.cjs&quot;, &quot;exports&quot;: &#123; &quot;import&quot;: &quot;./wrapper.mjs&quot;, &quot;require&quot;: &quot;./index.cjs&quot; &#125;&#125;// ./node_modules/pkg/index.cjsexports.name = &#x27;value&#x27;;// ./node_modules/pkg/wrapper.mjsimport cjsModule from &#x27;./index.cjs&#x27;;export const name = cjsModule.name; 如果模块不单单是命名的导出，还有其他的函数或者对象的导出像 module.exports = function()&#123;&#125; 或者需要支持全导入import pkg from &#39;pkg&#39; 那么这个ES Module包装器需要同时导出默认的内容。 123import cjsModule from &#x27;./index.cjs&#x27;;export const name = cjsModule.name;export default cjsModule; 适用场景 这个包现在就是用CommonJS写的，也不想重构到ES Module了，但想同时支持两种引入方式，那么简单搞搞包装就行了 这个包有被其他包依赖，而且最终的使用者可能同时装这两个包，比如一个utilities包是被直接引用的，而utilities-plus包在原来的基础上增加了一些新功能。因为这个包装器在CommonJS下导出的， 不管utilities-plus是CommonJS还是ES Module都可以支持。 这个包存了内部的状态，也不想重构将状态管理独立出来。 这种方式也可以换个玩法，那就是在明确CommonJS包和ES Module包之间不会相互影响的情况下（状态隔离了或者本身无状态），各自提供一套。 123456789// ./node_modules/pkg/package.json&#123; &quot;type&quot;: &quot;module&quot;, &quot;main&quot;: &quot;./index.cjs&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &quot;./index.cjs&quot;, &quot;./module&quot;: &quot;./wrapper.mjs&quot; &#125;&#125; 方法二 状态隔离如果CommonJS版本的和ES Module版本的包是等价的（比如一个就是另一个转义过来的），同时包的状态管理是隔离的或者本身是无状态的。就可以直接用条件导出对应不同版本就行。 123456789// ./node_modules/pkg/package.json&#123; &quot;type&quot;: &quot;module&quot;, &quot;main&quot;: &quot;./index.cjs&quot;, &quot;exports&quot;: &#123; &quot;import&quot;: &quot;./index.mjs&quot;, &quot;require&quot;: &quot;./index.cjs&quot; &#125;&#125; 为啥老说这个状态是个问题呢？因为这个包的CommonJS版本和ES Module版本都可能都被用到，前面说到了，不同人写法不一样可能存在同时用的问题，也可能是项目引入和项目依赖引入的方式不一样也会导致同时用到。那么这个时候，两份代码都会被加载到内存里面，也就存在了两个完全独立的内部状态，这就可能会引入难以发现和难搞的Bug。（其实也是各种多线程多进程分布式多机部署前后端同构等等场景里面经常出现的问题） 先不说无状态的包（比如像JavaScript Math模块如果是个包的话，就没有状态的事，因为都是静态的内容），可以通过如下方法来隔离可能再CommonJS和ES Module中都存在的包里面的状态的问题： 状态写到外部（也就是去除状态）123import Date from &#x27;date&#x27;;const someDate = new Date();// someDate contains state; Date does not 这样的话包可以返回新对象，可以改对象，但不存对象，将状态放到外部 状态隔离到公共内容上把状态相关的内容都放到一个或者多个CommonJS模块里面，并且让其他CommonJS和ES Module共享这些状态。这样就不会出现两种加载方式出现两种隔离的状态的问题，这样也就没有状态不一致的问题了。 123456789// ./node_modules/pkg/index.cjsconst state = require(&#x27;./state.cjs&#x27;);module.exports.state = state;// ./node_modules/pkg/index.mjsimport state from &#x27;./state.cjs&#x27;;export &#123; state&#125;; 所有加在这个包单例上面的插件，都需要分别加载CommonJS和ES Module单例上面。 适用场景 这个包当前是使用ES Module来写的，同时希望只要支持ES Module的地方都能用 这个包要么是无状态的，要么是可以简单的进行状态隔离的 这个包不大可能被其他的公开的包所依赖，或者即使被依赖了，这包也是无状态的或者只有不必在依赖中或者整个项目中共享的状态 这种方式也可以换个玩法，不一定需要条件导出，可以导出不同的路径来区分也行，实例如下： 123456789// ./node_modules/pkg/package.json&#123; &quot;type&quot;: &quot;module&quot;, &quot;main&quot;: &quot;./index.cjs&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &quot;./index.cjs&quot;, &quot;./module&quot;: &quot;./index.mjs&quot; &#125;&#125; NodeJS 加载ES Module的支持路径要求路径都是按照URL的规范来加载的，所以路径中带有# 和?这样的关键字需要被干掉。目前支持file:,node:,data: 这几种路径规则，像https://example.com/app.js 这样的原生不支持，除非自己定义模块加载器 file: URLs 引用根路径可以用/,//,file:///,URL解析和路径解析还有些不一样，推荐用url.pathToFileURL先转一下再导入 可以给路径带参数或者页内片段，但不同参数和不同页内片段的加载都会被当做新的加载而多次加载模块 12import &#x27;./foo.mjs?query=1&#x27;; // loads ./foo.mjs with query of &quot;?query=1&quot;import &#x27;./foo.mjs?query=2&#x27;; // loads ./foo.mjs with query of &quot;?query=2&quot; data: Imports 在如下几种MIME类型中支持 dataURL text/javascript 作为 ES Module application/json 作为 JSON application/wasm 作为 WASM dataURL的解析中不支持相对路径，举例如下 12import &#x27;data:text/javascript,console.log(&quot;hello!&quot;);&#x27;;import _ from &#x27;data:application/json,&quot;world!&quot;&#x27;; node: Imports 前面也提到了，明确指定加载Node核心库的方法，即使安装了相同依赖也会优先使用核心库 1import fs from &#x27;node:http&#x27;; 导入断言 支持导入断言，但还只支持json这一种类型 1234import fooData from &#x27;./foo.json&#x27; assert &#123; type: &#x27;json&#x27; &#125;;const &#123; default: barData &#125; = await import(&#x27;./bar.json&#x27;, &#123; assert: &#123; type: &#x27;json&#x27; &#125; &#125;); 动态导入 import() 动态导入同时支持CommonJS 和 ES Module，也可以支持交叉导入比如在CommonJS中导入ES Module，经测试简单的ES Module中导入CommonJS也可以 import.meta url 导入模块文件的绝对路径 file: URL，和浏览器访问文件的URL一样，import.meta.url 可以作为一个方便的URL的相对路径base resolve 【实验性的】，解析一个当前模块的相对路径 NodeJS环境下模块加载互操作 import import 只能在ES Module中使用，但动态导入import()可以在CommonJS和ES Module中使用，如果导入的是CommonJS 模块，则module.exports 会作为默认的导出。也给静态分析提供了命名导出的支持。 加载自定义模块的时候 import只能整体导入 CommonJS模块 加载NodeJS内置模块的时候，import可以导入命名导出 require require 只能加载 CommonJS的模块，要加载ES Module，需要用import() 为了更好的兼容现有的JS生态的用法，NodeJS中用了一个静态解析的过程让CommonJS的命名导出去对标ES module的导出，因为是做静态分析得来的，所以动态绑定的和新加到module.exports上面的导出都没法被感知到。基于通用语法的命名导出检测不一定能覆盖所以场景的命名导出检测，所以用default导出会更好。 1234567891011121314// cjs.cjsexports.name = &#x27;exported&#x27;;import &#123; name &#125; from &#x27;./cjs.cjs&#x27;;console.log(name);// Prints: &#x27;exported&#x27;import cjs from &#x27;./cjs.cjs&#x27;;console.log(cjs);// Prints: &#123; name: &#x27;exported&#x27; &#125;import * as m from &#x27;./cjs.cjs&#x27;;console.log(m);// Prints: [Module] &#123; default: &#123; name: &#x27;exported&#x27; &#125;, name: &#x27;exported&#x27; &#125; CommonJS 模块的module.exports导入可以和ES Module 的default导入对等 1234567891011import &#123; default as cjs &#125; from &#x27;cjs&#x27;;// The following import statement is &quot;syntax sugar&quot; (equivalent but sweeter)// for `&#123; default as cjsSugar &#125;` in the above import statement:import cjsSugar from &#x27;cjs&#x27;;console.log(cjs);console.log(cjs === cjsSugar);// Prints:// &lt;module.exports&gt;// true ES Module静态导入和动态导入的对象也可以对等 123456import * as m from &#x27;cjs&#x27;;console.log(m);console.log(m === await import(&#x27;cjs&#x27;));// Prints:// [Module] &#123; default: &lt;module.exports&gt; &#125;// true NodeJS中 ES Module和 CommonJS 的差异 没有require,exports,module.exports ，大部分情况下，import可以用来加载 CommonJS 模块。如果需要的话，可以在ES Module中用module.createRequire来创建一个require函数 没有__filename 和__dirname，可以用import.meta.url来替代 没有 JSON 模块加载（当前还是实验特性），可以通过文件加载的方式加载，也可以用module.createRequire来创造CommonJS加载环境 12import &#123; readFile &#125; from &#x27;fs/promises&#x27;;const json = JSON.parse(await readFile(new URL(&#x27;./dat.json&#x27;, import.meta.url))); 没有原生模块加载（现在还不支持），可以用module.createRequire或者process.dlopen替代 没有require.resolve 这个自然，连require都没有，当然也可以用module.createRequire搞一个，也可以用new URL(&#39;./local&#39;, import.meta.url)来做相对路径解析，也可以用当前的实验特性import.meta.resolve 没有NODE_PATH环境变量，因为不是包导入的一部分，可以用symlinks来替代 没有require.extensions 这个也不需要被import用到 没有require.cache 因为 ES Module是单独的，有自己的缓存方式 扩展的加载器 loaders,【实验特性】，可以自定义加载和转译的方式 CommonJS 和 ES Module 区别 CommonJS模块导出的是拷贝值后来变更无效，而ES Module导出的是值引用，可以感知变更 CommonJS模块加载方式是运行时加载， ES Module是编译时静态输出 CommonJS模块加载方式require是同步加载，而ES Module的import命令是异步处理，有静态处理的过程 ES Module加载过程参考文档ESM加载图解，官方规范里面就有ECMAScript 加载过程概要翻译： 构建过程：通过import获取依赖关系，创建依赖关系图，对每一个依赖的文件入口进行解析，并根据解析结果转换成【模块记录】,包含了当前模块的依赖模块，依赖的入口，以及相关的属性和方法 实例化过程：对每一个【模块记录】转换成【模块实例】(包含代码和状态的运行时结构)，（申请内层空间，这时内存中就有了这些内容） 执行过程：执行代码，并将实际的代码执行并填充相关实例 这三个过程是独立的异步的。 常见问题CommonJS 的循环引用 CommonJS是动态导入，执行到特定位置，此时已经导出了哪些内容，就有哪些内容 exports为先定义的一个空对象，每次执行exports.xx 就添加相应的对象中 module.exports 是直接替换当前模块的导出对象 所以根据上面的内容，可以通过对使用exports导出的方式来避免因为module.exports集中导出导致的要使用的入口还不存在的情况，以此来解决循环引用 更好的方式是合理拆分模块，比如将相互引用的内容拆到第三个模块中 12345678910111213141516171819202122// moduleA.jsconsole.log(&#x27;#moduleA start&#x27;)exports.varA = 1const varB = 2const varC = 3const moduleB = require(&#x27;./moduleB&#x27;)console.log(moduleB.varA,moduleB.varB,moduleB.varC)module.exports = &#123; varB, varC&#125;console.log(&#x27;#moduleA end&#x27;) 12345678910111213141516// moduleB.jsconsole.log(&#x27;#moduleB start&#x27;)exports.varA = 1const varB = 2const varC = 3const moduleA = require(&#x27;./moduleA&#x27;)console.log(moduleA.varA,moduleA.varB,moduleA.varC)module.exports = &#123; varB, varC&#125;console.log(&#x27;#moduleB end&#x27;) 123456console.log(&#x27;#module main start&#x27;)require(&#x27;./moduleA&#x27;)require(&#x27;./moduleB&#x27;)console.log(&#x27;module main end&#x27;) ES Module 的循环引用 ES Module的循环引用，可以直接被检查出来 模块导入导出的解析表现的有点怪异，可自行感受 12345678910111213141516171819202122232425262728293031323334353637383940414243// moduleA.mjsconsole.log(&#x27;#moduleA start&#x27;)import moduleB from &quot;./moduleB.mjs&quot;console.log(moduleB.varA,moduleB.varB,moduleB.varC)export let varA = 1const varB = 2const varC = 3export default &#123; varB, varC&#125;console.log(&#x27;#moduleA end&#x27;)// moduleB.mjsconsole.log(&#x27;#moduleB start&#x27;)import moduleA from &quot;./moduleA.mjs&quot;console.log(moduleA.varA,moduleA.varB,moduleA.varC)export const varA = 1const varB = 2const varC = 3export default &#123; varB, varC&#125;console.log(&#x27;#moduleB end&#x27;)// main.mjsconsole.log(&#x27;#module main start&#x27;)import &quot;./moduleA.mjs&quot;import &quot;./moduleB.mjs&quot;console.log(&#x27;module main end&#x27;) package.json的exports字段先后顺序来判断优先级（前面的遗留问题）疑惑点：一个对象的Key如何做到有序的？原理上对象也就是字典，key 可能是无序的或者顺序是不确定的（不同环境不一样） 虽然17.x文档上写了支持条件导出，但用了当前最新17.1.0 的版本的Node写了个条件导出的demo，发现还不支持，但不影响去找源码 查看NodeJS 条件导出的实现 下载NodeJS源码 翻开lib/modules，然后搜索conditional 可以找到resolve.js，同时能找到几个相关的函数 resolvePackageTarget isConditionalExportsMainSugar packageExportsResolve 再查看他们的调用情况，可以找出主线来 从上面几个函数中可以看出，也就一个ObjectGetOwnPropertyNames 获取配置的同时，用循环来处理的 那如果要有序的话，那么ObjectGetOwnPropertyNames 或者 Object.getOwnPropertyNames或者Object.keys是有序的 分别用如下样例在NodeJS 和 Chrome浏览器中测试，可以发现获取的对象key是有顺序的。 123456789101112131415161718192021222324const testObjA = &#123; &quot;import&quot;: &quot;./esm-export.mjs&quot;, &quot;require&quot;: &quot;./reuire-export.cjs&quot;, &quot;node&quot;: &#123; &quot;require&quot;: &quot;./require-export.cjs&quot;, &quot;import&quot;: &quot;./esm-export.mjs&quot; &#125;, &quot;default&quot;: &quot;./main-export.mjs&quot; &#125; const testObjB = &#123; &quot;node&quot;: &#123; &quot;require&quot;: &quot;./require-export.cjs&quot;, &quot;import&quot;: &quot;./esm-export.mjs&quot; &#125;, &quot;default&quot;: &quot;./main-export.mjs&quot;, &quot;import&quot;: &quot;./esm-export.mjs&quot;, &quot;require&quot;: &quot;./reuire-export.cjs&quot;, &#125; console.log(Object.keys(testObjA))console.log(Object.getOwnPropertyNames(testObjA))console.log(Object.keys(testObjB))console.log(Object.getOwnPropertyNames(testObjB)) 再看看ECMAScript规范的实现要求，Object.keys和Object.getOwnPropertyNames都是拿到数据之后，循环放到列表里面，然后转成数组，所以需要看看拿数据的时候做了什么 再翻开chromium v8的源码，在源码里面找ECMAScript中，拿数据的关键字OwnPropertyKeys ，在结果里面可以看到src/builtins/builtins-object.cc里面有GetOwnPropertyKeys的定义 1234567891011121314Object GetOwnPropertyKeys(Isolate* isolate, BuiltinArguments args, PropertyFilter filter) &#123; HandleScope scope(isolate); Handle&lt;Object&gt; object = args.atOrUndefined(isolate, 1); Handle&lt;JSReceiver&gt; receiver; ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, receiver, Object::ToObject(isolate, object)); Handle&lt;FixedArray&gt; keys; ASSIGN_RETURN_FAILURE_ON_EXCEPTION( isolate, keys, KeyAccumulator::GetKeys(receiver, KeyCollectionMode::kOwnOnly, filter, GetKeysConversion::kConvertToString)); return *isolate-&gt;factory()-&gt;NewJSArrayWithElements(keys);&#125; 再找到KeyAccumulator::GetKeys的定义，可以看到这里用的数据结构是OrderedHashSet有序的Hash结构，也就是本身是有序的支撑 1234567891011121314Handle&lt;FixedArray&gt; KeyAccumulator::GetKeys(GetKeysConversion convert) &#123; if (keys_.is_null()) &#123; return isolate_-&gt;factory()-&gt;empty_fixed_array(); &#125; if (mode_ == KeyCollectionMode::kOwnOnly &amp;&amp; keys_-&gt;map() == ReadOnlyRoots(isolate_).fixed_array_map()) &#123; return Handle&lt;FixedArray&gt;::cast(keys_); &#125; USE(ContainsOnlyValidKeys); Handle&lt;FixedArray&gt; result = OrderedHashSet::ConvertToKeysArray(isolate(), keys(), convert); DCHECK(ContainsOnlyValidKeys(result)); return result;&#125; 再继续查找继承链OrderedHashSet=&gt;OrderedHashTable=&gt;FixedArray 发现本质上是一个数组或者列表，有序就是本性了。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://rawbin-.github.io/tags/CommonJS/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://rawbin-.github.io/tags/ECMAScript/"}]},{"title":"前端组件化那些事","slug":"modules/2018-12-11-fe-component","date":"2021-12-31T02:37:59.948Z","updated":"2021-12-31T02:37:59.948Z","comments":true,"path":"modules/2018-12-11-fe-component/","link":"","permalink":"http://rawbin-.github.io/modules/2018-12-11-fe-component/","excerpt":"","text":"组件化的发展过程基于命名空间的多入口文件组件 jquery插件，一个js 一个css 基于模块的多入口文件组件 amd js，css 单JavaScript入口组件WebComponent 自定义元素 HTML模板 Shadow DOM HTML import lit from polymer React 组件化组件实现方式 React.createClass ES6 Class 无状态函数 Hooks 组件生命周期组件复用 mixin（早期特性） Decorator HOC——是一个以组件为参数的函数 displayName 用途 操作props 通过ref访问组件实例 组件状态提升 用其他元素包裹组件 实现方式 属性代理 反向继承 渲染劫持 控制state 组件间通信 props 回调函数 自定义事件 Context EventBus 组件调试 React Developer Tools React Context DevTool Redux DevTools why-did-you-update ReactPerf 组件性能优化 纯函数 PureRender（shouldComponentUpdate） shouldComponentUpdate react-addon-perf 组件测试 react-addons-test-util Enzyme Jest 浅渲染 全渲染 JSDOM Cheerio Karma Vue 组件化小程序组件化","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://rawbin-.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"组件化","slug":"组件化","permalink":"http://rawbin-.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"WebComponent","slug":"WebComponent","permalink":"http://rawbin-.github.io/tags/WebComponent/"},{"name":"React","slug":"React","permalink":"http://rawbin-.github.io/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"http://rawbin-.github.io/tags/Vue/"}]},{"title":"前端三剑客JavaScript、CSS、HTML模块化那些事","slug":"modules/2018-12-11-fe-js-css-html-modules","date":"2021-12-31T02:37:59.948Z","updated":"2021-12-31T02:37:59.948Z","comments":true,"path":"modules/2018-12-11-fe-js-css-html-modules/","link":"","permalink":"http://rawbin-.github.io/modules/2018-12-11-fe-js-css-html-modules/","excerpt":"","text":"JavaScript模块化JavasScript模块发展历史在ES2015（ES6 )之前，ECMAScript(俗称JavaScript)没有标准的模块，从最初对JavaScript的设计预期来说，也不是要做多少事情的，比如就做做表单校验以解决当时网速超级慢的情况下客户端与服务端交互等待时间太长的问题，谁知道后来Web技术的发展让JavaScript肩上的责任越来越重大，预期也越来越高。 全局变量早期不做任何管理的情况下，多个不同的JS的内容都通过script标签引用，不同js文件中的内容挂放在全局对象window的属性上，这样问题很明显，不同的js文件（可能是不同人写的）中有相同变量名的话，后面加载的会覆盖前面加载的，可能出现同名不同功能的函数被覆盖导致功能异常，这个前两年在维护老系统的时候还遇到过，同名的表单校验函数被各种CopyAndPaste到很多地方，然后有的地方需要这个规则，有的地方需要那个规则，然后你懂的，操碎了心心！！于是就有了下面的命名空间的事。 命名空间最早接触到命名空间来解决类似的问题是在yui 和 extjs 中，在我们经常玩的MathType Web 中也还能看到类似的身影com.wiris.js.xxx 对于从Java转过来的小伙伴一点也不会陌生，这不就是那个包名么，而且早期也没有啥前端工程师，基本都是Web开发，也就是说前端也是后端写的，这样看来就不足为奇了。在前端内容越来越多、前端技术逐渐细分的情况下，原有Web开发也存在搞不定的事了（我碰到过一个JavaWeb哥们，调一个Table样式搞了一天尝试了N多方法，恁是没搞出来，然后我们的前端小姐姐出马分分钟搞定），这也就是专业的人干专业的事，才有了下面的事情。下面这些我们都称之为规范，但规范也分级别，这些都是社区规范或者说是民间规范，但比起前面这种命名约定来说，已经有了大幅度的发展了。 AMD + CMD + KMD + UMD AMD(Asynchronous Module Definition)——RequireJS CMD(Common Module Definition)——SeaJS KMD(Kissy Module Definition)——Kissy UMD(Universal Module Definition)——上面的包括CommonJS在内的AllInOne JavaScript模块标准化详情见【JavaScript模块标准化】 CommonJS参考wiki这里说标准也不那么恰当，但在Node.js环境中，比起前面的各种MD来说，又更近了一步，更加统一，以至于体验上会更加规范，但还不是规范，至少可以做到只要是Node，都遵守一致的模块定义，所有使用者也能达成共识。 ECMAScript伴随着ES2015(ES6)的发布，JavaScript标准憋了十年的大招放出来，总算解决了模块标准化的问题，区别于以往任何的模块化系统，又是一套全新的规则，但标准总归是标准，各大平台相继支持Node，Deno等等 CSS 模块化CSS-in-JSCSS ModulesBEM:global() :local()样式组合样式覆盖 全局穿透样式 data属性来选择 HTML模块化相关文档 html modules 提的 issue html modules 提的 proposal html modules 浏览器厂商的反馈 html modules 技术设计文档 html modules 示例 html modules 争议 html modules 后续状态 模块化包管理工具corepack NodeJS 官方的包管理工具的管理工具 pnpm github yarn github cnpm github npm github bower github component github spm github 模块化构建工具vite github rollup github rollup doc ykit——去哪儿网 github qunar ued ykit doc webpack github webpack doc fastpack github fastpack doc parcel github fis——百度 github fis doc feflow——腾讯 github fekit——去哪儿网 github qunar ued fekit doc 前端工程化工具Fekit分析 WeFlow——腾讯 github coolie github coolie doc fed coolie doc 老牌通用自动化工具 grunt gulp JavaScript转义器在ES6发布前后，出现了一大堆相关的JavaScript转义器，主要解决新特性和兼容性问题，甚至也有Google的工具在其中，但最后因为各种各样的原因类似于更新不及时，支持不及时等等，最后babel 胜出，才有了现在的情况。 babel esm traceur-compiler es6-module-transpiler jstransform JavaScript预处理+类型增强 typescript flow","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://rawbin-.github.io/tags/HTML/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"JavaScript检测变量类型 typeof instanceof Object.toString","slug":"dev-app/2018-10-20-js-type-detection","date":"2021-12-31T02:37:59.947Z","updated":"2021-12-31T02:37:59.947Z","comments":true,"path":"dev-app/2018-10-20-js-type-detection/","link":"","permalink":"http://rawbin-.github.io/dev-app/2018-10-20-js-type-detection/","excerpt":"","text":"检测方法typeof 操作符 只能检测出基本类型undefined,object,string,boolean,number,function,symbol 检测原始值的类型，其他引用类型统一都在object中，如果要区分object的不同引用类型，需要用其他方法 Object.prototype.toString 可以根据返回不同对象包装函数类型的字符串 可以用来区分系统内类类型 instanceof 可以用来检测自定义类的类型，检测对象是否属于指定的类的实例 不同执行上下文不同的构造函数属于不同的结果，比如即使同样是Array也不行，所以有了Array.isArray来处理类似数组的判断 o instance t检测o是否在t.protoptype的原型链上 constructor属性 通过对象的constructor属性来判断 多个执行上下文（比如浏览器的多个框架子页面）无法判断出来是同一个，即使内容完全一样也不是同一个，参考instanceof 构造函数的名称 非标准的方法，让不同上下文中的构造函数都用同一个名字，可以参考下v8源码，Array.isArray的实现","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"代码规范","slug":"前端开发/Web开发/JavaScript/代码规范","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"css","slug":"css","permalink":"http://rawbin-.github.io/tags/css/"},{"name":"markdown","slug":"markdown","permalink":"http://rawbin-.github.io/tags/markdown/"},{"name":"W3C","slug":"W3C","permalink":"http://rawbin-.github.io/tags/W3C/"},{"name":"代码规范","slug":"代码规范","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"移动端滚动穿透解决方案","slug":"dev-app/2018-11-07-mobile-modal-scroll","date":"2021-12-31T02:37:59.947Z","updated":"2021-12-31T02:37:59.947Z","comments":true,"path":"dev-app/2018-11-07-mobile-modal-scroll/","link":"","permalink":"http://rawbin-.github.io/dev-app/2018-11-07-mobile-modal-scroll/","excerpt":"","text":"需求场景描述 页面有弹层，弹层有滚动 要求弹层滚动时背景不滚动 解决办法解决标准 很多方法都是要改原来的页面（也就是触发弹层的背景页面），给原来的页面加样式等操作，不符合本次解决的标准 本次解决的标准希望是在弹层中处理，把弹层当做一个业务无关的组件，不做关联依赖处理 小程序中的情景模拟器（符合预期） 在弹层的滚动区域只会触发弹层的滚动，不会触发背景页面的滚动 Android机（华为Mate30 5G, Android 10） 在弹层区域能滚动的时候只触发弹层的滚动 在弹层区域不能滚动的时候（比如滚到头或者滚到尾的时候）会触发背景页面的滚动 iOS机（iPhone X ，iOS 13.4.1） 在弹层滚动条出现的时候正常，弹层滚动条不出现的时候滚动背景 不但有背景的本身的滚动，还有弹性滚动 小程序中解决办法在modal 最外层加catchtouchmove=”emptyFunction”（别给”true”这样会报警告的方法） 这样在模拟器上touchpad还可以滚动，真机和模拟器上都没法拖动 仅适合弹层没有滚动条的情况 在modal 最外层加catchtouchmove=”emptyFunction”，弹层滚动区域用scroll-view，并设置scroll-y为true 只要有弹层，背景就不会滚动 弹层内部的滚动会正常的scroll-view滚动 参考资料 链接和代码","categories":[],"tags":[{"name":"滚动穿透","slug":"滚动穿透","permalink":"http://rawbin-.github.io/tags/%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F/"},{"name":"弹层滚动","slug":"弹层滚动","permalink":"http://rawbin-.github.io/tags/%E5%BC%B9%E5%B1%82%E6%BB%9A%E5%8A%A8/"},{"name":"禁止滚动","slug":"禁止滚动","permalink":"http://rawbin-.github.io/tags/%E7%A6%81%E6%AD%A2%E6%BB%9A%E5%8A%A8/"}]},{"title":"使用Canvas实现通用的手写和手绘","slug":"dev-app/2018-11-21-canvas-hand-sketch","date":"2021-12-31T02:37:59.947Z","updated":"2021-12-31T02:37:59.947Z","comments":true,"path":"dev-app/2018-11-21-canvas-hand-sketch/","link":"","permalink":"http://rawbin-.github.io/dev-app/2018-11-21-canvas-hand-sketch/","excerpt":"","text":"参考资料 canvas性能优化——离屏渲染 canvas手写 匠心打造canvas签名组件 https://github.com/Louiszhai/canvas-draw https://github.com/embiem/react-canvas-draw https://github.com/carstenschaefer/DrawerJs https://github.com/sendeveloper/react-signature-canvas https://github.com/xianzou/react-signature-phone https://github.com/Leimi/drawingboard.js canvas 图片裁剪 https://github.com/jamesssooi/Croppr.js https://github.com/fengyuanchen/cropperjs https://github.com/Foliotek/Croppie https://github.com/aloneqi/imageCropping https://github.com/Bless-L/img-clipping https://github.com/ElemeFE/image-cropper https://github.com/wx-plugin/image-cropper https://github.com/we-plugin/we-cropper","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://rawbin-.github.io/tags/canvas/"},{"name":"手写","slug":"手写","permalink":"http://rawbin-.github.io/tags/%E6%89%8B%E5%86%99/"},{"name":"手绘","slug":"手绘","permalink":"http://rawbin-.github.io/tags/%E6%89%8B%E7%BB%98/"}]},{"title":"iPhonee 安全区适配，小黑条适配标准解决方案","slug":"dev-app/2018-11-08-iphone-adapt-darkbar","date":"2021-12-31T02:37:59.947Z","updated":"2021-12-31T02:37:59.947Z","comments":true,"path":"dev-app/2018-11-08-iphone-adapt-darkbar/","link":"","permalink":"http://rawbin-.github.io/dev-app/2018-11-08-iphone-adapt-darkbar/","excerpt":"","text":"需求场景 自从有了iPhone底部小黑条之后，页面底部就有各种适配 小黑条还不止iPhone X这一种机型，后续新出的还要不要改代码？ 可以通过js来匹配机型，可以通过媒体查询来匹配机型，新的机型如何适配？ 解决办法解决标准 希望尽可能少的改动，不需要js里面设置，然后模板里面再判断，然后再加个对应的样式啥的，太麻烦 希望尽可能通用，不能加了iPhoneX，又加iPhone XI，又加iPhone XII，没完没了 希望可以适配未来的类似的机型 解决思路 找到这个小黑条的尺寸获取方式， 在iPhone上可以通过如下方式获取（兼容写法） 123height:50px;height: calc(50px + constant(safe-area-inset-bottom)); /* ios &lt; 11.2*/height: calc(50px + env(safe-area-inset-bottom)); /* ios &gt;= 11.2*/ 在我们页面样式对应的地方加上这个尺寸，需要就加上，不需要就不加 加的方式可以根据情况来选择 直接加在页面底部，padding 如果是吸底元素，要加元素的padding，通过加height高的方式也行 如果元素浮空，需要加margin的方式来设置，或者加底边距bottom的方式 当然内部加margin也行，需要注意背景颜色是否一致 有些地方需要全量的，有些地方可能需要高度折半，请自行选择 如果碰到一些特殊的情况，上面方式处理不了的，比如听说某些安卓机（我目前还没遇到），还可以回归原始的处理办法 媒体查询 配合JS通过getSystemInfo直接处理 screenHeight - safeArea.bottom 即是底部小黑条影响的范围，也就是上面方法求得的值 小程序中的解决办法 直接使用上面的兼容写法的适配方案即可 当前（20201128）最新的微信开发者工具开发版本上可以直接验证了，h5部分目前还不支持，开发哥哥么已经在搞了 H5中的解决办法 在html模板里面加如下meta标签,如果存在就合并一下，1&lt;meta name=&quot;viewport&quot; content=&quot;viewport-fit=cover&quot;&gt; 然后用上面的兼容写法处理 手边没有设备怎么办？模拟器 XCode(XCode 14) New =&gt;iOS=&gt;App类型的Application 接下来 Interface 选StoryBoard, Language选Swift 创建工程完成 把ViewController.swift代码改成如下: 1234567891011121314151617181920import UIKitimport WebKitclass ViewController: UIViewController &#123; var webView: WKWebView! override func loadView() &#123; webView = WKWebView() view = webView &#125; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. let url = URL(string: &quot;http://127.0.0.1:8080/iphone-style-adapt.html&quot;)! webView.load(URLRequest(url: url)) webView.allowsBackForwardNavigationGestures = true &#125;&#125; 在Info.plist中加入如下内容并合并标签 ，也就是把中间两行加入到dict标签中，（通过文本编辑器打开，或者XCode中以源码方式打开都行）12345&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt; 参考资料 网页适配iPhoneX,就这么简单 Designing Websites for iPhone X viewport-fit Adaptivity and Layout iPhone X适配方案 及 H5调试技巧 就H5调试技巧，浅谈：iPhone X 适配方案！ H5 IphoneX 适配简述 关于H5页面在iPhoneX适配","categories":[],"tags":[{"name":"iPhone X适配","slug":"iPhone-X适配","permalink":"http://rawbin-.github.io/tags/iPhone-X%E9%80%82%E9%85%8D/"},{"name":"小黑条适配","slug":"小黑条适配","permalink":"http://rawbin-.github.io/tags/%E5%B0%8F%E9%BB%91%E6%9D%A1%E9%80%82%E9%85%8D/"},{"name":"安全区适配","slug":"安全区适配","permalink":"http://rawbin-.github.io/tags/%E5%AE%89%E5%85%A8%E5%8C%BA%E9%80%82%E9%85%8D/"}]},{"title":"快速撸一个使用的小爬虫","slug":"dev-app/2018-11-30-quick-simple-spider","date":"2021-12-31T02:37:59.947Z","updated":"2021-12-31T02:37:59.947Z","comments":true,"path":"dev-app/2018-11-30-quick-simple-spider/","link":"","permalink":"http://rawbin-.github.io/dev-app/2018-11-30-quick-simple-spider/","excerpt":"","text":"NodeJS 版本https://github.com/rawbin-/simple-web-spider Python版","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://rawbin-.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"puppeteer","slug":"puppeteer","permalink":"http://rawbin-.github.io/tags/puppeteer/"}]},{"title":"屏幕事件，DOM位置及相关处理应用","slug":"dev-app/2018-10-19-dom-position","date":"2021-12-31T02:37:59.947Z","updated":"2021-12-31T02:37:59.947Z","comments":true,"path":"dev-app/2018-10-19-dom-position/","link":"","permalink":"http://rawbin-.github.io/dev-app/2018-10-19-dom-position/","excerpt":"","text":"相关通用属性（不兼容的就不用了）关于事件属性Event.screenX, Event.screenY相对于屏幕左上角的x,y坐标值，所有的鼠标事件都有定义 Event.clientX,Event.clientY相对于客户端左上角的x,y坐标值（不考虑滚动条），所有的鼠标事件都有定义 Event.Touch screenX，screenY 相对于屏幕左上角的坐标 clientX，clientY 相对于视口的坐标（不搞包含滚动距离） pageX，pageY 相对于视口的坐标（包含滚动距离） TouchEvent touches 每一个接触点的事件信息 targetTouches 当前事件目标节点上触发的接触点的事件信息 changedTouches 关于DOM位置Element.clientWidth,Element.clientHeight 如果当前元素是根元素，表达的是不包含滚动条的视窗宽高 非根元素，表达的是不包含滚动条的元素内容宽高+Padding值，也就是Padding边界的宽高值 Element.clientTop,Element.clientLeft 左边（或上边）的Border边到Padding边间的距离，一般就是Border的值(没有滚动条)，有滚动条的话要算滚动条的宽度 Element.offsetWidth,Element.offsetHeight 包含Padding和Border，但不包含Margin的宽高值，也就是Border边界的宽高值 Element.offsetTop,Element.offsetLeft Border左上角相对于offsetParent的值 一般offsetParent为body元素，有动态定位容器offsetParent就是这个定位的容器，如果在table内，这个offsetParent就是table Element.scrollWidth,Element.scrollHeight 元素整体的宽高尺寸，没有滚动条的话对应等于offsetWidth,offsetHeight的值，有滚动条的话就是整个内容区域的宽高（要加上可滚动的距离） Element.scrollTop,Element.scrollLeft 滚动了的距离 Element.getBoundingClientRect() 包含Border和Padding，不包含Margin 返回元素top,left,right,bottom,width,height等属性，表达左上角和右下角的x,y的坐标值及尺寸 元素框的位置，不包含滚动条，要滚动条还需要进一步计算 返回的结果不是实时的只是一个当时的静态快照 Element.getClientRects() 内联元素的每一个矩形框 Document.elementFromPoint() 传递x，y坐标来获取指定视口坐标上是什么元素 Node.contains() 判断某个节点是否包含某个其他节点，或者说某个其他节点是否是某个节点的后代 Window.getComputedStyle() 获取样式尺寸，计算过的像素尺寸","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"DOM","slug":"前端开发/Web开发/JavaScript/DOM","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/DOM/"}],"tags":[{"name":"DOM位置,DOM事件,屏幕位置","slug":"DOM位置-DOM事件-屏幕位置","permalink":"http://rawbin-.github.io/tags/DOM%E4%BD%8D%E7%BD%AE-DOM%E4%BA%8B%E4%BB%B6-%E5%B1%8F%E5%B9%95%E4%BD%8D%E7%BD%AE/"}]},{"title":"符号计算系统、库，公式编辑器梳理","slug":"dev-general/2018-10-25-symbol-compute-system","date":"2021-12-31T02:37:59.947Z","updated":"2021-12-31T02:37:59.947Z","comments":true,"path":"dev-general/2018-10-25-symbol-compute-system/","link":"","permalink":"http://rawbin-.github.io/dev-general/2018-10-25-symbol-compute-system/","excerpt":"","text":"软件系统Maxima 站点地址： http://maxima.sourceforge.net/index.html tex相关文档：http://maxima.sourceforge.net/docs/manual/maxima_72.html Mathematica 商业软件：https://www.wolfram.com/mathematica/ 在线计算：https://www.wolframalpha.com/ 对Tex的支持：https://reference.wolfram.com/language/tutorial/ImportingAndExporting.html#32618 Maple 商业软件：https://www.maplesoft.com.cn/index.shtml Wiris 系列Wiris 计算系统 页面地址：http://www.wiris.net/my_school/wiris/en/index.html Wiris Quizzes 答案比对 页面地址: http://www.wiris.com/quizzes/demo/generic/en/index.html 开发者文档：http://www.wiris.com/en/quizzes/download/generic MathType Web 文档地址：https://docs.wiris.com/en/mathtype/mathtype_web/start mathtype web sdk:https://docs.wiris.com/en/mathtype/mathtype_web/sdk/start 集成样例：https://docs.wiris.com/en/mathtype/mathtype_web/sdk-api/embedding 编辑器：https://docs.wiris.com/en/mathtype/mathtype_web/sdk-api/embedding 各种端、系统、编辑器的集成：https://docs.wiris.com/en/mathtype/mathtype_web/start release notes: https://docs.wiris.com/en/mathtype/release_notes/start mathtype 移动端：https://docs.wiris.com/en/mathtype/mathtype_web/sdk/mobile-apps mathtype 手写：https://docs.wiris.com/en/mathtype/mathtype_web/handwritten-input 手写测试：http://www.wiris.net/demo/hand/tests/en/test.html 编程库PythonSympy github地址: https://github.com/sympy/sympy 文档地址: https://www.sympy.org/en/index.html Scipy 站点地址: https://www.scipy.org/ Numpy 站点地址： https://numpy.org/","categories":[{"name":"符号计算","slug":"符号计算","permalink":"http://rawbin-.github.io/categories/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/"},{"name":"值计算","slug":"符号计算/值计算","permalink":"http://rawbin-.github.io/categories/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/%E5%80%BC%E8%AE%A1%E7%AE%97/"},{"name":"对比","slug":"符号计算/值计算/对比","permalink":"http://rawbin-.github.io/categories/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/%E5%80%BC%E8%AE%A1%E7%AE%97/%E5%AF%B9%E6%AF%94/"}],"tags":[{"name":"符号计算","slug":"符号计算","permalink":"http://rawbin-.github.io/tags/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/"},{"name":"值计算","slug":"值计算","permalink":"http://rawbin-.github.io/tags/%E5%80%BC%E8%AE%A1%E7%AE%97/"},{"name":"值对比","slug":"值对比","permalink":"http://rawbin-.github.io/tags/%E5%80%BC%E5%AF%B9%E6%AF%94/"}]},{"title":"2020跨平台跨端解决方案梳理","slug":"cross-platform/2018-10-15-cross-platform-enduser","date":"2021-12-31T02:37:59.946Z","updated":"2021-12-31T02:37:59.947Z","comments":true,"path":"cross-platform/2018-10-15-cross-platform-enduser/","link":"","permalink":"http://rawbin-.github.io/cross-platform/2018-10-15-cross-platform-enduser/","excerpt":"","text":"解决方案汇总Hybrid（H5+原生混合）Cordova 前身是PhoneGap 跨平台 Android，iOS，Windows 相关资源 文档地址： https://cordova.apache.org/ github地址：https://github.com/apache/cordova uni-app DCloud是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。 相关资源 文档地址： https://uniapp.dcloud.net.cn/ github地址：https://github.com/dcloudio/uni-app AppCan 跨平台 Android,iOS InoicTitaniumXamarin 跨平台 Android, iPhone, iPad, Mac, and Windows 开发语言 C# X NativeWeex阿里出品，Vue官方支持的跨平台开发框架，对标React Native 相关资源 文档地址：https://weex.apache.org/zh/ github地址：https://github.com/alibaba/weex React NativeFacebook出品的，跨平台开发框架，基于React，一码多端的成熟产品。 相关资源 文档地址： https://reactnative.dev/ github地址：https://github.com/facebook/react-native TaroTaro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发微信/京东/百度/支付宝/字节跳动/ QQ 小程序/H5 等应用。现如今市面上端的形态多种多样，Web、React Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。 相关资源 文档地址：https://taro.aotu.io/ github地址：https://github.com/NervJS/taro Chameleonweb、微信小程序、支付宝小程序、百度小程序、android(weex)、ios(weex)、qq 小程序、字节跳动小程序、快应用、持续更新中 相关资源 文档地址：https://cml.js.org/ github地址：https://github.com/didi/chameleon Flutter侧重跨端，一套代码适配Android和iOS和Web端 相关资源 文档地址： https://flutter.dev/docs github地址：https://github.com/flutter/flutter 小程序依赖所在平台本身进行跨平台，小程序依赖于微信的跨平台能力，又衍生出一堆框架 wepy来源腾讯，Vue风格的框架，支持ES2015+的特性，以及各方面的开发增强 相关资源 文档地址：https://wepyjs.gitee.io/wepy-docs/ github地址：https://github.com/Tencent/wepy mpvue来源美团，使用Vue开发小程序的前端框架 相关资源 文档地址： http://mpvue.com/ github地址：https://github.com/Meituan-Dianping/mpvue Chameleonweb、微信小程序、支付宝小程序、百度小程序、android(weex)、ios(weex)、qq 小程序、字节跳动小程序、快应用、持续更新中 相关资源 文档地址：https://cml.js.org/ github地址：https://github.com/didi/chameleon mpx相关资源 文档地址：https://mpxjs.cn/ github地址：https://github.com/didi/mpx TaroTaro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发微信/京东/百度/支付宝/字节跳动/ QQ 小程序/H5 等应用。现如今市面上端的形态多种多样，Web、React Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。 相关资源 文档地址：https://taro.aotu.io/ github地址：https://github.com/NervJS/taro FusionElectron 跨平台 Mac, Windows, Linux 开发语言 JavaScript therecipe/qt 跨平台 Windows / macOS / Linux / FreeBSD / Android / iOS / Sailfish OS / Raspberry Pi / AsteroidOS / Ubuntu Touch / JavaScript / WebAssembly Picasso美团的，暂时没开源 相关资源 介绍文档：https://tech.meituan.com/2018/06/21/picasso-the-future.html 快应用是国内主流手机厂商指定你给的轻量级应用标准，对标微信小程序，用JavaScript开发，原生控件渲染 其他汇总Google(Dart)：flutter FaceBook(React)：reactreact-native 阿里巴巴(Vue、Rax)：incubator-weex 腾讯(React、Vue)：https://github.com/Tencent/Hippyhttps://github.com/Tencent/omi 京东(React)：https://github.com/NervJS/taro 滴滴(类似Vue)：chameleon dcloud(Vue)：uni-app EEUI(Vue)：https://github.com/kuaifan/eeui ionic(React、Vue、Angular)：ionic cordova(HTML5)：cordova 微软(.NET)：xamarin 陌陌(Lua语言)：https://github.com/momotech/MLN 额外参考 小程序跨端框架（taro/uni-app/kbone）横评之2020版 跨端开发框架深度横评 app跨平台开发框架以及技术选型如何选择 小程序多端框架全面测评 uni-app选型评估","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"代码规范","slug":"前端开发/Web开发/JavaScript/代码规范","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"跨平台,跨端,解决方案,Web跨平台,Web跨端","slug":"跨平台-跨端-解决方案-Web跨平台-Web跨端","permalink":"http://rawbin-.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0-%E8%B7%A8%E7%AB%AF-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Web%E8%B7%A8%E5%B9%B3%E5%8F%B0-Web%E8%B7%A8%E7%AB%AF/"}]},{"title":"MacOS命令行bash切换为zsh","slug":"dev-env/2018-10-09-macos-bash-to-zsh","date":"2021-12-31T02:37:59.946Z","updated":"2021-12-31T02:37:59.946Z","comments":true,"path":"dev-env/2018-10-09-macos-bash-to-zsh/","link":"","permalink":"http://rawbin-.github.io/dev-env/2018-10-09-macos-bash-to-zsh/","excerpt":"","text":"为了更高效的使用命令行，将默认Shell从bash 切换为zsh，具体的可以简单参考下这里 变更比较多的话可以用这个 来管理 安装安装zsh1brew install zsh 安装 ohmyzsh 一个增强的配置框架可能需要梯子，参考这里 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 安装额外的自定义插件12brew install zsh-syntax-highlightingbrew install zsh-autosuggestions 配置配置zsh插件1vim ~/.zshrc 到这里, 凭感觉选就行， 12345678910111213141516plugins=( colored-man-pages git git-prompt gitfast node npm nvm osx screen sudo urltools vscode yarn z ) 将下面几行加在.zshrc 的末尾 12source /usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zshsource /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 迁移配置将~/.bashrc 中的内容，迁移到~/.zshrc中，删除针对bash的 配置 使配置生效1source ~/.zshrc","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"代码规范","slug":"前端开发/Web开发/JavaScript/代码规范","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"代码规范","slug":"代码规范","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://rawbin-.github.io/tags/TypeScript/"}]},{"title":"2020前端遮罩镂空聚焦引导技术方案大全","slug":"language/css/2018-10-11-css-show-with-mask","date":"2021-12-31T02:37:59.946Z","updated":"2021-12-31T02:37:59.946Z","comments":true,"path":"language/css/2018-10-11-css-show-with-mask/","link":"","permalink":"http://rawbin-.github.io/language/css/2018-10-11-css-show-with-mask/","excerpt":"","text":"开胃菜：简单遮罩、形状遮罩 教科书式的标准做法，需要考虑内容有滚动条的时候的在不同情况下的处理 123456789.mask&#123; position:fixed; top:0; right:0; bottom:0; left:0; background: rgba(0, 0, 0, 0.4); z-index: 10;&#125; border简单看一下原理图就知道了12345678.border-show&#123; width:0; height:0; border-top: 100px solid aqua; border-right: 100px solid green; border-bottom: 100px solid fuchsia ; border-left: 100px solid chartreuse;&#125; .border-show{ width:0; height:0; border-top: 100px solid aqua; border-right: 100px solid green; border-bottom: 100px solid fuchsia ; border-left: 100px solid chartreuse; } 画一个三角形 12345678.border-shape-triangle&#123; width:0; height:0; border-top: 100px solid aqua; border-right: 100px solid transparent; /*border-bottom: 100px solid fuchsia ;*/ border-left: 100px solid transparent;&#125; 换个角度的三角形12345678.border-shape-triangle-left&#123; width:0; height:0; border-top: 100px solid aqua; border-right: 100px solid transparent; /*border-bottom: 100px solid fuchsia ;*/ /*border-left: 100px solid transparent;*/&#125; 向右的大于号1234567.border-shape-arrow&#123; width:100px; height:100px; border-right:20px solid blue; border-top: 20px solid blue; transform: rotate(45deg);&#125; outline伪元素:before或:afterbox-shadowbackgroundbackground-*mask-*mix-blend-mode难度提升：镂空遮罩borderoutlinebox-shadowbackgroundbackground-*mask-*mix-blend-modeCanvasSVG图片DIV 拼接正式挑战：镂空可点击参考资料 CSS实现镂空遮罩 CSS实现镂空效果 CSS实现镂空效果 遮罩层镂空效果的多种实现方法 遮罩层镂空效果的多种实现方法 CSS镂空遮罩研究 用纯 CSS 实现镂空效果 幻术，一行代码实现镂空效果 用纯CSS实现镂空效果的示例代码 [CSS遮罩CSS3 mask/masks详细介绍](CSS遮罩CSS3 mask/masks详细介绍) CSS遮罩——如何在CSS中使用遮罩 史上最强大的40多个纯CSS绘制的图形 CSS3绘制各种形状的图形","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"代码规范","slug":"前端开发/Web开发/JavaScript/代码规范","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"css","slug":"css","permalink":"http://rawbin-.github.io/tags/css/"},{"name":"markdown","slug":"markdown","permalink":"http://rawbin-.github.io/tags/markdown/"},{"name":"W3C","slug":"W3C","permalink":"http://rawbin-.github.io/tags/W3C/"},{"name":"代码规范","slug":"代码规范","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"纯CSS实现markdown标题自动编号","slug":"language/css/2018-10-10-css-auto-number","date":"2021-12-31T02:37:59.946Z","updated":"2021-12-31T02:37:59.946Z","comments":true,"path":"language/css/2018-10-10-css-auto-number/","link":"","permalink":"http://rawbin-.github.io/language/css/2018-10-10-css-auto-number/","excerpt":"","text":"问题的由来第一次关注这个标题编号的问题应该回溯到本科毕业论文的时候了，当时还单独涉猎过这个主题，Word 有个很好的特性级联标题，一次设置好之后，后续只要设置标题样式就能按照设置的标题编号方式自动编号，我们要做的只是将对应的标题设置成对应基本的标题样式就好了，这个方法让我爱不释手，多年来一直沿用。完全解决了中途插入一章，一节等等导致的章节编号都需要人肉调整的问题，当然还有图片的编号命名什么的，都是类似的。直到后面开始用markdown 由于各个编辑器的切换，一直没有一个好用的替代方案，所以几年前我写了一个小工具用命令行来做这事rawbin-/markdown-clear，这个工具解决了在github写博客的问题，同时在解决博客的问题的基础上解决了在各个平台发文的问题，因为编号是用脚本写上去的，所以用markdown here在各个平台发文也就顺理成章的转成html就行了，也解决了这个阶段的问题。前两天把拖欠几个月的全面认知的总结写了，突然不想用这个脚本来编号了，产生一个想法：能不能不人肉编号，自动编上？然后就有了下面的内容。 先搞起来解决问题 以下操作案例都是在macOS中产出，其他平台可能有些许差别，换汤不换药。 在typora中写markdown自动编号 打开typora【偏好设置】 找到【外观】=&gt;【主题】=&gt;【打开主题文件夹】 将如下代码加入到打开目录的base.user.css 中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#writer &#123; counter-reset: h1&#125;h1 &#123; counter-reset: h2&#125;h2 &#123; counter-reset: h3&#125;h3 &#123; counter-reset: h4&#125;h4 &#123; counter-reset: h5&#125;h5 &#123; counter-reset: h6&#125;#writer h1:before &#123; counter-increment: h1; content: counter(h1) &quot;. &quot;&#125;#writer h2:before &#123; counter-increment: h2; content: counter(h1) &quot;.&quot; counter(h2) &quot;. &quot;&#125;#writer h3:before &#123; counter-increment: h3; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;. &quot;&#125;#writer h4:before &#123; counter-increment: h4; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot;&#125;#writer h5:before &#123; counter-increment: h5; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot;&#125;#writer h6:before&#123; counter-increment: h6; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot;&#125; 讲道理 打开typora【偏好设置】 找到【通用】=&gt;【高级 】=&gt;【开启调试模式】=&gt;勾选 然后在非源码模式下=&gt;【右键】=&gt;【检查元素】，就可以看到为什么是#write了 这个后面还有用 在github pages 写markdown博客自动编号我用的是jekyllbootstrap.com的模板，比较简单 打开任意一篇rawbin-.github.io中的文章，然后【右键】=&gt;【检查】 可以拿到两个内容 容器类为 .content ，严格点为#wrap .content 样式文件在assets/themes/bootstrap3，可以修改其下的css/style.css 将如下内容改到源代码的assets/themes/bootstrap3/css/style.css中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.content &#123; counter-reset: h1&#125;h1 &#123; counter-reset: h2&#125;h2 &#123; counter-reset: h3&#125;h3 &#123; counter-reset: h4&#125;h4 &#123; counter-reset: h5&#125;h5 &#123; counter-reset: h6&#125;.content h1:before &#123; counter-increment: h1; content: counter(h1) &quot;. &quot;&#125;.content h2:before &#123; counter-increment: h2; content: counter(h1) &quot;.&quot; counter(h2) &quot;. &quot;&#125;.content h3:before &#123; counter-increment: h3; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;. &quot;&#125;.content h4:before &#123; counter-increment: h4; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot;&#125;.content h5:before &#123; counter-increment: h5; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot;&#125;.content h6:before&#123; counter-increment: h6; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot;&#125; 在其他网页编辑中自动编码比如各个博客平台，各个自媒体平台等，像我们常用的写文档的语雀都可以的。[最后发现只有那么几个平台可以，有的伪类被过滤替换掉了，有的是直接支持markdown无法富文本编辑，有的…]，这里有一个强限制，就是站点要自己可控才行，不然会因为一些过滤规则被干到原形不再。 这里面涉及到一款浏览器插件markdown here，可以在页面富文本编辑器中将markdown 自动转换为网页，这也是我前面说到的这几年在各个平台发文的套路，写好编号好标题markdown往编辑器里面一贴，然后一点 ，搞定。 简单尝试 markdown here 有一个配置页面，可以配置和调整css，并能预览效果 简单看了下是用js把类转成了style属性，并且不支持伪类 修改源码 到adam-p/markdown-here 看到，已经两年没动代码了 不管三七二十三先 fork一把到rawbin-/markdown-here，然后把代码拉下来 先把css文件建起来src/common/auto-number-title，找容器类可以在markdown here的选项页面找到.markdown-here-wrapper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.markdown-here-wrapper &#123; counter-reset: h1&#125;.markdown-here-wrapper h1 &#123; counter-reset: h2&#125;.markdown-here-wrapper h2 &#123; counter-reset: h3&#125;.markdown-here-wrapper h3 &#123; counter-reset: h4&#125;.markdown-here-wrapper h4 &#123; counter-reset: h5&#125;.markdown-here-wrapper h5 &#123; counter-reset: h6&#125;.markdown-here-wrapper h1:before &#123; counter-increment: h1; content: counter(h1) &quot;. &quot;&#125;.markdown-here-wrapper h2:before &#123; counter-increment: h2; content: counter(h1) &quot;.&quot; counter(h2) &quot;. &quot;&#125;.markdown-here-wrapper h3:before &#123; counter-increment: h3; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;. &quot;&#125;.markdown-here-wrapper h4:before &#123; counter-increment: h4; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot;&#125;.markdown-here-wrapper h5:before &#123; counter-increment: h5; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot;&#125;.markdown-here-wrapper h6:before&#123; counter-increment: h6; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot;&#125; 然后修改一下注入配置，允许加载这个样式文件，并引入这个样式问题 剩下的有错改错就好了 最终产出和应用 克隆rawbin-/markdown-here 打开Chrome 设置三个点=&gt;【更多工具】=&gt;【扩展程序】 打开【开发者模式】 选择【加载已解压的扩展程序】=&gt;选择克隆代码下的src目录即可安装并加载插件 将插件固定在插件栏方便使用 auto-number-title.scss内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243.markdown-here-wrapper &#123; counter-reset: h1; h1 &#123; counter-reset: h2; &amp;:before &#123; counter-increment: h1; content: counter(h1) &quot;. &quot;; &#125; &#125; h2 &#123; counter-reset: h3; &amp;:before &#123; counter-increment: h2; content: counter(h1) &quot;.&quot; counter(h2) &quot;. &quot; &#125; &#125; h3 &#123; counter-reset: h4; &amp;:before &#123; counter-increment: h3; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;. &quot; &#125; &#125; h4 &#123; counter-reset: h5; &amp;:before &#123; counter-increment: h4; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot; &#125; &#125; h5 &#123; counter-reset: h6; &amp;:before &#123; counter-increment: h5; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot; &#125; &#125; h6:before&#123; counter-increment: h6; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot; &#125;&#125; 再来简单讲一下道理CSS 自动编号 不是一个新特性，或者说是一个老特性了，出现在CSS 2.1中，搜索site:w3.org css automatic numbering 可以找到，当然截止今天后来的版本(CSS 3, CSS 2.2)都有这个特性，从caniuse上可以看到，IE8及以上兼容，很棒吧 简单说明 counter-reset 重置 counter-increment ++ counter() 取值 配合before和after来做 还有更多的玩法，参见 CSS The Defiiniitiive Guide 4th ，这里有翻译gdut-yy/CSS-The-Definitive-Guide-4th-zh Chrome插件或扩展开发 这个 我也没实际搞过，原来看了看书 可参考的资料 官方文档 sxei/chrome-plugin-demo 或者搜索Chrome插件 全攻略 《Chrome扩展及应用开发》，这个就是我原来看的那本老书 还是有些问题没解决 上面的操作方式必须要h1到h6依次排开，不然会很好看 如果标题本身就编号了的，就有点糟糕了 这俩问题在我github的博客里面都能看到，解决办法可以是运行下`` 顺便探索下CSS其他可变的内容CSS变量或者说自定义属性 这个IE不兼容，其他浏览器高版本兼容 1234567:root&#123; --var-test:xxx&#125;.body&#123; --var-test:ooo; prop-test:var(--var-test)&#125; attr() 这个caniuse也有些说不清楚，主体兼容也是从IE8开始的，需要自己总结 强大的地方是可以读取属性值，赋给另外的属性，也就是可以来个属性联动 看起来纯CSS的解决方案就到此告一段落了 如果能有脚本参与，就自由了 attr() 配合伪类来做展示，是一个JS和CSS通信的一个比较好的方式","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"代码规范","slug":"前端开发/Web开发/JavaScript/代码规范","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"css","slug":"css","permalink":"http://rawbin-.github.io/tags/css/"},{"name":"markdown","slug":"markdown","permalink":"http://rawbin-.github.io/tags/markdown/"},{"name":"W3C","slug":"W3C","permalink":"http://rawbin-.github.io/tags/W3C/"},{"name":"代码规范","slug":"代码规范","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"项目规范标准化","slug":"dev-env/2018-10-01-project-normalize","date":"2021-12-31T02:37:59.945Z","updated":"2021-12-31T02:37:59.945Z","comments":true,"path":"dev-env/2018-10-01-project-normalize/","link":"","permalink":"http://rawbin-.github.io/dev-env/2018-10-01-project-normalize/","excerpt":"","text":"规范化工具EditorConfig用来统一不同平台不同编辑器中的编辑内容规范的配置，被各种编辑器广泛的支持，一次配置处处统一的感觉 官网 配置规范 配置样例 .editorconfig1234567891011121314151617181920# 项目根目录下的这个值要 为true, 配置这一个就可以用了root = true# 针对所有文件的配置[*]# end_of_line = lf # 不配置就让系统自己定charset = utf-8tab_width = 4indent_size = 4indent_style = spaceinsert_final_newline = falsetrim_trailing_whitespace = true# 可以针对不同的文件类型单独配置# [*.&#123;js,jsx&#125;]# indent_size = 4# 也可以针对具体的文件单独配置# [&#123;package.json,package-lock.json&#125;]# indent_size = 4 文件格式 空行 只包含空格 注释 ; 或者 # 开头的行 区块头 [开头]结尾，/为路径分隔符,\\\\不能为路径分隔符 键值对 A=B的形式，中间可以有空格 匹配规则 * 匹配不带/的字符串 ** 匹配任意字符串 ? 匹配非/的单字符 [seq] 任意中括号内的单字符 [!seq]任意非中括号内的单字符 &#123;s1,s2,s3&#125; 任意单个字符串 &#123;num1,num2&#125; 任意一个范围内的整数 配置属性所有属性值都是大小写不敏感的，都会被核心库转为小写 root true 表示这个是顶层配置 indent_style tab space indent_size tab 用 tab_width 或 tab的宽度 列的数量 tab_width 列的数量，当indent_size是数字的时候，默认是indent_size end_of_line 不设置就可以不同平台用不同平台的，代码管理平台来控制 lf crlf cr charset latin utf-8 utf-16be utf-16le utf-8-bom trim_trailing_whitespace true false insert_final_newline true false ESLint冲破一切，最后胜出的一款ECMAScript及其周边的静态规范检查工具 官网 中文站点 安装配置123456npm i eslint -g # 全局安装npm i eslint -D # 本地安装eslint --init 生成配置文件eslint --fix path/to/fileseslint --fix-dry-run path/to/fileseslint --fix-type Array path/to/files 配置方式 注释方式，可以直接配置到源代码中 配置文件的方式，可以使用JavaScript,JSON或者YAML文件来进行配置 可以使用 .eslintrc.* 文件来配置，也可以在package.json 中的eslintConfig中配置 同一个目录下的 优先级顺序 .eslintrc.js .eslintrc.yaml .eslintrc.yml .eslintrc.json .eslintrc package.json 禁用规则 注释的方式 禁用一组文件的配置文件中的规则，使用rules,overrides 中再配置rules来做 忽略的文件 .eslintignore # 开头的行被当做注释 路径是相对于本配置文件的路径 忽略模式的规范跟.gitignore一致 gitignore 以!开头的为否定模式，重新包含前面被忽略的模式 默认lint .js文件，其他的需要根据命令行参数指定 1eslint --fix-dry-run --no-ignore --ext .js,.jsx . 配置属性 parser 常用默认的和 babel-eslint parserOptions 解析器的信息 ecmaVersion 这个字段不会自动启动比如ES6的全局变量 sourceType 默认script 可以设为module ecmaFeatures 额外的语言特性 globalReturn impliedStrict 全局严格模式 jsx experimentalObjectRestSpread 实验的特性 plugins 插件可以提供处理器 overrides 插件重写的配置 processor 可以从另一种文件中提取代码，然后处理其中的JavaScript env 检查所支持的环境，browser,node,commonjs,es6等 globals 全局变量 每个变量的属性值writable,readonly,off rules 具体的规则 每一个规则的值off,warn,error 或者 0,1,2 配置在插件中的规则时，需要是 插件名/ 规则ID的形式 规则配置文档 extends 扩展配置 eslint:recommended 扩展推荐的配置 StyleLint通用的样式规则检查工具 官网 1npm install --save-dev stylelint stylelint-config-standard 禁用规则12345678910/* stylelint-disable *//* stylelint-enable foo *//* stylelint-disable foo *//* stylelint-enable *//* stylelint-disable foo, bar *//* stylelint-disable baz *//* stylelint-enable baz, bar *//* stylelint-enable foo *//* stylelint-disable-line *//* stylelint-disable-next-line */ 配置Prettier非常受欢迎的代码美化工具 官网 12npm i eslint-config-prettier -Dnpm i eslint-plugin-prettier -D 配置改到.eslintrc.js中的extends序列中 配置lint-staged1npm i lint-staged -D 在package.json 中添加如下配置 12345&quot;lint-staged&quot;: &#123; &quot;*.js&quot;: [ &quot;eslint --fix&quot; ]&#125;, 匹配规则 使用micromatch 来匹配 *.js所有的js文件 !(*test).js除了*test.js的js文件 如果不带/ 就不管路径，如果带/就需要管路径 可以通过*.&#123;js,jsx&#125;来指定多个匹配后缀 配置 commitlint 安装 1npm install --save-dev @commitlint/&#123;cli,config-conventional&#125; 配置文件 commitlint.config.js 123module.exports = &#123; extends: [&#x27;@commitlint/config-conventional&#x27;]&#125; 配置husky1npm i husky -D 在package.json中加入如下配置 123456&quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;lint-staged&quot;, # 这个命令是想要的hook命令 &quot;commit-msg&quot;: &quot;commitlint -e $HUSKY_GIT_PARAMS&quot; &#125;&#125;, 编辑器配置WebStorm 或 IDEA系列的配置EditorConfig【Preference】=&gt;【Editor】=&gt; 【Code Style】=&gt; [Enable EditorConfig Support] 配置ESLint【Preference】=&gt; 【Language &amp; Frameworks】=&gt;【JavaScript】=&gt; 【Code Quality Tools】=&gt; 【ESLint】=&gt; [Automatic ESLint Configuation] VSCode 配置配置EditorConfig【Extention】=&gt;搜索[EditorConfig for VSCode] 然后 【install】即可 配置ESLint【Extention】=&gt;搜索[ESLint] 然后 【install】即可 项目实践操作EditorConfig拷贝如下内容到项目.editorconfig 文件中， 1234567891011121314151617181920# 项目根目录下的这个值要 为true, 配置这一个就可以用了root = true# 针对所有文件的配置[*]# end_of_line = lf # 不配置就让系统自己定charset = utf-8tab_width = 4indent_size = 4indent_style = spaceinsert_final_newline = falsetrim_trailing_whitespace = true# 可以针对不同的文件类型单独配置# [*.&#123;js,jsx&#125;]# indent_size = 4# 也可以针对具体的文件单独配置# [&#123;package.json,package-lock.json&#125;]# indent_size = 4 配置ESLint使用 eslint --init 并选择对应的选项 ，生成 基础的配置 增加基础的lint配置 ​ npm i eslint-config-recommended -D 然后在.eslintrc.js的extends中把 eslint:recommended放到第一个 增加对 babel的支持 npm i babel-eslint -D 然后在eslint 的配置文件里面增加 &quot;parser&quot;:&quot;babel-eslint&quot;的属性配置 配置Stylelint小程序配置 1npm install --save-dev stylelint stylelint-config-standard stylelint-config-standard-wxss 配置文件.stylelintrc.json 123&#123; &quot;extends&quot;: &quot;stylelint-config-standard-wxss&quot;&#125; 配置文件 .stylelintignore 12node_modulesminiprogram_npm React工程配置1npm install --save-dev stylelint stylelint-config-standard stylelint-scss 配置文件.stylelintrc.json 1234&#123; &quot;extends&quot;: &quot;stylelint-config-standard&quot;, &quot;plugins&quot;: [&quot;stylelint-scss&quot;]&#125; 配置文件 .stylelintignore 12node_modulesdist 配置lint-stagednpm i lint-staged -D 然后就可以在package.json中添加对应的配置了 12345678&quot;lint-staged&quot;: &#123; &quot;*.&#123;js,jsx&#125;&quot;: [ &quot;eslint --fix --ext .js,.jsx&quot; ], &quot;*.wxss&quot;: [ &quot;stylelint --fix --syntax css&quot; ]&#125;, 配置 commitlint 安装 1npm install --save-dev @commitlint/&#123;cli,config-conventional&#125; 配置文件 commitlint.config.js 123module.exports = &#123; extends: [&#x27;@commitlint/config-conventional&#x27;]&#125; 配置huskynpm i husky -D 然后就可以在package.json 中添加hooks了 123456&quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;lint-staged&quot;, # 这个命令是想要的hook命令 &quot;commit-msg&quot;: &quot;commitlint -e $HUSKY_GIT_PARAMS&quot; &#125;&#125;, 参考文档 ESLint 配置及应用 magic-lint commitlint commitzen standard-version stylelint","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"代码规范","slug":"前端开发/Web开发/JavaScript/代码规范","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"代码规范","slug":"代码规范","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://rawbin-.github.io/tags/TypeScript/"}]},{"title":"TypeScript简明参考手册","slug":"language/2018-09-25-typescript-ref","date":"2021-12-31T02:37:59.945Z","updated":"2021-12-31T02:37:59.945Z","comments":true,"path":"language/2018-09-25-typescript-ref/","link":"","permalink":"http://rawbin-.github.io/language/2018-09-25-typescript-ref/","excerpt":"","text":"TypeScript是JavaScript(ECMAScript)的超集，在支持JavaScript的基础上增强了自己的类型系统，强化了作为弱类型语言JavaScript在运行前的各种类型检查、依赖检查等等在提高项目代码质量、提升开发效率和降低风险中很有用的编译器特性。 本文基于TypeScript 3.8 类型系统基本类型boolean 布尔值 1let isDone:boolean = false number 数值 1234let decimal: number = 6;let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744; string 字符串 1234567let color: string = &quot;blue&quot;;color = &quot;red&quot;;let fullName: string = `Bob Bobbington`;let age: number = 37;let sentence: string = `Hello, my name is $&#123;fullName&#125;.I&#x27;ll be $&#123;age + 1&#125; years old next month.`; Array 数组/列表 两种指定的方式 12let list: number[] = [1, 2, 3];let list: Array&lt;number&gt; = [1, 2, 3]; Tuple 元组 设定特定序列的组合值 1234567891011// Declare a tuple typelet x: [string, number];// Initialize itx = [&quot;hello&quot;, 10]; // OK// Initialize it incorrectlyx = [10, &quot;hello&quot;]; // Errorconsole.log(x[0].substring(1)); // OKconsole.log(x[1].substring(1)); // Error, &#x27;number&#x27; does not have &#x27;substring&#x27;Property &#x27;substring&#x27; does not exist on type &#x27;number&#x27;.x[3] = &quot;world&quot;; // Error, Property &#x27;3&#x27; does not exist on type &#x27;[string, number]&#x27;.Tuple type &#x27;[string, number]&#x27; of length &#x27;2&#x27; has no element at index &#x27;3&#x27;. 123console.log(x[5].toString()); // Error, Property &#x27;5&#x27; does not exist on type &#x27;[string, number]&#x27;.Object is possibly &#x27;undefined&#x27;.Tuple type &#x27;[string, number]&#x27; of length &#x27;2&#x27; has no element at index &#x27;5&#x27;. Enum 枚举 给值更友好的名称 默认值从0开始，可以手动设置开始的值，也可以手动设置每一个值 可以通过值来获取值的名称 1234567enum Color &#123; Red = 1, Green, Blue,&#125;let c: Color = Color.Green; Any 都行 在JS2TS的迁移过程中常用 any类型可以赋任意值也能调用任意方法，但object类型只能赋任意值不能调用任意方法，即使存在也不行 123456789101112let notSure: any = 4;notSure = &quot;maybe a string instead&quot;;notSure = false; // okay, definitely a booleanlet notSure: any = 4;notSure.ifItExists(); // okay, ifItExists might exist at runtimenotSure.toFixed(); // okay, toFixed exists (but the compiler doesn&#x27;t check)let prettySure: Object = 4;prettySure.toFixed(); // Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.let list: any[] = [1, true, &quot;free&quot;];list[1] = 100; Void 无/空 如果变量定义为void,没多少用，只能赋值为null或者undefined(在没配置--strickNullChecks) 123function warnUser(): void &#123; console.log(&quot;This is my warning message&quot;);&#125; 12let unusable: void = undefined;unusable = null; // OK if `--strictNullChecks` is not given Null and Undefined 空对象/未定义 null和undefined 既是值也是类型 null和undefined是所有类型的子类型 可以把null和undefined赋值给其他类型 如果开了--stricNullChecks,null和undefined只能赋值给any和他们自己（此时undefined还能赋值给void）,这是为了避免同一个值多个（string或者null或者undefined）类型 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; Never 绝非 在函数抛异常或者永远不会返回的情况下的返回值类型 never类型是所有类似的子类型，并且除了它自己，它没有其他子类型 1234567891011121314// Function returning never must have unreachable end pointfunction error(message: string): never &#123; throw new Error(message);&#125;// Inferred return type is neverfunction fail() &#123; return error(&quot;Something failed&quot;);&#125;// Function returning never must have unreachable end pointfunction infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; Object 对象 代表所有的非原始类型 object 原始类型目前为 number,string,boolean,symbol,null,undefined 1234567891011121314declare function create(o: object | null): void;create(&#123; prop: 0 &#125;); // OKcreate(null); // OKcreate(42); // ErrorArgument of type &#x27;42&#x27; is not assignable to parameter of type &#x27;object | null&#x27;.create(&quot;string&quot;); // ErrorArgument of type &#x27;&quot;string&quot;&#x27; is not assignable to parameter of type &#x27;object | null&#x27;.create(false); // ErrorArgument of type &#x27;false&#x27; is not assignable to parameter of type &#x27;object | null&#x27;.create(undefined); // ErrorArgument of type &#x27;undefined&#x27; is not assignable to parameter of type &#x27;object | null&#x27;. 复合类型function 函数类型 1234567function add(x: number, y: number): number &#123; return x + y;&#125;let myAdd = function(x: number, y: number): number &#123; return x + y;&#125;; 123456let myAdd: (x: number, y: number) =&gt; number = function( x: number, y: number): number &#123; return x + y;&#125;; 可选参数（可选参数要在所有必选参数之后） 12345678function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + &quot; &quot; + lastName; else return firstName;&#125;let result1 = buildName(&quot;Bob&quot;); // works correctly nowlet result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // error, too many parameterslet result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); // ah, just right 默认参数（没有位置要求） 12345678function buildName(firstName = &quot;Will&quot;, lastName: string) &#123; return firstName + &quot; &quot; + lastName;&#125;let result1 = buildName(&quot;Bob&quot;); // error, too few parameterslet result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // error, too many parameterslet result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); // okay and returns &quot;Bob Adams&quot;let result4 = buildName(undefined, &quot;Adams&quot;); // okay and returns &quot;Will Adams&quot; 剩余参数，在参数最后 12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);&#125;let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName; 明确的this指向 123456789101112131415161718192021222324252627interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function(this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;; &#125;; &#125;&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit); 函数重载 12345678910111213141516171819202122232425262728let suits = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];function pickCard(x: &#123; suit: string; card: number &#125;[]): number;function pickCard(x: number): &#123; suit: string; card: number &#125;;function pickCard(x): any &#123; // Check to see if we&#x27;re working with an object/array // if so, they gave us the deck and we&#x27;ll pick the card if (typeof x == &quot;object&quot;) &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == &quot;number&quot;) &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [ &#123; suit: &quot;diamonds&quot;, card: 2 &#125;, &#123; suit: &quot;spades&quot;, card: 10 &#125;, &#123; suit: &quot;hearts&quot;, card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];alert(&quot;card: &quot; + pickedCard1.card + &quot; of &quot; + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(&quot;card: &quot; + pickedCard2.card + &quot; of &quot; + pickedCard2.suit); class 类类型 类有方法和属性，可以继承，ECMAScript 2015或者ES6开始支持 类的属性和方法可以有public, private,protected三种,属性可以用readonly修饰 public为默认，公开访问 private 不能被直接访问，有两种实现方式，ECMAScript用#在属性名前表示私有，TypeScript用private关键字 protected 可以被派生类访问 static属性和方法属于类属性或者类方法，不用实例调用 构造器参数使用属性装饰器，可以声明并初始化对应的属性，public,protected,private,readonly 访问器属性需要把编译器设置为ECMAScript 5 或者更高才支持，访问器属性有get没有set会自动设置为readonly abstract类和方法，不能被直接实例化，必须被派生类是实现了才可以 接口可以继承类，类声明做两件事一个是声明实例的类型，另一个是一个构造器函数 interface 接口类型 基本定义 使用?定义可选属性 readonly定义只读属性 12345interface LabeledValue &#123;label: string;value?: stringreadonly flag: boolean&#125; 123function printLabel(labeledObj: LabeledValue) &#123;console.log(labeledObj.label);&#125; 12let myObj = &#123; size: 10, label: &quot;Size 10 Object&quot; &#125;;printLabel(myObj); 避免过度检测的方式 使用类型断言 1let mySquare = createSquare(&#123; width: 100, opacity: 0.5 &#125; as SquareConfig); 使用任意类型的额外属性定义 12345interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125; Function 函数类型12345678910interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function (source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125;; Indexable 索引类型 可以用readonly设置只读 12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [&quot;Bob&quot;, &quot;Fred&quot;];let myStr: string = myArray[0]; Class 类 类型 接口描述了类公共的部分，不能描述私有的部分 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125; 类实现接口，只有类的实例部分会被检测，静态部分不会被检测，可以用类表达式来整合两者 1234567891011121314interface ClockConstructor &#123; new (hour: number, minute: number);&#125;interface ClockInterface &#123; tick();&#125;const Clock: ClockConstructor = class Clock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(&quot;beep beep&quot;); &#125;&#125;; 接口继承 接口可以继承，可以多继承 12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &#123;&#125; as Square;square.color = &quot;blue&quot;;square.sideLength = 10;square.penWidth = 5.0; 混合类型 得益于JavaScript动态类型的特性 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = function (start: number) &#123;&#125; as Counter; counter.interval = 123; counter.reset = function () &#123;&#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 接口继承类 继承类的接口具有类的所有属性（不管私有的还是公有的） 只有类的后代类能实现这个接口 123456789101112131415161718192021222324252627class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123;&#125;&#125;class TextBox extends Control &#123; select() &#123;&#125;&#125;// Error: Property &#x27;state&#x27; is missing in type &#x27;Image&#x27;.class ImageControl implements SelectableControl &#123;Class &#x27;ImageControl&#x27; incorrectly implements interface &#x27;SelectableControl&#x27;. Types have separate declarations of a private property &#x27;state&#x27;. private state: any; select() &#123;&#125;&#125;class Location &#123;&#125;Duplicate identifier &#x27;Location&#x27;. Literal 字面类型字符串字面量 字面量实现枚举 123456789101112131415161718type Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;;class UIElement &#123; animate(dx: number, dy: number, easing: Easing) &#123; if (easing === &quot;ease-in&quot;) &#123; // ... &#125; else if (easing === &quot;ease-out&quot;) &#123; &#125; else if (easing === &quot;ease-in-out&quot;) &#123; &#125; else &#123; // It&#x27;s possible that someone could reach this // by ignoring your types though. &#125; &#125;&#125;let button = new UIElement();button.animate(0, 0, &quot;ease-in&quot;);button.animate(0, 0, &quot;uneasy&quot;); 字面类型实现重载 123456function createElement(tagName: &quot;img&quot;): HTMLImageElement;function createElement(tagName: &quot;input&quot;): HTMLInputElement;// ... more overloads ...function createElement(tagName: string): Element &#123; // ... code goes here ...&#125; 数字字面量1234567interface MapConfig &#123; lng: number; lat: number; tileSize: 8 | 16 | 32;&#125;setupMap(&#123; lng: -73.935242, lat: 40.73061, tileSize: 16 &#125;); Enum 枚举类型数值枚举 默认为0 ，可以指定第一个开始的值，也可以为每一个名称指定值 123456enum Direction &#123; Up = 1, Down, Left, Right&#125; 字符串枚举123456enum Direction &#123; Up = &quot;UP&quot;, Down = &quot;DOWN&quot;, Left = &quot;LEFT&quot;, Right = &quot;RIGHT&quot;&#125; 计算和常数值123456789enum FileAccess &#123; // constant members None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, // computed member G = &quot;123&quot;.length&#125; Union 和 Intersection 类型union 联合类型1234567891011/** * Takes a string and adds &quot;padding&quot; to the left. * If &#x27;padding&#x27; is a string, then &#x27;padding&#x27; is appended to the left side. * If &#x27;padding&#x27; is a number, then that number of spaces is added to the left side. */function padLeft(value: string, padding: string | number) &#123; // ...&#125;let indentedString = padLeft(&quot;Hello world&quot;, true);Argument of type &#x27;true&#x27; is not assignable to parameter of type &#x27;string | number&#x27;. 返回共用类型的，只能用公共类型 12345678910111213141516171819interface Bird &#123; fly(): void; layEggs(): void;&#125;interface Fish &#123; swim(): void; layEggs(): void;&#125;declare function getSmallPet(): Fish | Bird;let pet = getSmallPet();pet.layEggs();// Only available in one of the two possible typespet.swim();Property &#x27;swim&#x27; does not exist on type &#x27;Bird | Fish&#x27;. Property &#x27;swim&#x27; does not exist on type &#x27;Bird&#x27;. 区别对待联合类型 123456789101112131415161718192021222324type NetworkLoadingState = &#123; state: &quot;loading&quot;;&#125;;type NetworkFailedState = &#123; state: &quot;failed&quot;; code: number;&#125;;type NetworkSuccessState = &#123; state: &quot;success&quot;; response: &#123; title: string; duration: number; summary: string; &#125;;&#125;;// Create a type which represents only one of the above types// but you aren&#x27;t sure which it is yet.type NetworkState = | NetworkLoadingState | NetworkFailedState | NetworkSuccessState; intersection 交叉类型123456789101112131415161718192021222324252627interface ErrorHandling &#123; success: boolean; error?: &#123; message: string &#125;;&#125;interface ArtworksData &#123; artworks: &#123; title: string &#125;[];&#125;interface ArtistsData &#123; artists: &#123; name: string &#125;[];&#125;// These interfaces are composed to have// consistent error handling, and their own data.type ArtworksResponse = ArtworksData &amp; ErrorHandling;type ArtistsResponse = ArtistsData &amp; ErrorHandling;const handleArtistsResponse = (response: ArtistsResponse) =&gt; &#123; if (response.error) &#123; console.error(response.error.message); return; &#125; console.log(response.artists);&#125;; 交叉类型的应用 1234567891011121314151617181920212223242526272829303132333435class Person &#123; constructor(public name: string) &#123;&#125;&#125;interface Loggable &#123; log(name: string): void;&#125;class ConsoleLogger implements Loggable &#123; log(name: string) &#123; console.log(`Hello, I&#x27;m $&#123;name&#125;.`); &#125;&#125;// Takes two objects and merges them togetherfunction extend&lt;First extends &#123;&#125;, Second extends &#123;&#125;&gt;( first: First, second: Second): First &amp; Second &#123; const result: Partial&lt;First &amp; Second&gt; = &#123;&#125;; for (const prop in first) &#123; if (first.hasOwnProperty(prop)) &#123; (result as First)[prop] = first[prop]; &#125; &#125; for (const prop in second) &#123; if (second.hasOwnProperty(prop)) &#123; (result as Second)[prop] = second[prop]; &#125; &#125; return result as First &amp; Second;&#125;const jim = extend(new Person(&quot;Jim&quot;), ConsoleLogger.prototype);jim.log(jim.name); generic 通用类型any 作为通用，不推荐通用类型变量123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity; 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &#123; &lt;T&gt;(arg: T): T &#125; = identity; 123456789interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn = identity; 通用类12345678910class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y;&#125;; 通用约束12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // Now we know it has a .length property, so no more error return arg;&#125; 12345678function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, &quot;a&quot;); // okaygetProperty(x, &quot;m&quot;); // error: Argument of type &#x27;m&#x27; isn&#x27;t assignable to &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27; | &#x27;d&#x27;. 1234567891011121314151617181920212223242526class BeeKeeper &#123; hasMask: boolean;&#125;class ZooKeeper &#123; nametag: string;&#125;class Animal &#123; numLegs: number;&#125;class Bee extends Animal &#123; keeper: BeeKeeper;&#125;class Lion extends Animal &#123; keeper: ZooKeeper;&#125;function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123; return new c();&#125;createInstance(Lion).keeper.nametag; // typechecks!createInstance(Bee).keeper.hasMask; // typechecks! 类型操作类型断言 在明确值类型的时候可以让解析器有更明确的动作 12345let someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length;let strLength2: number = (someValue as string).length; 类型别名123456789101112131415161718192021222324252627282930type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === &quot;string&quot;) &#123; return n; &#125; else &#123; return n(); &#125;&#125;type Container&lt;T&gt; = &#123; value: T &#125;;type Tree&lt;T&gt; = &#123; value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;;&#125;;type LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;interface Person &#123; name: string;&#125;var people: LinkedList&lt;Person&gt;;var s = people.name;var s = people.next.name;var s = people.next.next.name;var s = people.next.next.next.name; 声明合并 合并接口内容 合并名称空间 合并名称空间和类 合并名称空间和函数 合并名称空间和枚举 代码组织Module 模块 任何包含顶级的import或export的文件被当做模块，反之则当做普通脚本 Export 可以导出变量、函数、类、类型别名、接口 12345678export TYPE OBJECTexport &#123;OBJECT&#125;export &#123;OBJECT as ANOTHERNAME&#125;export &#123;OBJECT&#125; from &#x27;MODULE&#x27;export &#123;OBJECT as ANOTHERNAME&#125; from &#x27;MODULE&#x27;export * from &#x27;MODULE&#x27;export * as OBJECT from &#x27;MODULE&#x27;export default DEFAULT export= 只能用import MODULE = require(&#39;MODULE&#39;)来导入 1export = OBJECT Import1234567import &#123;OBJECT&#125; from &#x27;MODULE&#x27;import &#123;OBJECT as ANOTHERNAME&#125; from &#x27;MODULE&#x27;import * as OBJECT from &#x27;MODULE&#x27;import &quot;MODULE&quot;improt &#123;OBJECTTYPE&#125; from &#x27;MODULE&#x27;import type &#123;OBJECTTYPE&#125; from &#x27;MODULE&#x27;import DEFAULT from &#x27;MODULE&#x27; 动态模块加载123456789101112declare function require(moduleName: string): any;import &#123; ZipCodeValidator as Zip &#125; from &quot;./ZipCodeValidator&quot;;if (needZipValidation) &#123; let ZipCodeValidator: typeof Zip = require(&quot;./ZipCodeValidator&quot;); let validator = new ZipCodeValidator(); if (validator.isAcceptable(&quot;...&quot;)) &#123; /* ... */ &#125;&#125;Sample: Dynam 模块接口定义 不是TypeScript编写的库，需要声明库的接口才能使用 库的声明一般定义在.d.ts文件里面，类似于C/C++里面的头文件.h 外围模块精准声明和引用 声明 12345678910111213141516171819declare module &quot;url&quot; &#123; export interface Url &#123; protocol?: string; hostname?: string; pathname?: string; &#125; export function parse( urlStr: string, parseQueryString?, slashesDenoteHost? ): Url;&#125;declare module &quot;path&quot; &#123; export function normalize(p: string): string; export function join(...paths: any[]): string; export var sep: string;&#125; 引用 123/// &lt;reference path=&quot;node.d.ts&quot;/&gt;import * as URL from &quot;url&quot;;let myUrl = URL.parse(&quot;http://www.typescriptlang.org&quot;); 简化声明和引用 声明 1declare module &quot;hot-new-module&quot;; 引用 12import x, &#123; y &#125; from &quot;hot-new-module&quot;;x(y); 模块通配声明 SystemJS 和 AMD 声明 123456789declare module &quot;*!text&quot; &#123; const content: string; export default content;&#125;// Some do it the other way around.declare module &quot;json!*&quot; &#123; const value: any; export default value;&#125; 引用 123import fileContent from &quot;./xyz.txt!text&quot;;import data from &quot;json!http://example.com/data.json&quot;;console.log(data, fileContent); UMD模块声明 声明 12export function isPrime(x: number): boolean;export as namespace mathLib; 引用 123import &#123; isPrime &#125; from &quot;math-lib&quot;;isPrime(2);mathLib.isPrime(2); // ERROR: can&#x27;t use the global definition from inside a module 1mathLib.isPrime(2); 模块构建指南 导出到接近模块顶级的部分，这样引入就更加轻便 导出namespace会多了名称空间这一层 导出类的静态方法会多了类这一层，可以考虑导出为工具函数 导出单个的类或者函数，用export default 导出多个对象，都放在顶层export xx 导入 明确导入名称 import &#123;xx,yy&#125; from &#39;MODULE&#39; 使用名称空间方式导入多接口模块import * as xxx from &#39;MODULE&#39; 通过导入再重新导出的方式来扩展功能，保持原来的接口 在模块里面不要用名称空间 名称空间是在全局用来对逻辑相关的对象和类型进行分组归类的 在全局用来避免命名冲突很重要 常见的乱用场景 单个文件的唯一顶层声明是export namespace xx&#123;&#125;, 这种直接删掉并上移一层 多个文件有相同的顶层export namespace xx，这个不会合并的成一个的 Namespace 名称空间 用来逻辑上包装一系列的功能 可以在多个文件中使用同一个名称空间，也可以用引用标签来给编译器提供引用关系 可以通过import xx = x.y.z这样的方式来给名称空间设置别名 原来使用script标签加载的库而不是模块加载器定义的，用namespace来定义接口 模块和名称空间的使用 新项目新代码都用模块来组织代码 跨多个文件时使用名称空间 最外层没必要使用名称空间，这样会多一层，只有逻辑归类的时候更需要这个 模块 模块可以包含代码和声明 模块能够明确依赖（比如依赖模块加载器，运行时），能更好的重用代码，强隔离以及更好的开发工具支持 官方推荐优先使用模块，在新项目和新代码中 名称空间 名称空间是TypeScript特有的，ECMAScript没有 名称空间就是代码的逻辑组织，简单好用 名称空间可以跨多个文件（使用同一个名就行），也能用--outFile拼起来 名称空间在Web应用中组织代码的好方式，所有的依赖都包含在&lt;script&gt;标签中 名称空间有全局污染的问题，难以确认组件依赖，尤其是在大型项目中 模块声明声明引用12345// myModule.d.ts// In a .d.ts file or .ts file that is not a module:declare module &quot;SomeModule&quot; &#123;export function fn(): string;&#125; 123// myOtherModule.ts/// &lt;reference path=&quot;myModules.d.ts&quot; /&gt;import * as m from &quot;SomeModule&quot;; 模块解析相对引用 相对导入是以/,./,../开始的 除此之外的为非相对导入MODULE,@xx/yy 模块解析策略经典 AMD或者System或者ES2015 相对引用相对于引用文件来解析 非相对引用从目录树来解析 MODULE.ts和MODULE.d.ts 从当前文件夹找 从上一级文件找 一直找到根目录 Node 相对引用 从相对引用路径的文件来找 从相对引用路径的目录来找，目录要是一个包（有package.json文件，并有main字段配置） 从相对引用路径的目录来找，目录下有文件index.js 非相对引用，从node_modules来解析 找当前模块同一级的node_modules下对应的 对应的js文件,MODULE.js 对应的模块目录MODULE,目录要是一个包（有package.json文件，并有main字段配置） 对应的模块目录,目录下有文件index.js 找上一级的node_modules 一直找到根目录 TypeScript模块解析 相对引用 找.ts,.tsx,.d.ts 找MODULE 类似于Node的相对查找方法，package.json中找types属性 类似于Node的相对查找方法，找MODULE/index 非相对引用 找 .ts,.tsx,.d.ts 找当前目录下node_modules下的MODULE 类似于Node的相对查找方法，package.json中找types属性 找当前目录下node_modules/@types/MODULE.d.ts 类似于Node的相对查找方法，找MODULE/index 找上一级的node_modules 一直找到根目录","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"NodeJS","slug":"前端开发/Web开发/JavaScript/NodeJS","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/NodeJS/"},{"name":"TypeScript","slug":"前端开发/Web开发/JavaScript/NodeJS/TypeScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/NodeJS/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://rawbin-.github.io/tags/TypeScript/"}]},{"title":"Nest Web框架实战简明参考手册","slug":"framework/2018-09-25-nestjs-ref","date":"2021-12-31T02:37:59.945Z","updated":"2021-12-31T02:37:59.945Z","comments":true,"path":"framework/2018-09-25-nestjs-ref/","link":"","permalink":"http://rawbin-.github.io/framework/2018-09-25-nestjs-ref/","excerpt":"","text":"核心概念Nest本身 是一个基于Node.js的高效可扩展的服务端应用的Web框架 完全支持TypeScript，本身就是用TypeScript实现的 结合面向对象编程（OOP），函数式编程（FP）和函数响应式编程（FRP） 底层是基于Express实现的，也能轻松集成Fastify 集成度高，致力于提供可测试、可扩展、松耦合和易维护的应用框架，思想大体来源于Angular 有一套完整的项目结构生成模板，有每一个项目组件的生成模板 有各种微服务组件的集成，大小型项目都能轻易玩起来 等等 应用分类网络应用 基于HTTP的平台 基于Websocket的应用 微服务（基于TCP和UDP） 脱机/单机/独立 应用(不带网络监听的)混合应用 同时包含了微服务和其他网络应用的应用 Decorators 装饰器 Nest 构建的基础，是ES2016的语言特性，从代码表达形式上很容易看出来 可以用来传递数据，可以跟管道联合使用 可以将多个装饰器构建为一个装饰器来使用 Nest 提供的对应Web框架的参数装饰器，对应原生Web框架的对象 @Request =&gt; req @Response =&gt; res @Nest =&gt; next @Session =&gt; req.session @Param(param?: string) =&gt; req.params/req.params[param] @Body(param?: string) =&gt; req.body/req.body[param] @Query(param?: string) =&gt; req.query/req.query[param] @Headers(param?: string) =&gt; req.headers / req.headers[param] @Ip =&gt; req.ip Module 模块 是标注Module装饰器的一个类 是Nest组织项目结构的一部分，是用来组织程序部件的有效方式，模块组织以下内容 providers 提供者 ，要被Nest注入器实例化的提供者，会被至少在本模块共享 controllers 控制器，本模块定义的要被实例化的控制器 imports 本模块依赖的模块 exports 本模块要暴露的模块，是providers的子集 应用生命周期启动过程 引导启动 onModuleInit事件，针对每一个模块，在模块初始化完成后执行 等待子控制器和提供者的onModuleInit方法执行完成 等待模块的onModuleInit方法执行完成 onApplicationBootstrap 事件， 针对每一个模块 等待子控制器和提供者onApplicationBootstrap方法执行完成 等待模块的onApplicationBootstrap方法执行完成 初始化监听器（ 针对HTTP Server，WS Server和每一个微服务 等待连接打开或者就绪 Nest整个应用启动完成 关闭过程 onModuleDestory 针对每一个模块 等待子控制器和提供者onModuleDestory方法执行完成 等待模块的onModuleDestory方法执行完成 beforeApplicationShundown 针对每一个模块 等待子控制器和提供者beforeApplicationShundown方法执行完成 等待模块的beforeApplicationShundown方法执行完成 关闭监听器 针对HTTP Server，WS Server和每一个微服务 等待连接关闭 onApplicationShundown 针对每一个模块 等待子控制器和提供者onApplicationShundown方法执行完成 等待模块的onApplicationShundown方法执行完成 请求生命周期收到请求middleware 中间件 全局绑定的中间件 模块绑定的中间件 guard 守卫 全局守卫 控制器守卫 路由守卫 interceptor 拦截器 全局拦截器（pre-controller） 控制器拦截器（pre-controller） 路由拦截器（pre-controller） pipe 管道 全局管道 控制器管道 路由管道 路由参数管道 controller 控制器（方法处理器）service 服务（如果存在）interceptor 拦截器 路由拦截器（post-request） 控制器拦截器（post-request） 全局拦截器（post-request） filter 过滤器 路由过滤器 控制器过滤器 全局过滤器 服务端响应MVC架构相关概念Middleware 中间件 在路由控制器之前调用的函数 可以访问request和response对象，调用next函数继续请求响应流程，返回响应内容终止流程 Guards 守卫 一个使用Injectable装饰器，同时实现了CanActivate 接口的类 只负责根据特定的条件（比如权限，角色，访问控制列表等）决定请求是否需要被路由处理器处理 能访问ExecutionContext执行上下文，明确知道接下来会执行什么， Interceptors 拦截器 一个使用Injectable装饰器，同时实现了NestInterceptor 接口的类 受AOP思想的启发，提供了实现如下行为的能力： 在方法执行前后绑定额外的逻辑 转换函数执行的结果 转换函数抛出的异常 扩展基本的函数行为 根据一定的条件重新函数的功能，比如根据缓存来重写 Pipes 管道 一个使用Injectable装饰器，同时实现了PipeTransform 接口的类 管道典型应用场景： 数据转换，将输入转到预期的输出 数据校验，校验输入数据是否有效，校验通过就直接透传，不通过就抛异常 管道在控制器方法调用前被调用，接收方法的入参；如果管道抛异常，不会再执行控制器方法 Exception Filter 异常过滤器 Nest内置一个异常层来负责全局处理所有未处理的异常 可以使用标准的异常，也可以过滤部分或者全部异常来自定义异常处理， Controller 控制器 负责处理请求和给出响应 请求是从路由分配过来的 每一个控制器可以通过Controller装饰器来定义路由 每一个控制器下的方法 可以通过HTTP对应的方法装饰器，如Get,Post等定义下级路由 可以通过Res,Req装饰器注入框架原生的请求响应实例 Provider 提供者 提供依赖注入的能力，使得对象直接可以创建多样的关系 依赖注入是IoC控制反转的一种实现方式，Nest运行时本身是一个IoC容器 本质上是一个使用了Injectable装饰器类 很多Nest中的基本类都可以作为提供者，比如Service、Repository、Factory、Helper等等 标准提供者方式是给模块（module）配置提供者（provider）信息，自定义的场景如下 创建自定义的实例而不是Nest提供的 重用已有的类来做另一个依赖 重写用来测试的模拟类 自定义提供者的实现方式useValue,useClass,useFactory,useExisting,Inject装饰器等等 Service 服务 服务是常见的提供者，直接通过控制器的构造函数注入到控制器 应用解析Workspace Project（工作区项目） project（项目）在这里的定义可以为如下两种中的任一一种 application（应用） ，标准的Nest 应用，也是常见的Web应用结构 library（库），是一种打包通用功能特性（比如模块，提供者，控制器等等）的方式，无法独立运行 所有的工作区项目都有一个默认项目，在nest-cli.json中定义，被nest start和nest build作为默认值调用 application和library有两个区别可以从配置文件看出来： type分别为application和library，这不是废话 entryFile 分别为main 和 index Application 应用 也叫应用型项目，在单库模式常用，就是标准的Nest 应用结构，使用nest g app 或者nest g sub-app生成的 可以用nest start xxx 启动应用型项目 Library 库 也叫库型项目，使用nest g lib生成 standard 标准模式（默认） 用来组织单独的以项目为中心的应用 这些应用不需要优化模块共享，也不需要优化复杂的打包过程等等 monorepo 单库模式 monorepo是一种代码组织的思想，怎么翻译不重要，对应multirepo，将多个紧密关联又相互独立的项目放到一个仓库里面来管理，使用工作区的概念 在标准模式的基础上（只有一个应用）,添加一个子应用(nest g app xx)或者一个库(nest g lib yy)，则自动转为单库模式，转换过程就是当前应用（这会应该叫工作区间了）放了多个应用，看一眼就懂了 这种模式带来的好处 将代码资源当做轻量级单独的一部分来对待，更适合多开发人员的团队或者多项目的环境 将打包过程部分自动化，更容易创建和管理模块化的组件 带来更好的代码重用 使集成测试更容易 项目范围内的资源共享更容易，比如配置策略， 过滤规则，钩子函数等等，比类似于git submodules更好用 命令行工具 nest功能概览1234567891011121314151617181920212223242526272829303132333435363738$ nest -hUsage: nest &lt;command&gt; [options]Options: -v, --version Output the current version. -h, --help Output usage information.Commands: new|n [options] [name] Generate Nest application. build [options] [app] Build Nest application. start [options] [app] Run Nest application. info|i Display Nest project details. update|u [options] Update Nest dependencies. add [options] &lt;library&gt; Adds support for an external library to your project. generate|g [options] &lt;schematic&gt; [name] [path] Generate a Nest element. Available schematics: ┌───────────────┬─────────────┐ │ name │ alias │ │ application │ application │ │ class │ cl │ │ configuration │ config │ │ controller │ co │ │ decorator │ d │ │ filter │ f │ │ gateway │ ga │ │ guard │ gu │ │ interceptor │ in │ │ interface │ interface │ │ middleware │ mi │ │ module │ mo │ │ pipe │ pi │ │ provider │ pr │ │ resolver │ r │ │ service │ s │ │ library │ lib │ │ sub-app │ app │ └───────────────┴─────────────┘ 命令详解new 简写 n 生成标准模式的项目结构的所有文件 build 按nest的方式打包 start 编译并运行应用（或则工作区的默认项目） info 输出项目相关的部件及版本相关信息 update 更新nest相关的依赖到最新版本 add 导入一个已被打包为nest 库的库，执行它的安装过程 generate application 创建一个标准结构的应用，不安装依赖包（nest new 会安装） class 生成一个空的类及测试文件 configuration 生成一个nest-cli.json ,暂时还不好用 controller 生成一个空的controller及测试文件 decorator 生成一个空的装饰器文件 filter 生成一个空的过滤器及其测试文件 gateway 生成一个空的网关及其测试文件 guard 生成一个空的守卫及其测试文件 interceptor 生成一个空的拦截器及其测试文件 interface 生成一个空的接口文件 middleware 生成一个空的中间件及其测试文件 module 生成一个空的模块文件 pipe 生成一个空的管道及其测试文件 provider 生成一个空的提供者及其测试文件 resolver 生成一个graphql的解析器及其测试文件 service 生成一个空的服务及其测试文件 library 生成完整的lib结构放入libs目录，如果当前项目是标准模式会转换为单库模式 sub-app 生成完整的app结构放入apps目录，如果当前项目是标准模式会转换为单库模式 常用实现参考参考入口 相关资料 techniques recipes 常用功能特性静态站点 @nestjs/serve-static mvc 权限控制 authentication nestjsx/nest-access-control CURD 中文参考 nestjsx/crud cqrs 项目配置 nestjsx/nestjs-config @nestjs/config 项目文档 compdoc swagger 项目日志 logger nest-winston nest-morgan 健康检查 Terminus HTTP集成 HTTP 文件上传 multer 序列化 class-transformer GraphQL转换 Prisma nestjs-query 数据库 database typeorm sequelize mongodb @nest/mongoose mongoose nestjs-typegoose 数据校验 class-validator 路由 nestjsx/nest-router 缓存 cache-manager 任务队列 bull rabbitmq nestjsx/nestjs-amqp amqplib 安全性 helmet 定时任务 @nestjs/schedule 项目实战相关概念 application 标准项目里面代表整个项目，单库项目里面代表一个子应用 library 生成完整的lib结构放入libs目录，如果当前项目是标准模式会转换为单库模式 sub-app 生成完整的app结构放入apps目录，如果当前项目是标准模式会转换为单库模式 controller 控制器，负责处理请求和给出响应 service 服务，一种是提供者，负责处理业务逻辑 middleware 在路由处理程序之前调用，可以访问请求和响应对象，通用的过滤函数 module 模块，用来组织项目结构 decorator 装饰器，语言特性，用来支持功能增强和功能复用 provider 提供者，通用的可注入的类，一般会更具体的类，比如service filter 过滤器，用来处理异常过滤 pipe 管道，用来做数据转换和验证 guard 守卫，用来做权限控制 interceptor 拦截器，面向切面编程的思想，函数前后增加额外逻辑，转换函数的结果或抛出的异常等 class 通用的纯粹的TypeScript类 interface 通用的TypeScript接口 configuration 项目配置nest-cli.json gateway 网关，抽象的应用类型之上的 resolver 解析器，提供把graphql操作转换成数据的指令 项目需求 访问RabbitMQ获取关键信息 或者 通过接口传入 通过MQ中拿到的信息查询MongoDB 提供页面服务和模板渲染 提供信息配置 提供健康检查 提供日志记录 提供Web安全防护 项目规划 从Nest的设计来说，RabbitMQ属于微服务，而页面属于HTTP服务，所以本项目是一个混合应用 相关参考 rabbitmq实现 参考 mongodb实现 参考 typegoose 页面服务 参考, 模板渲染 参考 信息配置 参考 健康检查 参考 日志信息 参考 安全配置 参考 项目结构设计 使用单库模式 各个功能以公共模块的方式存在于项目中，可以简单实现插拔","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"NodeJS","slug":"前端开发/Web开发/JavaScript/NodeJS","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/NodeJS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://rawbin-.github.io/tags/TypeScript/"},{"name":"Nest","slug":"Nest","permalink":"http://rawbin-.github.io/tags/Nest/"}]},{"title":"PM2 进程管理配置","slug":"dev-env/2018-09-12-pm2-doc","date":"2021-12-31T02:37:59.944Z","updated":"2021-12-31T02:37:59.944Z","comments":true,"path":"dev-env/2018-09-12-pm2-doc/","link":"","permalink":"http://rawbin-.github.io/dev-env/2018-09-12-pm2-doc/","excerpt":"","text":"进程管理命令status/list/ls/l 查看当前PM2管理的进程列表及状态start/stop/restart/delete 启动/停止/重启/删除应用 APP_NAME/APP_ID/all/ecosystem.config.js reload 无中断/无缝重新加载代码 logs 日志信息查询 monit 命令行的监控信息 ecosystem 配置文件生成 (参数说明)[https://pm2.keymetrics.io/docs/usage/application-declaration/] 参数参考1234567891011121314151617181920212223242526272829# Specify an app name--name &lt;app_name&gt;# Watch and Restart app when files change--watch# Set memory threshold for app reload--max-memory-restart &lt;200MB&gt;# Specify log file--log &lt;log_path&gt;# Pass extra arguments to the script-- arg1 arg2 arg3# Delay between automatic restarts--restart-delay &lt;delay in ms&gt;# Prefix logs with time--time# Do not auto restart app--no-autorestart# Specify cron for forced restart--cron &lt;cron_pattern&gt;# Attach to application log--no-daemon 命令参考1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Fork modepm2 start app.js --name my-api # Name process# Cluster modepm2 start app.js -i 0 # Will start maximum processes with LB depending on available CPUspm2 start app.js -i max # Same as above, but deprecated.pm2 scale app +3 # Scales `app` up by 3 workerspm2 scale app 2 # Scales `app` up or down to 2 workers total# Listingpm2 list # Display all processes statuspm2 jlist # Print process list in raw JSONpm2 prettylist # Print process list in beautified JSONpm2 describe 0 # Display all informations about a specific processpm2 monit # Monitor all processes# Logspm2 logs [--raw] # Display all processes logs in streamingpm2 flush # Empty all log filespm2 reloadLogs # Reload all logs# Actionspm2 stop all # Stop all processespm2 restart all # Restart all processespm2 reload all # Will 0s downtime reload (for NETWORKED apps)pm2 stop 0 # Stop specific process idpm2 restart 0 # Restart specific process idpm2 delete 0 # Will remove process from pm2 listpm2 delete all # Will remove all processes from pm2 list# Miscpm2 reset &lt;process&gt; # Reset meta data (restarted time...)pm2 updatePM2 # Update in memory pm2pm2 ping # Ensure pm2 daemon has been launchedpm2 sendSignal SIGUSR2 my-app # Send system signal to scriptpm2 start app.js --no-daemonpm2 start app.js --no-vizionpm2 start app.js --no-autorestart","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"Node.js","slug":"Node-js","permalink":"http://rawbin-.github.io/tags/Node-js/"},{"name":"PM2","slug":"PM2","permalink":"http://rawbin-.github.io/tags/PM2/"}]},{"title":"NodeJS 服务端技术调研","slug":"dev-env/2018-09-10-node-service-preview","date":"2021-12-31T02:37:59.944Z","updated":"2021-12-31T02:37:59.944Z","comments":true,"path":"dev-env/2018-09-10-node-service-preview/","link":"","permalink":"http://rawbin-.github.io/dev-env/2018-09-10-node-service-preview/","excerpt":"","text":"技术框架选型Node特点及适用性特点 从2009年3月开始亮相，目前发展10+年 事件驱动，轻量、松耦合、只关注事务点 单线程（JavaScript代码执行）， 没有同步问题，没有死锁，没有线程切换的影响 无法利用多核，一个错误会引起整个应用退出，健壮性有风险 通过child_process、Cluster、Cluster2来解决 异步非阻塞I/O，减少昂贵的I/O对CPU计算的影响，充分利用硬件资源 应用场景 不太适合CPU密集型业务（也不差，可以通过分解业务解决），适合I/O密集型业务 通过编写C/C++扩展或者child_process来解决 前后端公用模板的系统 Web开发框架 包名称 github Star数 周下载量 上次发布时间 备注 express 46.4k 10,638,972 6 months ago koa 28k 388,602 a month ago 备选 nest 25.6k 100,465 hapi 11.9k 148,441 3 months ago restify 9.6k 103,575 7 days ago fastify 12.7k 60,139 a day ago 文档中有对比数据 loopback 13k 48,179 6 months ago egg 14.4k 6,750 2 days ago 基于koa，备选 sails 21k 37,670 6 months ago micro 60,466 5 months ago 微服务框架 @feathersjs/feathers 11.9k 38,304 3 days ago derby 4.5k 156 6 days ago seneca 3.6k 8664 3 months ago 备选 Connect 2010年开始出现，只是一个中间件层，后被用在Express和Koa中 Express 2010年开始出现，继承了Connect的思想并内置了很多中间件，MEAN（MongoDB+Express+Angular+Node）非常流行 Koa 2013年底，Express原班人马打造，解决Express异步中间件层级调用等问题，内部没提供中间件 Hapi restify fastify LoopBack eggjs thinkjs sails micro @feathersjs/feathers derby Seneca Node微服务框架 模板引擎 包名称 github Star数 周下载量 上次发布时间 备注 art-template 8.7k 30,801 a year ago 备选 velocityjs 506 166,655 2 months ago pug 18.8k 543,078 6 months ago 原名jade handlebars 15k 9,244,577 21 days ago 备选 mustache 13.5k 1,343,511 2 days ago ejs 4k 4,601,778 15 days ago 备选 dot 4.4k 172,329 2 days ago nunjucks 6.4k 242,099 9 months ago art-template velocityjs Jade/pug Handlebars Mustache Embedded JavaScript dot numjucks 这里有个对比 art-template 性能表现好 数据库框架 包名称 github Star数 周下载量 上次发布时间 备注 typeorm 16.5k 201,756 4 days ago sequelize 20.6k 465,897 a month ago knex 11k 412,470 a day ago typeorm Sequelize knex 服务端渲染 Vue vue-server-renderer nuxtjs quasar React react-dom/server nextjs 实时通信 Websocket WebRTC Socket.IO 开发测试编码规范 eslint 安全编码 xss 转义输出 csrf 验证token 异常处理 try catch 无法捕捉try 中异步异常 server on error process on uncaughtException domains(pending deprecated) 结束进程 避免抛出新异常 process.exit 结束进程 timmer.unref 避免timmer阻止进程退出 server.close 停止接收新连接 cluster.work.disconnect 关闭IPC通道 流程控制 async step wind bagpipe 自动化测试 相关概念参考 Nock HTTP相关测试 Nyc 覆盖度测试 Selenium 浏览器相关自动化测试 Headless Browser puppeteer 汇总 https://github.com/dhamaniasad/HeadlessBrowsers 压测 ab JMeter 测试框架 汇总 https://phantomjs.org/headless-testing.html Karma mocha ava jasmine Vows async + BDD风格 SuperTest RESTful API Sinon.JS 端到端测试 CasperJS PhantomJS SlimerJS Protractor Nightwatch TestCafe CodeceptJs 断言库 chai BDD风格+TDD风格 should.js BDD风格 expect.js BDD风格 assert TDD风格 覆盖率 istanbul nyc 部署维护服务进程管理 简单比较 pm2 nodemon forever strong-pm node-supervisor upstart init.d systemd 服务监控 PM2 Keymetrics 监控指标 响应时间 进程监控 磁盘监控 内存监控 CPU监控 心跳监测 Node自带, process 相关信息 REPL 《node项目实践》 《Node调试指南》 alinode 日志追踪 winston bunyan log log4js Patertrail 中间件 morgan express-winston 安全相关 防止命令注入 持续集成和持续部署 Travis CI Jenkins strider 部署容器 Docker kubernetes chef vagrant","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"Node.js","slug":"Node-js","permalink":"http://rawbin-.github.io/tags/Node-js/"}]},{"title":"从零搞一个Node项目结构模板","slug":"dev-env/2018-09-22-node-ts-project-templates","date":"2021-12-31T02:37:59.944Z","updated":"2021-12-31T02:37:59.944Z","comments":true,"path":"dev-env/2018-09-22-node-ts-project-templates/","link":"","permalink":"http://rawbin-.github.io/dev-env/2018-09-22-node-ts-project-templates/","excerpt":"","text":"Nest Web项目结构生成第一次接触框架结构生成器是在好几年前用Django的时候，后面用Node也有类似的操作，确实省了不少事，直接上手吧 项目结构生成观望一下 先安装命令行工具 1npm i @nestjs/cli -g 查看都能干些啥 1234567891011121314151617181920212223242526272829303132333435363738$ nest -hUsage: nest &lt;command&gt; [options]Options: -v, --version Output the current version. -h, --help Output usage information.Commands: new|n [options] [name] Generate Nest application. build [options] [app] Build Nest application. start [options] [app] Run Nest application. info|i Display Nest project details. update|u [options] Update Nest dependencies. add [options] &lt;library&gt; Adds support for an external library to your project. generate|g [options] &lt;schematic&gt; [name] [path] Generate a Nest element. Available schematics: ┌───────────────┬─────────────┐ │ name │ alias │ │ application │ application │ │ class │ cl │ │ configuration │ config │ │ controller │ co │ │ decorator │ d │ │ filter │ f │ │ gateway │ ga │ │ guard │ gu │ │ interceptor │ in │ │ interface │ interface │ │ middleware │ mi │ │ module │ mo │ │ pipe │ pi │ │ provider │ pr │ │ resolver │ r │ │ service │ s │ │ library │ lib │ │ sub-app │ app │ └───────────────┴─────────────┘ 只是看看都干了些啥 --dry-run 这是非常有用，非常通用的选项 如果记不住，请记住我的翻译——干-跑，当然只是为了印象深刻哈，请专业一点~ 跑跑看，只是看看做了什么，只是看看 1234567891011121314151617181920$ nest new test-app --dry-run⚡ We will scaffold your app in a few seconds..CREATE test-app/.eslintrc.js (599 bytes)CREATE test-app/.prettierrc (51 bytes)CREATE test-app/README.md (3370 bytes)CREATE test-app/nest-cli.json (64 bytes)CREATE test-app/package.json (1896 bytes)CREATE test-app/tsconfig.build.json (97 bytes)CREATE test-app/tsconfig.json (336 bytes)CREATE test-app/src/app.controller.spec.ts (617 bytes)CREATE test-app/src/app.controller.ts (274 bytes)CREATE test-app/src/app.module.ts (249 bytes)CREATE test-app/src/app.service.ts (142 bytes)CREATE test-app/src/main.ts (208 bytes)CREATE test-app/test/app.e2e-spec.ts (630 bytes)CREATE test-app/test/jest-e2e.json (183 bytes)Command has been executed in dry run mode, nothing changed! 直接上手 新建一个项目 12npm i @nestjs/cli -gnest new test-application 在当前目录下初始化，如果对应文件存在会报错 1nest new . 更多命令，请自行玩耍，用上面的方法 参考 目录结构解析查看目录结构123456789101112131415161718$ tree -I node_modules.├── LICENSE ├── README.md├── nest-cli.json├── package-lock.json├── package.json├── src│ ├── app.controller.spec.ts│ ├── app.controller.ts│ ├── app.module.ts│ ├── app.service.ts│ └── main.ts├── test│ ├── app.e2e-spec.ts│ └── jest-e2e.json├── tsconfig.build.json└── tsconfig.json 通用项目结构文件可以参考TS官方的TS项目结构，大体都差不多，TypeScript-Node-Starter 基础文件协议文件 添加LICENCE或LICENSE文件， 说明对应的开源协议 到SPDX License List 或者Open Source Initiative，下载相应协议的模板，我们这里选用MIT 修改必要的协议时间和作者 这里我觉得没必要保留80列宽了，现在的显示设备几乎没必要这么玩了 12345678MIT LicenseCopyright (c) &lt;year&gt; &lt;copyright holders&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 说明文件 添加README或者ReadMe.md或者README.md文件 说明项目的一些信息 给出详细参考资料的链接 给读者一个整体的导航内容 等等 git文件过滤 添加.gitignore 文件，忽略不需要提交的文件变更 自动生成 可以去github gitignore 下载一个最相近的模板然后改改 可以去gitignore.io生成一个,然后把内容拿下了 可以参考gitignore.io 文档，自己配命令行工具，以便随时可以玩 我们这里生成了一个macOS + Node + Webstorm 的结果 自己手写 内容语法参考gitignore doc 生成项目文件1npm init 增加TypeScript支持生成配置文件 12npm i typescript -Dnpx tsc --init 在当前目录下会生成tsconfig.json，可以根据情况自行调整 增加TS的Lint规则TypeScript官方采用ESLint规则了，通过配置可以生成对应的配置，如果要手动改，配置对应的包就行@typescript-eslint/parser @typescript-eslint/eslint-plugin 12npm i eslint -Dnpx eslint --init 手动创建规则排除文件.eslintignore 12345678910# /node_modules/* in the project root is ignored by default# build artefactsdist/*coverage/*# data definition files**/*.d.ts# 3rd party libs/src/public/# custom definition files/src/types/ 类型定义文件生成 包文件类型定义生成 12npm i dts-gen -Dnpx dts-gen -m MODULE_NAME -t TEMPLATENAME 单个文件类型定义文件生成 12npm i dtsmake -Dnpx dtsmake -s ./path/to/sourcefile.jsdtsmake -s ./path/to/sourcefile.jsD 使用TypeScript直接运行只建议在开发环境使用，效率问题 1npm i ts-node -D 添加相关框架添加Web框架几乎每一个Web框架都有对应的不同成熟度的项目结构生成工具，用起来，省点劲 express 生成App相关目录结构 12npm i express-generator -Dnpx express APP_NAME koa 12npm i koa-generator -Dnpx koa APP_NAME nest 12npm i @nestjs/cli -Dnpx nest APP_NAME egg 1npm init egg APP_NAME 添加测试框架添加相关依赖并生成配置文件 12npm install -D jest ts-jest @types/jestnpx jest --init 其他相关内容根据情况添加，比如CI/CD的，Docker的","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"NodeJS","slug":"前端开发/Web开发/JavaScript/NodeJS","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/NodeJS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"项目结构","slug":"项目结构","permalink":"http://rawbin-.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"},{"name":"项目模板","slug":"项目模板","permalink":"http://rawbin-.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/"}]},{"title":"docker安装配置生态全览","slug":"dev-env/2018-09-20-docker-config","date":"2021-12-31T02:37:59.944Z","updated":"2021-12-31T02:37:59.944Z","comments":true,"path":"dev-env/2018-09-20-docker-config/","link":"","permalink":"http://rawbin-.github.io/dev-env/2018-09-20-docker-config/","excerpt":"","text":"基本概念虚拟化 虚拟机和容器都属于软件虚拟化的范畴，软件虚拟化=&gt;平台虚拟化=&gt;操作系统虚拟化=&gt;容器技术(docker为其中一种) 容器虚拟化可以更高效的构建应用，也更容易管理维护 镜像 是docker容器的基础，是docker容器的初始状态 包含数据和必要的元数据（JSON描述文件，描述镜像信息、数据之间的关系，容器配置等） 容器 是一个可移植的运行单元，是docker镜像的运行实例 是基于docker镜像创建、包含运行某一特定应用程序所需要的的OS、软件、配置文件和数据的集合，是docker运行态的体现 仓库 镜像的存取的地方 安装CentOS 下安装分步安装 (如果有)删除旧版本 12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 添加必要组件 12sudo yum updatesudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加docker软件源 1sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 更新软件源缓存并安装docker 123sudo yum updatesudo yum install -y docker-cesudo systemctl start docker 脚本安装123curl -fsSL https://get.docker.com -o get-docker.sh## 注意安全 最好检查下sudo sh get-docker.sh 其他环境 参考客户端安装和脚本安装 配置数据管理数据卷docker volumn命令及其子命令来管理 create inspect ls prune rm 可以在docker run 的时候绑定数据卷 1docker run [OPTIONS] --mount type=[volumn|bind|tmpfs],source=PATH,destination=PATH CONTAINER COMMAND [ARGS...] 数据卷容器123docker run -it -v /dbdata --name dbdata ubuntu ## 创建数据容器docker run -it --volumes-from dbdata --name db1 ubuntudocker run -it --volumes-from dbdata --name db2 ubuntu ## 其他容器挂载数据卷 利用数据卷容器迁移数据备份1docker run --volumes-from dbdata -v $(pwd):/backup --name worker ubuntu tar cvf /backup/backup.tart /dbdata ## 启动容器并备份到 backup.tar 恢复12docker run -v /dbdata --name dbdata2 ubuntu /bin/bash ## 创建带数据卷的容器dbdata2docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar 端口映射随机端口1docker run -d -P NAME 指定端口1docker run -d -p IP:HOST_PORT:CONTAINER_PORT|IP::CONTAINER_PORT|HOST_PORT:CONTAINER_PORT 映射结果区别 IP:HOST_PORT:CONTAINER_PORT 指定地址的指定端口 IP::CONTAINER_PORT 指定地址的任一端口 HOST_PORT:CONTAINER_PORT 所有地址的指定端口 查看端口映射1docker port NAME PORT Dockerfile指南主体结构 基础镜像信息 1FROM NAME[:TAG] 维护者信息 1LABEL maintainer docker_user&lt;xxx@email.com&gt; 镜像操作指令 12RUN xxxRUN yyy ## 每一条RUN指令镜像添加一层并提交 容器启动时指令 1CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;deamon off;&quot;] 指令参考 配置指令 ARG 定义创建镜像过程使用的变量 FROM 指定所创建镜像的基础镜像 LABEL 为生成的镜像添加元数据标签信息 EXPOSE 声明镜像内服务监听的端口，只起声明作用 ENV 声明环境变量 ENTRYPORT 指定镜像的默认入口命令 VOLUME 创建一个数据挂载点 USER 指定运行容器时的用户名或者UID WORKDIR 配置工作目录 ONBUILD 创建子镜像时指定自动执行的操作指令 STOPSIGNAL 指定退出的信号值 HEALTHCHECK 配置所启动容器如何进行健康检查 SHELL 指定默认shell类型 操作指令 RUN 运行指定命令 CMD 启动容器时指定默认执行的命令 ADD 添加内容到镜像 COPY 复制内容到镜像 使用Dockerfile创建镜像1docker [image] build [OPTIONS] PATH | URL | - 该命令会读取指定路径（包括子目录）下的Dockerfile，并将改路径下所有数据作为上下文发给docker服务端，服务端在校验Dockerfile格式通过后，逐条执行其中定义的指令，碰到ADD，COPY，RUN指令生成一层新的镜像，最终创建成功返回镜像ID。 上下文文件过大，会延缓创建过程，非必须文件不要放到上下文路径下，如果使用非上下文路径下的Dockerfile可以使用-f来指定路径，也可以通过.dockerignore文件来指定忽略的文件，支持通配符 * 表示任意多个字符 ? 代表单个字符 ! 表示不匹配 命令参考Docker操作获取镜像1docker [image] pull NAME[:TAG] 查看镜像信息1docker images 或者 docker image ls 搜索镜像1docker search [option] keyword 删除镜像1docker rmi NAME 或者 docker image rm NAME 创建镜像基于已有容器创建1docker [container] commit [OPTIONS] CONTAINER [REPOSITORY:[:TAG]] 基于本地模板导入1docker [image] import [OPTIONS] file|URL|-[REPOSITORY[:TAG]] 基于Dockerfile 创建12345FROM REPOSITORY:TAGLABEL version=&quot;1.0&quot; maintainer=&quot;xxx&quot;RUN xxxx 存储和导入存储1docker [image] save -o xxx REPOSITORY:TAG 导入1docker load -i xxx 上传镜像1docker [image] push NAME[:TAG] | [REPOSITORY[:RETISTRY_PORT]NAME[:TAG] 容器操作创建容器1docker [container] create [OPTIONS] NAME[:TAG] 创建后启动1docker [container] start [OPTIONS] NAME[:TAG] 创建并启动1docker [container] run [OPTIONS] NAME[:TAG] 相当于先执行docker create ，再执行docker start 常见错误 125 Docker daemon 执行出错，比如指定了不支持的docker命令参数 126 所指定命令无法执行，例如权限出错 127 容器内命令无法找到 常用参数 -i 让容器的标准输入保持打开 -t 分配一个伪终端 -d 守护状态运行 等待退出并打印返回结果1docker [container] wait CONTAINER [CONTAINER...] 查看容器输出1docker [container] logs NAME[:TAG] 暂停/恢复容器1docker [container] pause/unpause CONTAINER [CONTAINER] 停止容器123docker [container] stop [-t|--time[=10]] CONTAINER [CONTAINER...]docker [container] kill CONTAINER [CONTAINER...] ## 强行停止docker [container] prune ## 清理停止状态的容器 进入容器attach命令1docker [container] attach [--detach-keys[=[]]] [--no-stdin] [--sig-proxy[=true]] CONTAINER 多个窗口同时attach的时候，多个窗口会同步显示，一个阻塞其他的也无法操作 exec命令1docker [container] exec [-d|--detach] [--detach-keys[=[]]] [-i|--interactive] [--privileged] [-t|--tty] [-u|--user[=USER]] CONTAINER COMMAND [ARGS] 删除容器1docker [container] rm [-f|--force] [-l|--link] [-v|--volumes] CONTAINER [CONTAINER...] 只能删除已经处于终止或者退出状态的容器，并不能删除处于运行状态的容器，-f会先发SIGKILL给容器终止应用然后删除。 导入和导出1docker [container] export [-o|--output[=&quot;xx.tar&quot;]] CONTAINER 1docker [container] import [-c|--change[=[]]] [-m|--message[=MESSAGE]] file|URL|-[REPOSITORY[:TAG]] 查看容器查看容器详情1docker [container] inspect [OPTIONS] CONTAINER [CONTAINER...] 查看容器内进程1docker [container] top [OPTIONS] CONTAINER [CONTAINER...] 其他命令查看命令帮助12docker container helpdocker help 复制文件1docker [container] cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- 查看容器变更1docker [container] diff CONTAINER 查看端口映射1docker [container] port CONTAINER [PRIVATE_PORT[/PORT]] 更新配置1docker [container] update [OPTIONS] CONTAINER [CONTAINER...] 集群运维管理容器编排调度业界的一些组合 Swarm+Compose - DockerKubernetes - GoogleFleet - CentOSMarathon+Mesos - ApacheRancherNomadDC/OSDocker集群管理docker-compose 容器编排 dockder-compose -f docker-compose.yml 指定配置文件 docker-compose config 检查docker-compose.yml的语法问题 也可以输出内容 docker-compose -p PREFIX up 指定启动是的服务前缀 docker-compose build MIRROR_NAME 构建镜像 docker-compose bundle 生成.dab包，给docker deploy来部署 docker-compose create 创建服务容器 docker-compose down 清理项目,停止容器并删除包括容器、网络、数据卷等内容(跳过正在使用的)，对应up docker-compose events 查看配置相关的服务的事件 docker-compose exec 进入服务 docker-compose kill kill服务 docker-compose logs 查看服务容器日志 docker-compose pause 暂停服务容器 docker-compose port 查看服务容器端口状态 docker-compose ps 查看容器列表 docker-compose images 查看服务镜像列表 docker-compose pull 拉取项目镜像 docker-compose push 推送项目镜像 docker-compose restart 重启服务容器 docker-compose rm 删除项目容器 docker-compose run 执行一次命令 docker-compose scale SERVICE_NAME=NUM 设置服务容器数量 docker-compose start 启动服务容器 docker-compose stop 停止容器服务 docker-compose top 查看容器服务状态 docker-compose unpause 取消暂停状态 docker-compose up 启动项目，包括构建，创建(重新创建)、启动和链接服务容器 compose 配置文件Compose的配置文件是一个YML格式的文件，它定义了包括服务（容器）、网络、数据卷在内的一系列项目组件，默认路径是./docker-compose.yml。 使用配置文件定义的服务在启动时就跟使用Docker Client的docker run一样，同样的配置文件重定义的网络、数据卷也相当于Docker Client中使用docker network create和dockder volume create一样。实际上，Compose并不会真正操作容器，它只适合解析配置文件的定义，然后发送给Docker Client。 Compose 配置文件中定义的每个服务都必须通过image标签指定镜像或build标签来执行构建(上下文中存在Dockerfile)，Dockerfile中定义的变量可以在docker-compose.yml文件中使用，不必在docker-compose.yml文件中重新定义。 文件语法version1version &quot;VERSION&quot; services如果同时指定build和image，会先执行构建，然后命名为image指定的名字 image 指定镜像名称或者镜像ID build 可以基于Dockerfile，构建需要的镜像 直接指定Dockerfile的相对或者绝对路径 context 指定上下文根目录 dockerfile 指定Dockerfile的名称 cache_from 指定构建缓存 labels cap_add cap_drop command 可以覆盖容器启动后默认执行的命令，可以直接写，也可以写成数组的形式 configs 设置config文件，在集群部署时可以方便调度配置文件 source Docker中存在的配置的名称 target 容器内部的目标路径 gid/uid 指定配置文件存放时的用户归属 mode 配置文件的权限 cgroup_parent 为容器指定一个可选的父cgroup container_name 默认容器名称格式为 deploy 仅在使用docker stack部署到集群是生效，docker-compose up和docker-compose run等命令无效 mode global和 replicated(默认)二选一 replicas 数量 update_config 配置更新策略 parallelism 每次更新的容器数量 delay 更新一组容器时等待的时间 failure_action 如果更新失败后续操作,continue或者pause(默认) monitor每个任务更新失败后监视的时间间隔(ns|us|s|m|h)默认为0 max_failure_ratio 允许更新过程中更新失败的最大容器数量 restart_policy重启策略 condition 可选值有 none,on-failure,any（默认） delay 每次尝试重启要等待多时时间，默认为0 max_attempts 尝试次数，默认永不放弃 window 重启后等待多时时间才能确定启动成功,默认立即 resources 配置资源约束 limits reservations cpu_shares cpu_quota cpuset mem_limit memswap_limit mem_swappiness args 指定构建过程中的环境变量，可以使用冒号或者等号分隔，可以省略来允许空值 devices设备映射列表 depends_on 规定服务的前后依赖顺序 dns 指定dns配置 dns_search 自定义搜索域 tmpfs 挂载临时目录到容器 entrypoint 定义接入点，覆盖Dockerfile中的定义 env_file .env文件设置的Compose的变量，对宿主机的Compose而言，不会用在构建中 environment 设置镜像变量，可以将变量保存到镜像中，启动的容器都会包含这些变量设置，与Dockerfile的ENV一样 expose 用于暴露端口,与Dockerfile中的EXPOSE一样 external_links 为了使Compose能够连接这些不在docker-compose.yml中定义的容器 extra_hosts 添加主机名的标签，往/etc/hosts中添加一些记录 healthcheck 检查容器状态的命令 test 命令 interval timeout retries labels 向容器添加元数据，与Dockerfile中的LABEL命令类似 links 连接到其他服务的容器中 logging 配置日志服务 driver options network_mode 指定服务或者容器的网络 networks 也可以设置不同网络及相关映射，用于服务升级 pid设置PID模式，跟主机系统共享进程命名空间 ports 映射端口的标签，使用HOST:CONTAINER格式时，端口小于60可能会报错，YAML将会解析xx:yy为60进制 secrets 每个服务配置独立的secrets security_opt 为每个容器覆盖默认的标签，管理全部服务的标签 stop_signal 设置另一个信号来停止容器，默认情况下使用SIGTERM来停止容器 volumes 挂载一个目录或者一个已存在的数据卷容器，可以直接使用 volumes_from 从其他容器或者服务挂载数据卷 extends 可以扩展另一个服务，扩展内容来自当前文件，也可以来自其他文件 file service 123456version &quot;VERSION&quot;services SERVICE_NAME image:IMAGE_NAMEnetworks swarm 集群管理 可以把多个docker主机组成的系统转换为单一的虚拟docker主机，使得容器可以组成跨主机的子网网络 docker 1.23版本之后自带的官方支持的集群管理工具，支持 swarm mode 集群管理模式 docker swarm模式不是指docker swarm命令，docker swarm模式包含了 docker node、docker service、docker stack、docker deploy、docker network等命令在内的一整套完整的集群部署管理体系，是融与docker中的集群管理方案 docker swarm 命令 docker swarm init 初始化swarm集群 docker swarm join 加入一个集群，包括普通节点和管理节点 docker swarm join-token 管理加入集群 的口令(tokens) docker swarm leave 离开当前集群 docker swarm unlock 解锁集群 docker swarm unlock-key 管理解锁集群的密钥 docker swarm update 更新集群 docker node 命令 docker node demote 将一个或者多个节点降级为普通节点 docker node inspect 显示节点的详细信息 docker node ls 查看集群的所有弱点 docker node promote 将普通节点提升为管理节点 docker node ps 显示一个或多个节点的正在运行的任务列Shell, 默认为当前节点 docker node rm 移除一个或者多个节点 docker node update 更新节点 docker stack 命令 docker stack deploy 部署一个新的Docker栈或更新现有的Docker栈 docker stack ls 显示所有的Docker栈 docker stack ps 显示指定栈的任务 docker stack rm 删除指定的Docker栈 docker stach service 显示指定栈的服务列Shell docker-machine 集群网络建立跨主机网络 docker-machine create 创建虚拟机 docker-machine env 查看虚拟机的环境变量信息 docker-machine ls 查看虚拟机列表 docker-machine ssh 操作虚拟机 dockek-machine ssh MANAGER_NAME docker swarm init 初始化集群 docker-machine ssh MANAGER_NAME docker node ls 查看集群管理节点相关的节点 docker-machine ssh WORKERNAME docker swarm join 将worker加入集群 docker-machine ssh MANAGER_NAME docker swarm join-token 获取manager的集群token 在跨主机网络上部署应用 docker-machine ssh MANAGER_NAME docker pull manager的集群节点获取镜像 docker service create 创建服务使用的跨主机网络 docker service ls 查看服务状态 docker service ps 查看服务详情 docker-machine ssh MANAGER_NAME docker ps -a 到节点上查看服务状态 docker-machine ssh NODE_NAME docker exec -i 进入机器，可以互ping 查看联通状态 dockder-machine ssh NODE_NAME ping 集群的ping Kubernetes与Docker集群管理的一套类似，Kubernetes是一个用于容器集群的自动化部署、扩容以及运维的开源平台，是Google内部Borg集群管理平台的开源版本。 比起前面的组合，部署更加方便，在微服务管理上更加出色，市场份额占比增长很快。Kubernetes基于容器的应用部署和维护，可靠的高可用机器可用机制使得服务滚动升级不再艰难，集成负载均衡和服务发现功能，拥有跨机器甚至跨地区的集群调度能力，自动根据用户期望伸缩服务于和规模，兼容有、无状态服务，支持Volume等，通过插件机制保证扩展性。 使用Kubernetes可以快速高效地响应客户需求，快速并且无意外的部署应用，并且可以动态对应用进行扩容，无缝的升级应用。 基本概念资源Node，Pod， 各种Controller，Service 等都可以看做一种”资源对象”，而这些资源都可以通过Kubernetes提供的kubectl命令行工具执行管理操作，etcd会记录并保持这些资源的状态。Kubernetes通过与etcd的记录比对，当实际的服务状态与期望状态不符合时，会自动调度资源去实现期望的状态。 调度中心：MasterMaster就是管理节点，是集群控制中心，每个Kubernetes集群里都至少需要有一个Master节点来负责集群的管理和控制，Kubernetes几乎所有的控制命令都是发给Master的。Master节点作为集群的大脑，通常都位于一个高性能服务中，以保证集群运行正常。 工作节点：Node在Kubernetes集群中，Node作为一种资源，它表示所有在集群中的机器，包括Master也是Node中的一员（如果Master运行服务）。Node节点并不局限于物理主机，所有部署了Kubernetes agent的环境都可以称为节点（例如虚拟机）。Node节点是集群中的工作和负载节点，每个Node都会被Master分配一些工作和负载，当某个Node宕机时，其工作会被Master自动转移到其他节点上去。 Node节点可以动态添加到Kubernetes集群中，当Kubernetes在Node节点配置完成并启动时，Node节点中的kubelet(agent程序)便会想Master注册。当Node被Master认证通过时，Node节点的kubelet进程就会定时地向Master节点发送自身的信息（例如操作系统，Docker版本，机器的CPU和内存情况）以及哪些Pod在运行等。这样Master就可以获知每个Node的资源使用情况，并根据用户的期望高效地实现资源调度。 当某个Node超过设定时间没有发送信息给Master时，Master便把该Node的状态标记为不可用（Not Ready）,然后Master开启工作负载转义流程，把失联Node节点的工作交给其他Node节点，这是一个完全自动的流程。 相关命令： kubectl get node 获取节点列表信息 kubectl describe node NODE_NAME 查看节点详细信息 最小调度单位：PodPod是Kubernetes里面抽象出来的一个概念，他是Kubernetes的最小调度单位，每个Pod都有一个独立的IP（不推荐用IP去访问），并至少由一个容器构成，同一个Pod中的容器会自动分配到同一个物理机或者虚拟机上，一个Pod内的容器共享Pod的Volumes 、网络、端口等资源（联合命名空间包括PID、网络、IPC、UTS等）。 同一个Pod中的容器可以自由访问，共享内存，一般情况下，我们把有”亲密关系”的容器放到一个Pod中，使得他们可以通过localhost互相访问，例如在一个PHP服务器中，前端使用nginx作为Web服务，后端使用php-fpm执行任务，那么将这两个容器部署在一个Pod内就非常合理了。 Kubernetes的Pod和Docker Container区别很大，Pod里包含多个Container，主要考虑两方面，一方面是自身解耦和Docker解耦，另一方面通过Pod打包多个Container使之共享同一个生命周期，有利于多个服务有强依赖的场景。 资源标签：LabelLabel是附加在Kubernetes资源对象上的键值对（由key/value组成），以传达使用者所定义的可识别属性。他可以在创建的时候指定，也可以随时修改，一个资源对象上面可以有任意多个Label。 Label可以用来组织和选择某个资源的子集合，Kubernetes最终会索引并且反向索引Label以获得更高效的查询和监视，把他们用到UI或者CLI中进行排序或者分组等。 相关命令： kubectl get nodes --show-labels 获取节点标签 kubectl label node NODE_NAME LABEL=VALUE 新增标签 kubectl label node NODE_NAME LABEL=- 删除标签 kubectl get pods -l environment=production kubectl get pods -l &#39;environment in (production)&#39; 弹性伸缩：RC与RSReplication Controller简称RC，用来确保同一时间内存在指定数量的副本Pod（Pod Replicas）在运行中。RC允许用户调整（也成为scaling）副本数量，RC可以再机器故障或其他原因导致部分Pod关闭时重新创建指定数量的Pod副本（异常多出来的Pod也会自动回收）。典型应用场景包括确保健康Pod的数量，弹性伸缩，滚动升级以及应用多版本发布跟踪等。 Replica Set简称RS，是新版本的RC，本质是一样的，区别在于ReplicaSet支持集合式的选择器，RC仅支持等式。 部署对象：DevelopmentDeployment和ReplicaSet用来替代以前的Replication Controller，以实现更高效的Pod管理流程。可以简单理解为以前的RC分为现在的两个资源Deployment和RS，其中Development可以创建Pod和ReplicaSet，而ReplicaSet知负责管理Pod副本数量不再参与到Pod整个生命周期过程中。 自动扩容案例 kubectl autoscale deployment CONFIG_NAME --min=MIN --max=MAX --cpu-percent=80 水平扩展：HPAHPA全称为Horizontal Pod Autoscaling即Pod的水平自动扩展，他可以根据当前系统的负载来自动水平扩容，如果系统负载超过预定值，就开始增加Pod的个数，如果低于某个值，就自动减少Pod的个数。 HPA根据CPU使用率或者应用自定义metrics自动扩展Pod数量，使用Heapster去收集CPU的使用情况。 kubectl autoscale (-f FILENAME | TYPE NAME |TYPE/NAME) [--min-MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags] [options] 服务对象：ServiceService是Kubernetes中最核心的资源对象之一，我们前面所说的Pod、RC、RS、Deployment、Label等都是为Service服务的，例如Pod副本实际上是通过Label选择器来实现与Service对接的——作为Service负载均衡的后端，而RC/RS的作用实际上是保证Service的服务能力和服务质量始终处于预期的标准。Service作为Kubernetes里面抽象出来的一层，它定义了由多个Pods组成的逻辑组，Service可以管理组内的Pod。 Service有三大作用：对外暴露流量，做负载均衡，服务发现。 数据卷资源：Volume用在Kubernetes中持久化数据，一个Kubernetes Volume拥有明确的生命周期，与所在的Pod的生命周期相同。Volume独立于任何容器，只与Pod有关，所以数据卷在Pod或者容器重启过程中还会保留。 Kubernetes Volume支持多种类型，任何容器都可以使用多个Kubernetes Volume。数据卷是文件目录，不是所有的数据卷都是持久化的，emptyDir,secret,gitRepo等随着Pod的消失而消失。 数据持久化：Persistent VolumePersistent Volume和Persistent Volume Claim是Kubernetes提供的两种API资源，拥有抽象存储细节。 PV只是网络存储，不与Pod共享生命周期，而是独立于Pod之外；PVC是用户存储的请求，他类似于Pod，Pod消耗节点资源，而PVC消费PV资源，例如Pod可以向Node请求特定级别的资源（CPU和内存），而PVC可以向PV请求特定的大小和访问模式。 命名空间：NamespaceNamespace是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目或用户组。常见的Pods、Services、RC和Development等都是属于某个Namespace的（默认是default），但Node和Persistent Volume等资源不属于任何Namespace。 在一个Kubernetes集群中可以用Namespace创建多个“虚拟集群”，这些Namespace之间可以完全隔离。因为Namespace可以提供独立的命名空间，因此可以实现部分的环境隔离。当你的项目和人员众多的时候可以考虑根据项目属性划分不同的Namespace比如（开发、测试、生产）。 相关命令： kubectl get namespaces kubectl create namespace NAMESPACE_NAME 注释：AnnotationAnnotation使用键值对存储元数据，与Label相似，但没有Label那么严格的命名规则。 Annotation主要用于信息检索、标记等，给人看的内容，可以灵活填写，像构建信息，版本信息，Docker镜像信息，日志存储位置等可能对管理有帮助的内容都可以写进去，以便管理人员后续管理时能够理解整个资源的用途和其他相关信息。 部署方式Minikube 意见部署单机版Minikube使用操作系统中的虚拟机技术，在本地简历一个虚拟机集群，模拟集群环境，整个过程一键部署，不需要了解部署细节，适合入门学习或者体验Kubernetes的用户。 Kubeadm 自动化部署版本如果已经使用Minikube安装了Kubernetes，那么需要删除$HOME/.kube目录 手动部署二进制版本命令参考kubectl [子命令] [资源类型] [资源名称] [选项] 常见资源类型缩写表 service =&gt;svc serviceaccounts =&gt; sa resourcequotas =&gt; quota replicationcontrollers =&gt; rc replicasets =&gt; rs podsecuritypolicies =&gt; psp pods =&gt; po poddisruptionbudgets =&gt; pdb persistentvolumes =&gt; pv persistentvolumeclains =&gt; pvc nodes =&gt; no networkpolicies =&gt; netpol namespace =&gt; ns limitranges =&gt; limits ingresses =&gt; ing horizontalpodautoscalers =&gt; hpa events =&gt; ev endpoints =&gt; ep deployments =&gt; deploy daemonsets =&gt; ds configmaps =&gt; cm componentstatuses =&gt; cs certificatesigningrequests =&gt; csr 基本命令create通过文件名或控制台输入创建资源 clusterrole 创建一个新的集群角色 clusterrolebinding 为特定的集群角色创建集群角色绑定 configmap 从本地文件、目录或者字符值创建一个configmap，可以用来保存键值对的配置数据 deployment 创建具有指定名称的deployment namespace 创建具有指定名称的namespace poddisruptionbudget 创建具有指定名称的poddisruptionbudget quota 创建具有指定名称的quota （资源配额） role 使用单一规则创建角色 rolebinding 为特定角色或集群角色创建一个角色绑定 secret 使用指定的子命令创建一个secret,子命令有docker-retistry generic和tls三个 service 使用指定的子命令创建一个服务，有四个子命令，clusterip，externalname，loadbalancer，nodeport serviceaccount 创建具有指定名称的服务账户 expose将一个资源（RC，Service，Deployment，Pod）作为新的Kubernetes服务。 expose按名称查找deployment，service，RC，RS或Pod，并将该资源的选择器用作指定端口上新的服务的选择器。deployment或RS只有当选择器可转换为服务支持的选择器时，即当选择器仅包含matchLabels组件时，才会暴露服务。 run创建并允许特定镜像，通过deployment或job来管理创建的容器。 set配置应用资源，这个命令可以更改现有的应用程序资源。 image 更新现有容器镜像的资源。 resources 为Pod模板指定计算资源请求(包括CPU和内存)，如果一个Pod被成功部署，这个命令将保证Pod请求的资源数量 selector 在资源对象上设置选择器。注意如果资源在调用set selector之前已经有选择器，则新的选择器将覆盖旧的选择器。 subject 在RoleBinding/ClusterRoleBinding中更新user，group或ServiceAccount get显示一个或者多个资源，默认隐藏已停止的资源，无论运行成功还是启动失败，只要状态不是活动的都不显示。可以通过--show-all来显示完整结果 。 explain资源记录，获取资源及其字段的文档 edit在服务器上使用默认编辑器编辑资源，使用这个命令可以编辑多个对象，然后一次性地应用更改。 delete通过指定文件名、stdin、资源名称、资源标签选择器来删除资源。 部署命令rollout管理资源的部署，有效的资源类型包括:deployments,daemonsets history 查看以前部署的版本和配置 pause 将指定的资源标记为已暂停，已暂停资源将不会由控制器调度。目前支持deployment resume 恢复暂停资源，暂停的资源将不会被控制器调度，通过恢复资源，我们允许它再次调度。 status 显示部署的状态，默认情况下，“部署状态”将监视最新部署的状态，知道完成为止。 undo 回滚先前的部署 rolling-update执行指定的RC进行滚动更新，使用新的RC控制器替换旧的RC控制器，逐步使用新的Pod Template替换旧的Pod。新旧RC必须在同一个Namespace中，并覆盖其选择器至少一个标签（通常是版本号），以便选择器可以区分新旧版本RC。 scale为Deployment，RS，RC或Job设置新的规模。scale允许用户为伸缩操作指定一个或多个前提条件。如果制定了--current-replicas或--resource-version则在尝试伸缩规模之前进行验证，并确保将 规模伸缩命令发送到服务器时前提条件不变。 autoscale创建自动规模伸缩器，可自动调整并设置在Kubernetes集群中运行的Pod数量，通过名称查找Development,ReplicaSet,ReplicationController,并创建一个使用指定资源状态作为参考的自动规模伸缩器，autoscale可以根据需要自动增加或者减少系统中部署的Pod数量 集群管理命令certificate修改证书资源 approve 批准证书签名请求，kubectl certificate 准许管理人员提交的证书签名请求(CSR)，此操作告诉证书签名控制器向请求者颁发证书，其中包含CSR中请求的属性。 deny 拒绝签名请求，kubectl certificate拒绝管理人员发送的证书签名请求（CSR），此操作会告知证书签名控制器不想请求者颁发证书。 cluster-info使用标签显示Master服务器和Service的地址，如果要进一步调试和诊断集群问题，可以使用kubectl cluster-info dump命令 top显示资源（CPU、内存、存储）的使用情况。top命令用于查看节点或Pod的资源消耗，此命令需要Heapster正确配置并在服务器上正常工作。 node 显示节点的资源信息 pod 显示指定pod的信息 cordon标记节点为不可调度，不可调度的节点将从集群的调度列表中删除，不会调度任何资源到该节点中，一般用于节点维护升级服务。标记为不可调度并不会删除节点上的Pod，但是失联的Pod 也无法与集群通信。 uncordon标记节点为可调度。 draindrain标记节点，表示准备维护。该命令会删除该节点上的所有Pod通常用于节点维护。 taint当节点被标记为taint(变质)时，除非Pod被标识为可以忍受污染(toleration)，否则不会有任何Pod呗调度到该节点。之所以把taint标记到节点而不是标记到Pod，是因为在这种情况下绝大多数的Pod都 不应该部署到taint节点上。 故障排除和调试命令describe显示特定资源或资源组的详细信息，与其他API调用合并在一起，以显示指定资源或资源组的详细描述。 kubectl describe TYPE NAME_PREFIX logs打印指定资源中容器的日志，如果Pod只有一个容器，容器名称是可选的。 attach附加到已经在现在容器中运行的进程，从指定的Pod中获取输出，默认依附到第一个容器。 exec在容器中执行命令。 port-forward将一个或多个本地端口转发到Pod。比如本地监听5000和6000端口，并把数据转发到Pod的5000和6000端口 kubectl port-forward NAME 5000 6000 proxy在localhost和Kubernetes API Server之间创建代理服务器或应用层网关。proxy允许通过指定的HTTP路径提供静态内容。所有传入数据通过一个端口进入，并被转发到远程Kubernetes API服务端口（除了与静态内容路径匹配的路径）中。 cp将文件和目录拷贝到容器中，cp命令要求容器中存在tar命令，如果tar不存在，kubectl cp将执行失败。 auth检查授权，can-i 子命令用户检查用户是否允许执行某些操作。 高级命令apply通过文件名或stdin将apply配置到资源中，文件可以使用JSON和YAML格式。资源名称必须制定，如果资源不存在，将创建资源。 patch使用补丁更新资源的字段，文件可以是JSON和YAML格式 replace用指定的文件或stdin替换资源，如果替换现有资源，则必须提供完整的资源定义，可以通过kubectl get TYPE NAME -o yaml获得 convert在不同API版本中转换配置文件，YAML和JSON格式都可以，参数可以是文件名，目录或URL。 设置命令label更新资源上的标签，标签规则是以字母或数字开头，可以包含字母、数字、连字符、点和下划线，最多为63个字符。 annotate更新一个或多个资源上的注释 completion输出指定shell的shell完整代码，必须对shell代码进行评估，以提供kubectl命令的交互 其他命令api-versions在服务器上输出支持的API版本 config使用kubectl config set current-context my-context之类的子命令修改kubeconfig文件 set-cluster 在kubeconfig文件中设置一个集群项 set-context 在kubeconfig配置文件中上设置一个环境项 set-credentials 在kubeconfig配置文件中上设置一个用户项 set 在kubeconfig配置文件中上设置一个单独的值 unset 在kubeconfig配置文件中上清除一个单独的值 use-context 使用kubeconfig中一个环境项作为当前配置 view 显示合并后的kubeconfig设置，或者一个指定的kubeconfig配置文件 help查看所有命令的帮助 options输出某个命令的所有选项 plugin运行一个命令行插件，插件命令不属于kubectl子命令，可以由第三方提供 version打印输出当前上下文环境中的客户端和服务端版本信息","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"自动化","slug":"Web开发/前端开发/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://rawbin-.github.io/tags/%E9%83%A8%E7%BD%B2/"},{"name":"自动化","slug":"自动化","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"运维","slug":"运维","permalink":"http://rawbin-.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"容器化","slug":"容器化","permalink":"http://rawbin-.github.io/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"可伸缩","slug":"可伸缩","permalink":"http://rawbin-.github.io/tags/%E5%8F%AF%E4%BC%B8%E7%BC%A9/"}]},{"title":"docker+kubenetes开发上线运维","slug":"dev-env/2018-09-20-docker-k8s-through","date":"2021-12-31T02:37:59.944Z","updated":"2021-12-31T02:37:59.944Z","comments":true,"path":"dev-env/2018-09-20-docker-k8s-through/","link":"","permalink":"http://rawbin-.github.io/dev-env/2018-09-20-docker-k8s-through/","excerpt":"","text":"概念理解两大生态Docker 将精力专注在应用开发上，包揽环境部署问题(Debug you app, not your environment) 将环境部署定义在稳定的自动化的基础上，从过程上降低运维成本 相关概念 完整的概念参考Docker 本身代指Docker 这个思想，这个项目，相关的产品，工具、社区等等，不同语境代指不一样。 Docker 是一种可以提供操作系统级别虚拟化（也称作容器）的软件技术。 Repository （仓库）存放和管理镜像的地方，比如DockerHub Image （镜像）是一个配置和数据的集合，是容器的初始状态 Container（容器）容器是镜像的实例，是可移植的动态调度单元 Dockerfile一个用来生成镜像的配置文件 Kubernetes 已经是解决Docker编排需求的行业标准，超过了包括Docker官方的Docker Compose，用于管理容器化的工作负载和服务 高可用、弹性扩容、强大的生态系统，从架构上降低运维成本 相关概念 完整的概念参考Pod是管理容器的，Service来管理Pods，Pod上的标签Label作为Pod和Service的关联，解决服务扩容和升级的问题只需要目标Pod上创建一个Replication Controller(RC) Container（容器）容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖 Pod（容器组）Pod 是 Kubernetes 的原子对象， 表示集群上一组正在运行的容器，Pod与Pod之间可以直接通信，包含 Pause容器 其他业务容器 多个业务容器共享Pause容器的IP，共享Pause容器挂载的Volume卷，简化了通信问题，也解决了文件共享问题 Service（服务）将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法，是服务的入口，通过Label Selector跟 Pod副本机器的无缝对接 Node（工作节点）是执行工作的机器，是集群中的工作负载节点，它可以是一个虚拟机或者物理机器，每个节点都包含用于运行Pods的必要服务，并由主控组件管理，最小的管理单元是Pod，除Master外的集群其他机器的统称，包含的服务 kubelt 负责Pod的管理，与Master节点的通信，实现集群管理 kube-proxy 实现Kubernetes Service的通信和负载均衡 ·Container Runtime，docker或其他容器运行时，容器引擎，负责本机容器的管理 Master(管理节点)Kubernetes集群控制管理节点,负责整个集群的管理和控制，所有的控制命令都会发送到这里，包含的服务 kube-apiserver 用于暴露Kubernetes API，提供HTTP Rest接口的管理服务，是集群资源操作的唯一入口，任何资源请求或者调用都是通过kube-apiserver 提供的接口进行的 kube-controller-manager Kubernetes 集群中所有资源对象的自动化控制中心，他们是集群中处理常规任务的后台线程，逻辑上每个控制器都是一个单独的进程，为了降低复杂度，他们都被编译成单个二进制文件并在单个进程中运行 Node Controller 节点控制器，检查云端节点，以确保节点在停止响应之后在云中是否删除 Route Controller 路由个控制器，用于在底层云基础架构中设置路由 Service Controller 服务控制器，用于创建、更新和删除云提供商的负载均衡器 Volume Controller 卷控制器，用于创建、附加和装载卷，以及与云提供商交互以协调卷 cloud-controller-manager 云控制器管理器 kube-scheduler 负责负载的调度（Pod调度）进程，为Pod选择Node以供运行 etcd-server 是Kubernetes高可用的一致性键值存储系统，也是默认的存储系统，用于存储所有的集群数据，使用时需要为etcd提供数据备份计划 Volume（卷）定义在Pod上，被一个Pod中的多个容器挂载到具体的文件目录下，当容器终止或者重启时，Volume中的数据也不会丢失，是Pod中能够呗多个容器访问的共享目录。 Label（标签）和 Label Selector（标签选择器）标签是附加到对象上的键值对，随后可以对这个对象用标签选择器进项查询和筛选拥有特定标签的对象，是Kubernetes实现的简单通用的对象查询机制。 Replication Controller（RC 复制控制器）保障Pod的副本数量在任意时刻都符合预期值，多了就杀掉，少了就创建。 Replica Set（RS 副本集控制器）是下一单 RC，跟RC的唯一区别是，RS 支持基于集合的Label Selector 而RC只支持基于等式的，RS很少单独使用，主要被Deployment这个更高层次的资源对象所使用，从而形成一整套Pod创建、删除、更新的编排机制。 Deployment（部署控制器）为Pod和RS 提供声明式更新 插件 DNS 支持Kubernetes集群系统中各服务之间的发现和调用 Web UI(Dashboard) 是Kubernetes集群基于Web的通用UI，允许用户管理集群以及管理集群运行中的应用程 Container Resource Monitoring 提供UI监测容器、Pods、服务以及整个集群中的数据，用于检查Kubernetes集群中应用程序的性能 Cluster-level Logging 集群级日志记录和存储，并且提供了搜索/浏览界面。 环境部署开发环境部署 参考macOS安装kubectl使用Homebrew12brew install kubectlkubectl version --client 使用Macports123sudo port selfupdatesudo port install kubectlkubectl version --client 通用命令行安装1234curl -LO &quot;https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl&quot;chmod +x ./kubectlsudo mv ./kubectl /usr/local/bin/kubectlkubectl version --client 安装Minikube 参考检查是否支持虚拟化，不支持需要安装一种1sysctl -a | grep -E --color &#x27;machdep.cpu.features|VMX&#x27; 使用Homebrew1brew install minikube 通用命令行安装123curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64 chmod +x minikubesudo mv minikube /usr/local/bin 启动这个过程要下载较大体积的内容，可能需要爬墙，请泡杯茶或者来杯咖啡 1minikube start 创建新的集群 1minikube start -p testcluster 打开可视化面板 1minikube dashboard 测试环境CentOS环境集群规划 主机名称 操作系统 IP 系统配置 备注 vm-130.8-centos-k8smaster centos-7-x86_64 192.168.130.8 8核32G 作为主节点 vm-130.20-centos-k8snode centos-7-x86_64 192.168.130.20 8核32G 作为工作节点 配置主机名 /etc/hostname12hostnamehostnamectl set-hostname HOSTNAME 配置host /etc/hosts这些内容就是从默认里面拷出来然后改改的得到的就是一个全量 1234567127.0.0.1 HOSTNAME HOSTNAME127.0.0.1 localhost.localdomain localhost127.0.0.1 localhost4.localdomain4 localhost4::1 HOSTNAME HOSTNAME::1 localhost.localdomain localhost::1 localhost6.localdomain6 localhost6 主机配置脚本1234567891011121314151617181920HOSTNAME=&quot;vm-130.8-centos-k8smaster&quot; # 设置hostnamehostnamectl set-hostname $HOSTNAME# 查看hostnamehostnameecho &quot;127.0.0.1 $HOSTNAME $HOSTNAME127.0.0.1 localhost.localdomain localhost127.0.0.1 localhost4.localdomain4 localhost4::1 $HOSTNAME $HOSTNAME::1 localhost.localdomain localhost::1 localhost6.localdomain6 localhost6192.168.130.8 vm-130.8-centos-k8smaster192.168.130.20 vm-130.20-centos-k8snode&quot;&gt; /etc/hosts# 查看结果cat /etc/hosts 配置动态/静态IP /etc/sysconfig/network-scripts/ifcfg-eth0 动态IP 12345678BOOTPROTO=dhcpDEVICE=eth0HWADDR=52:54:00:22:47:30NM_CONTROLLED=noONBOOT=yesPERSISTENT_DHCLIENT=yesTYPE=EthernetUSERCTL=no 静态IP 12345678910111213141516 BOOTPROTO=static DEVICE=eth0HWADDR=52:54:00:22:47:30 NM_CONTROLLED=no ONBOOT=yes TYPE=Ethernet IPADDR= PREFIX=24 NETMASK= NETWORK= GATEWAY= BROADCAST= DEFROUTE=yes ONBOOT=yes USERCTL=yes IPV4_FAILURE_FATAL=yes 配置网络 /etc/sysconfig/network12NETWORKING=yesHOSTNAME= 配置DNS /etc/resolv.conf12nameserver 114.114.114.114nameserver 8.8.8.8 重启和查看网络12systemctl restart network.servicesystemctl status network.service 安装Docker分步安装 (如果有)删除旧版本 12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 添加必要组件 12sudo yum updatesudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加docker软件源 1sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 更新软件源缓存并安装docker 123sudo yum updatesudo yum install -y docker-cesudo systemctl start docker 脚本安装123curl -fsSL https://get.docker.com -o get-docker.sh## 注意安全 最好检查下sudo sh get-docker.sh 安装kubeadm kubelet kubectl官方的源需要梯子，改成阿里云的 123456789101112131415161718cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-\\$basearchenabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgexclude=kube*EOF# Set SELinux in permissive mode (effectively disabling it)setenforce 0sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/configyum install -y kubelet kubeadm kubectl --disableexcludes=kubernetessystemctl enable kubelet CentOS 7 配置防火墙 12345cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOFsysctl --system 启动kubelet 12systemctl daemon-reloadsystemctl enable kubelet &amp;&amp; systemctl start kubelet 镜像获取 查看需要的镜像列表 1kubeadm config images list 获取镜像 通过国内能够访问的方式来获取，缺点是可能不是最新的包 使用脚本的方式来做 12345678# 下载需要的镜像kubeadm config images list |sed -e &#x27;s/^/docker pull /g&#x27; -e &#x27;s#k8s.gcr.io#docker.io/mirrorgooglecontainers#g&#x27; -e &#x27;s/:/-amd64:/g&#x27; |sh -x # 重命名镜像docker images |grep mirrorgooglecontainers |awk &#x27;&#123;print &quot;docker tag &quot;,$1&quot;:&quot;$2,$1&quot;:&quot;$2&#125;&#x27; |sed -e &#x27;s#mirrorgooglecontainers#k8s.gcr.io#2&#x27; |sh -x # 删除mirrorgooglecontainers镜像docker images |grep mirrorgooglecontainers |awk &#x27;&#123;print &quot;docker rmi &quot;, $1&quot;:&quot;$2&#125;&#x27; |sh -x coredns不在mirrorgooglecontainers 里面，需要单独下载 123docker pull coredns/coredns:1.6.7docker tag coredns/coredns:1.6.7 k8s.gcr.io/coredns:1.6.7docker rmi coredns/coredns:1.6.7 使用配置文件，镜像命名完全一致可用 12345# 生成配置文件kubeadm config print init-defaults | sed -e &#x27;s#k8s.gcr.io#docker.io/mirrorgooglecontainers#g&#x27;&gt; kubeadm.confkubeadm config images list --config kubeadm.confkubeadm config images pull --config kubeadm.confkubeadm init --config kubeadm.conf 查看镜像 1docker images 主节点配置 启动主节点 1kubeadm init 可以使用kubeadm init --dry-run 来查看初始化过程 1kubeadm init --kubernets-version=xxx --aiserver-advertise-address=xxx --Pod-network-cidr=xxxx ==service-cidr=xxx 集群创建成功后，类似于下面的命令需要保存备用 1kubeadm join IP:PORT --token xxx --discovery-token-ca0cert-hash xxx 认证 root 用户 1export KUBECONFIG=/etc/kubernetes/admin.conf 非root用户 123mkdir -p $HOME/.kubecp -i /etc/kubernetes/admin.conf $HOME/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config 安装 flannel网格插件 1kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 检查集群状态 1kubectl get cs 确认相关Pod已经正常运行 1kubectl get Pods -n kube-system -o wide 工作节点配置 使用上面保存备用的命令加入集群 1kubeadm join IP:PORT --token xxx --discovery-token-ca0cert-hash xxx 在主节点上拷贝配置文件到工作节点 1scp /etc/kubernetes/admin.conf IP:/etc/kubernetes/admin.conf 配置kubeconfig文件 12export KUBECONFIG=/etc/kubernetes/admin.con fecho &quot;export KUBECONFIG=/etc/kubernetes/admin.conf&quot; &gt;&gt; ~/.bash_profile 查看集群状态 1kubectl get nodes 安装dashboard 安装 123docker pull mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.1docker tag mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.1 k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml 线上环境 参考测试环境配置 应用配置使用Deployment对象来运行应用程序使用yaml文件来定义Deployment对象。 Deployment配置规范deployment-demo.yaml 1234567891011121314151617181920212223242526272829303132333435363738# API版本对象，可以通过 `kubectl api-versions`命令查看apiVersion: apps/v1 # 资源类型，区分大小写，可通过`kubectl api-resources` 命令查看，这里使用Deploymentkind: Deployment # 标准元数据metadata: # 当前Deployment对象名称，同一个命名空间下必须唯一 name: first-demo-deployment# 部署规范，Deployment控制器会根据此模板调整当前Pod到最终的期望状态spec: # Pod数量，这里指运行5个Pod replicas: 5 # 选择器，定义Deployment控制器如何找到要管理的Pod selector: # 匹配标签 matchLabels: app: first-demo # Pod的模板定义 template: 标准的元数据 metedata: # Pod标签 labels: # 定义Pod标签的键值对 app: first-demo # Pod规范 spec: # 容器列表，Pod中至少有一个容器 containers: # 容器名称 name: first-demo-con # 镜像地址 image: node # 端口列表 ports: # 设置容器端口 containerPort: 80 使用kubectl create创建资源1kubectl create -f deployment-demo.yaml 创建和更新资源可以用 1kubectl apply -f deployment-demo.yaml 检查资源创建状态 1kubectl get Deployment first-demo-deployment 查看副本集状态 1kubectl get ReplicaSets -lapp=first-demo 查看Pod状态 1kubectl get Pods -lapp=first-demo --show-labels 配置自动伸缩和回滚 手动伸缩应用，也可以通过修改配置文件再执行命令的方式来做 1kubectl scale --replicas=3 deployment/first-demo-deployment 自动伸缩 12kubectl autoscale deployment/first-demo-deployment --min=2 --max=10kubectl autoscale deployment/first-demo-deployment --max=5 --cpu-percent=70 ​ 快速运行对象 1kubectl run DEPLOYNAME --image=xxx --env &quot;AA=BB&quot; 更新应用 1kubectl set env deployment/first-demo-deployment AA=BB 回滚应用 12kubectl rollout history deplyment/first-demo-deploymentkubectl rollout status deplyment/first-demo-deployment 服务访问的几种方式通过Service访问应用 通过PodIP访问，PodIP会随着Pod的生死而变动 1kubectl get Pods -lapp=first-demo -o wide # 查Pod状态 通过ClusterIP Service在集群内部访问，Service集群配置文件clusterIPService.yaml 123456789101112131415161718192021222324# api版本信息apiVersion: v1# 资源类型kind: Service# 标准元数据metadata: # 服务名称 name: demo-service# 规范定义spec: # 服务类型，不填默认为ClusterIP type: ClusterIP # 标签选择器 selector: # 标签键值对 app: demo # 端口 ports: # 协议，支持TCP和UDP protocol: TCP # 当前端口 port: 80 # 目标端口 targetPort: 80 123kubectl create -f clusterIPService.yamlkubectl get services demo-service -o widekubectl get endpoints demo-service -o wide 通过NodePort Service在外部访问集群应用NodePort类型的Service允许在每个节点的IP上时候用静态端口公开服务，我们可以在集群之外通过请求IP：Port的方式来访问, nodePortService.yaml 1234567891011121314151617181920212223# api版本信息apiVersion: v1# 资源类型kind: Service# 标准元数据metadata: # 服务名称 name: nodeport-service# 规范定义spec: # 服务类型，不填默认为ClusterIP type: NodePort # 端口列表 ports: # 当前端口 port: 80 # 节点端口，默认端口范围为30000-32767 nodePort: 31001 # 标签选择器 selector: # 标签键值对 app: demo # 端口 12kubectl create -f nodePortService.yamlkubectl get services ndoeport-service 通过LoadBalancer Service在外部访问集群服务使用一个负载均衡的IP，来访问集群服务 12345678910111213141516171819202122232425262728293031323334353637# api版本信息apiVersion: v1# 资源类型kind: Service# 标准元数据metadata: # 服务名称 name: demo-service # 名称空间 namespace:default# 规范定义spec: # 集群IP clusterIP:10.100.2.20 # 负载均衡IP loadBalancerIP:10.100.2.2 # 服务类型，不填默认为ClusterIP type: LoadBalancer # 端口列表 ports: name: tcp-80-80 # 当前端口 port: 80 # 节点端口，默认端口范围为30000-32767 nodePort: 31001 # 协议，支持TCP和UDP protocol: TCP # 当前端口 port: 80 # 目标端口 targetPort: 80 # 标签选择器 selector: # 标签键值对 app: demo k8s-app: demo qcloud-app: demo 使用Ingress负载分发微服务使用Helm简化Kubernetes应用部署运维场景健康状态检查组件、插件健康状态检查1kubectl get componentstatus 或者 1kubectl get cs 部分插件默认基于systemd运行，比如kubelet, Docker等，我们需要使用以下命令确保其处于活动状态 1systemctl status kubelet docker 大部分Kubernetes组件运行在命名空间为kube-system的静态Pod中，我们可以使用一下命令来查看这些Pod的状态 1kubectl get Pods -o wide - n kube-system 组件异常分析 k8s为Master-Slave结构，分为Master组件和节点组件 如果Master组件出问题，就可能导致集群不可访问，Kubernetes API访问出错、各种控制器无法工作等 如果节点组件出问题，就可能会导致该节点异常并且该节点Pod无法正常运行和结束 kube-apiserver 对外暴露了Kubernetes API，如果kube-apiserver出现异常就可能会导致 集群无法访问，无法注册新的节点 资源（Deployment，Service等）无法创建、更新和删除 现有的不依赖Kubernetes API的Pods和Service可以继续正常工作 etcd用于Kubernetes的后端存储，所有集群数据存在这里，如果etcd出现问题可能会导致 kube-apiserver 无法读写集群状态，apiserver无法启动 Kubernetes API访问出错 kubectl操作异常 kubelet无法访问apiserver，仅能继续运行已有的Pod kube-controller-manager和kube-scheduler分别用于控制器管理和Pod的调度，如果出现问题就可能导致： 相关控制器无法工作 资源（Deployment，Service 等 ）无法正常 工作 无法注册新的节点 Pod无法调度，一直处于Pending状态 kubelet是主要的代理节点，如果节点宕机或者kubelet出现异常，可能会导致 该节点上Pod无法正常运行，如果节点关机，那么当前节点上所有Pod都将停止运行 已运行的Pod无法伸缩，也无法正常终止 无法启动新的Pod 节点会标识为不健康状态 副本控制器会在其他节点上启动新的Pod kubelet有可能会删掉当前运行的Pod coredns是k8s的默认的DNS服务器，如果出现问题可能导致 无法注册新的节点 集群网络出现问题 Pod无法解析域名 kube-proxy是每个节点上运行的网络代理，如果出现异常，就可能导致该节点Pod通信异常 节点健康状态检查1kubectl get nodes Pod健康状态检查1kubectl get Pods -o wide Service 健康状态检查1kubectl get svc -o wide 系统相关检查查看日志 查看系统服务日志 1journalctl -u docker 查看并追踪kubelet的日志 1journalctl -u kubelet -f 查看容器日志 1kubectl logs PODNAME 查看资源详情和事件 查看资源详情 1kubectl describe 查看节点详情 1kubectl describe nodes [NODENAME] 查看Pod详情 1kubectl describe Pods PODNAME 查看资源配置 1kubectl get 查看Pod的配置 1kubectl get Pods PODNAME -o yaml 查看所有Pod 1kubectl get Pods -o json 查看服务配置 1kubectl get svc SVCNAME -o yaml 查看部署配置 1kubectl get deployments DEPNAME -o yaml 容器状态检查 进入容器检查 1kubectl exec 使用调试工具kubectl-debug 1kubectl debug 常见问题 镜像源问题 可以使用亚马逊国内源 http://mirror.azure.cn 可以使用中科大镜像源 http://mirror.ustc.edu.cn coredns添加节点长久等待 先查看服务状态 1kubectl get Pods -n kube-system -o wide 查看 容器日志 1kubectl log -f CONTAINERNAME -n kube-system 处理防火墙规则 123456systemctl stop kubeletsystemctl stop dockeriptables --flushiptables -tnat --flushsystemctl start kubeletsystemctl start docker 添加工作节点，提示token过期 12kubeadm token generatekubeadm token create &lt;token&gt; --print-join-command --ttl=0 kubectl 执行命令报错 the connection to the server host:8080 was refused 问题原因是kubectl命令需要使用 kubernetes-admin的身份来运行，在kubeadm init启动集群的步骤就生成了/etc/kubernetes/admin.conf 需要将主节点中的/etc/kuubernetes/admin.conf文件复制到工作节点相同目录下，然后在工作节点配置环境变量，参考工作节点配置 网络组建flannel无法完成初始化 123kubectl get Pods -n kube-system -o widekubectl logs -f NAME -n kube-systemjournactl -u kubelet -f 部分节点无法初始化Pod 查看日志，然后处理flannel网格出现的问题 1234kubeadm resetsystemctl stop kubelet &amp;&amp; systemctl stop docker &amp;&amp; rm -rf /var/lib/cni/ &amp;&amp; rm -rf /var/lib/kubelet/* &amp;&amp; rm -rf /var/lib/etcd &amp;&amp; rm -rf /etc/cni/ &amp;&amp; ifconfig cni0 down &amp;&amp; ifconfig flannel.1 down &amp;&amp; ifconfig docker0 down &amp;&amp; ip link delete cnisystemctl start kubeletsystemctl start docker0 常用内容Shell相关 Shell 脚本调试 1sh -xv script-to-run.sh 系统相关 CentOS查看主机基本硬件信息 查看系统信息 12cat /etc/redhat-releaseuname -a 查看CPU信息 1grep &quot;model name&quot; /proc/cpuinfo 查看内存信息 1grep MemTotal /proc/meminfo 查看硬盘信息 1df -h 安装配置相关 主机名错误（只能包含小写字母，中划线和点） 1could not convert cfg to an internal cfg: nodeRegistration.name: Invalid value: &quot;k8s_master&quot;: a DNS-1123 subdomain must consist of lower case alphanumeric characters, &#x27;-&#x27; or &#x27;.&#x27;, and must start and end with an alphanumeric character (e.g. &#x27;example.com&#x27;, regex used for validation is &#x27;[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*&#x27;) 解决办法 1hostnamectl set-hostname xxx 参考资料 Dockerfile 官方最佳实践 Kubernetes Handbook 熟悉Docker的参考 Kubernetes 配置参考","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"自动化","slug":"Web开发/前端开发/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://rawbin-.github.io/tags/%E9%83%A8%E7%BD%B2/"},{"name":"自动化","slug":"自动化","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"运维","slug":"运维","permalink":"http://rawbin-.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"容器化","slug":"容器化","permalink":"http://rawbin-.github.io/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"可伸缩","slug":"可伸缩","permalink":"http://rawbin-.github.io/tags/%E5%8F%AF%E4%BC%B8%E7%BC%A9/"}]},{"title":"Shell字符串处理","slug":"language/shell/2018-09-22-shell-string","date":"2021-12-31T02:37:59.944Z","updated":"2021-12-31T02:37:59.945Z","comments":true,"path":"language/shell/2018-09-22-shell-string/","link":"","permalink":"http://rawbin-.github.io/language/shell/2018-09-22-shell-string/","excerpt":"","text":"参数替换$&#123;param&#125; 避免参数后面的字符导致的冲突 访问&gt;=10 的位置参数 $&#123;string:position&#125; 从 position的位置开始截取 $&#123;string:position:length&#125; 从position的位置开始截取长度为length的 $&#123;string#substring&#125; 从前往后，截取最短匹配substring的 $&#123;string##substrng&#125; 从前往后，截取最长匹配substring的 $&#123;string%substring&#125; 从后往前，截取最短匹配substring的 $&#123;string%%substrng&#125; 从后往前，截取最长匹配substring的 $&#123;string/substring/replacement&#125; 替换第一个匹配substring的为replacement $&#123;string//substring/replacement&#125; 替换所有匹配substring的为replacement $&#123;string/#substring/replacement&#125; 如果substring能匹配首部，就替换成replacement $&#123;string/%substring/replacement&#125; 如果substring能匹配尾部，就替换成replacement 案例解析12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env bashhello=&quot;this is a hello from code ode&quot;## 变量的长度echo $&#123;#hello&#125;## 从截取从10开始的子串echo $&#123;hello:10&#125;## 从10开始截取长度为5的子串echo $&#123;hello:10:5&#125;## 从前往后截掉最短的*is的匹配echo $&#123;hello#*is&#125;## 从前往后截掉最长的*is的匹配echo $&#123;hello##*is&#125;## 从后往前截掉最短的ode*的匹配echo $&#123;hello%ode*&#125;## 从后往前截掉最长的ode*的匹配echo $&#123;hello%%ode*&#125;## 把第一个is换成areecho $&#123;hello/is/are&#125;## 把所有is换成areecho $&#123;hello//is/are&#125;## 从前往后匹配this的话就替换成THISecho $&#123;hello/#this/THIS&#125;## 从后往前匹配ode的话就替换成ODEecho $&#123;hello/%ode/ODE&#125; 1234567891011121314151617#!/usr/bin/env bash## 处理逗号分隔的字符串## 把内容复制一遍并输出## 把第一个参数中的所有逗号替换成空格，便于后面的循环arg_info=$&#123;1//,/ &#125;result=&quot;&quot;## for arg in $arg_infodoresult=&quot;$result,$arg$arg&quot;done## 去掉第一个逗号并输出echo $&#123;result#?&#125;","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://rawbin-.github.io/tags/Shell/"},{"name":"字符串处理","slug":"字符串处理","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"}]},{"title":"使用nginx实现灰度发布","slug":"dev-env/2018-08-28-abtest-dev","date":"2021-12-31T02:37:59.943Z","updated":"2021-12-31T02:37:59.943Z","comments":true,"path":"dev-env/2018-08-28-abtest-dev/","link":"","permalink":"http://rawbin-.github.io/dev-env/2018-08-28-abtest-dev/","excerpt":"","text":"前言参考资料中已经包含了几种不同的通过nginx实现灰度发布的方式 编程方式 OpenResty nginx+lua nginx默认 Cookie判断 IP 判断 跟上面相关的可以直接参考对应的内容，咱们这里讲另外一个编程方式，nginx+njs的方式，是nginx官方支持的，用js的语法来写的扩展方式。（对大家都友好，哈哈） njs ref简介(简单翻译了下) njs 是用来扩展nginx功能的JavaScript子集，目前支持ES5严格模式以及部分ES6+的特性，特性支持在不断完善中 使用场景 在转发上游之前进行复杂的访问控制或安全检查 调整响应头 进行灵活的异步内容处理或过滤 等等 MacOS 下使用nginx+njs模块MacOS安装nginx+njs brew install nginx 直接安装，这样安装的不具备定制性，纯默认配置 brew install nginx-full 这样安装可以传入配置参数，可以通过brew install nginx-full --help来查看哪些可以添加的配置参数，比如安装调试模式的 nginx 源码编译安装 如果上面两种都满足不了需求，比如当前njs模块还没被参数支持，那就需要源码编译安装咯 先安装mercurial这个代码管理工具（为嘛还不切到git呢） brew install mercurial 安装 mercurial ref 搞一个操作空间并切过去 mkdir nginx-install &amp;&amp; cd nginx-install 拉取 nginx 源码 hg clone http://hg.nginx.org/nginx 拉取 njs 源码 hg clone http://hg.nginx.org/njs 执行nginx和动态模块配置 cd nginx &amp;&amp; ./auto/configure --add-dynamic-module=../njs/nginx/ 安装nginx make &amp;&amp; make install 如果遇到权限问题 sudo mkdir /usr/local/nginx &amp;&amp; sudo chown -R $(whoami) /usr/local/nginx 安装好的nginx 会在 /usr/local/nginx/sbin/nginx 路径下，使用这个路径执行启动即可 配置 nginx+njs 安装好njs模块之后，包含两部分ngx_stream_js_module 和 ngx_http_js_module 两部分，可以根据文档配置，我们这里以ngx_http_js_module为例，配置参考 进入nginx 目录，并建立相关配置文件 语法参考 cd /usr/local/nginx/conf &amp;&amp; mkdir njs-conf 创建 touch njs-conf/main.js njs-conf/divide-by-user.js njs-conf/main.js 内容如下：(注意路径) import divideByUser from &#39;conf/njs-conf/divide-by-user.js&#39; var divideByPolicy = (req) =&gt; &#123; divideByUser(req); &#125; 1234567891011121314151617181920- `njs-conf/divide-by-user.js` 内容如下 [可操作对象参考](http://nginx.org/en/docs/njs/reference.html)- ```js export default (req) =&gt; &#123; req.status = 200; req.headersOut[&#x27;Content-Type&#x27;] = &#x27;text/html;charset=utf-8&#x27;; req.sendHeader(); req.send(&#x27;divide by user\\r\\n&#x27;); req.send(JSON.stringify(req)); req.send(&#x27;\\n\\nrequest object info:\\n\\n&#x27;) for(var i in req)&#123; if(i === &#x27;parent&#x27;)&#123; continue; &#125; req.send(`$&#123;Object.prototype.toString.apply(req[i]).slice(7)&#125;\\b $&#123;i&#125; = $&#123;JSON.stringify(req[i])&#125; \\n\\n`) &#125; req.send(&#x27;\\n\\n&#x27;); req.finish(); &#125; 修改并调整nginx.conf ## 在主配置里面加载动态模块 load_module modules/ngx_http_js_module.so; ## events &#123; ...&#125; ## http &#123;...&#125; ## 在http 中引入 我们的 njs配置 js_include njs-conf/main.js; ## server &#123;...&#125; 重启nginx /usr/local/nginx/sbin/nginx -s reload 如果配置有错误会报错，改掉即可。 语法参考 如果不容易发现错误，可以用njs调试，路径在nginx-install/njs/build/njs 参考 参考资料 A/B测试和灰度发布的关系 nginx灰度发布 web service灰度发布 ABTest及流量切换实现 灰度发布的原理及实现 使用Nginx实现Web应用灰度发布 使用Nginx实现灰度发布 OpenResty搭建高性能服务端","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"灰度发布","slug":"前端开发/Web开发/灰度发布","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/"},{"name":"ABTest","slug":"前端开发/Web开发/灰度发布/ABTest","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/ABTest/"}],"tags":[{"name":"客户端","slug":"客户端","permalink":"http://rawbin-.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"桌面端","slug":"桌面端","permalink":"http://rawbin-.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF/"},{"name":"灰度发布","slug":"灰度发布","permalink":"http://rawbin-.github.io/tags/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/"},{"name":"ABTest","slug":"ABTest","permalink":"http://rawbin-.github.io/tags/ABTest/"}]},{"title":"Electron客户端缓存和离线包探究","slug":"cross-platform/electron/2018-07-10-electron-cache","date":"2021-12-31T02:37:59.943Z","updated":"2021-12-31T02:37:59.943Z","comments":true,"path":"cross-platform/electron/2018-07-10-electron-cache/","link":"","permalink":"http://rawbin-.github.io/cross-platform/electron/2018-07-10-electron-cache/","excerpt":"","text":"asar包加解密参考资料 如何使用electron-builder及electron-updater给项目配置自动更新 使用 electron-builder 及 electron-updater 给项目配置自动更新 Electron应用使用electron-builder配合electron-updater实现自动更新 我是如何实现electron的在线升级热更新功能的？ Electron实现在线升级 热更新 遇到的问题 electron 热更新 Electron实现在线升级及功能的热更新 Electron 与 Vue 的性能优化","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"Electron","slug":"前端开发/Web开发/JavaScript/Electron","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/Electron/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"客户端","slug":"客户端","permalink":"http://rawbin-.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"桌面端","slug":"桌面端","permalink":"http://rawbin-.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF/"},{"name":"Electron","slug":"Electron","permalink":"http://rawbin-.github.io/tags/Electron/"}]},{"title":"Electron 脚本注入","slug":"cross-platform/electron/2018-07-10-electron-window-inject","date":"2021-12-31T02:37:59.943Z","updated":"2021-12-31T02:37:59.943Z","comments":true,"path":"cross-platform/electron/2018-07-10-electron-window-inject/","link":"","permalink":"http://rawbin-.github.io/cross-platform/electron/2018-07-10-electron-window-inject/","excerpt":"","text":"收集到的方法BrowserWindow 配置 webPreferences.preload String (可选) -在页面运行其他脚本之前预先加载指定的脚本 无论页面是否集成Node, 此脚本都可以访问所有Node API 脚本路径为文件的绝对路径。 当 node integration 关闭时, 预加载的脚本将从全局范围重新引入node的全局引用标志 参考示例. webContents 方法 executeJavaScript insertCSS 事件 did-finish-load dom-ready 遇到的一些坑(好好看控制台，错误信息有可能在最上面，滚动到看不见了) preload脚本语法 脚本本身只能用commonjs来写 不支持import 也不支持require ES6 module，只能用module.exports 12345678910111213// preload.js// const rendererAPI = require(&#x27;./RendererAPI&#x27;).default// rendererAPI()// export default () =&gt; &#123;// SyntaxError: Unexpected token &#x27;export&#x27;// import RendererAPI from &#x27;./RendererAPI&#x27;// // RendererAPI()// import RendererAPI from &#x27;./RendererAPI&#x27;// SyntaxError: Cannot use import statement outside a moduleconst rendererAPI = require(&#x27;./RendererAPI&#x27;)rendererAPI() 报错备忘 注意路径问题(一定要绝对路径)，要用打包后的地址 preload:path.join(app.getAppPath(),&#39;renderer-preload.js&#39;) 12345678910111213141516171819//module.exports = xxxUncaught TypeError: Cannot assign to read only property &#x27;exports&#x27; of object &#x27;#&lt;Object&gt;&#x27;// const rendererAPI = require(&#x27;./RendererAPI&#x27;).default// rendererAPI()// export default () =&gt; &#123;// SyntaxError: Unexpected token &#x27;export&#x27;// import RendererAPI from &#x27;./RendererAPI&#x27;// SyntaxError: Cannot use import statement outside a module// cannot load preload.js Unexpected Identifier Unable to create basic Accelerated OpenGL renderer. Unable to create basic Accelerated OpenGL renderer. Core Image is now using the software OpenGL renderer. This will be slow. executeJavaScript`时机 判断跟dom-ready, load等的关系 参考资料 BrowserWindow关于preload的说明 sandbox中preload的说明 webContents文档 在Electron中最快速预加载脚本 Electron webview完全指南 #217 Electron 深度实践总结 electron 提供SDK接口注入到远端页面使用 Electron 爬坑记 electron程序，如何在主进程远程页面中注入js及css？ Electron 预加载远程页面提升用户体验 electron 研究笔记 electron初探问题总结 我眼中的 Electron","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"Electron","slug":"前端开发/Web开发/JavaScript/Electron","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/Electron/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"客户端","slug":"客户端","permalink":"http://rawbin-.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"桌面端","slug":"桌面端","permalink":"http://rawbin-.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF/"},{"name":"Electron","slug":"Electron","permalink":"http://rawbin-.github.io/tags/Electron/"}]},{"title":"使用ava+spectron做Electron测试","slug":"cross-platform/electron/2018-07-12-electron-ava-test","date":"2021-12-31T02:37:59.943Z","updated":"2021-12-31T02:37:59.943Z","comments":true,"path":"cross-platform/electron/2018-07-12-electron-ava-test/","link":"","permalink":"http://rawbin-.github.io/cross-platform/electron/2018-07-12-electron-ava-test/","excerpt":"","text":"引子原有项目是electron-vue的模板，使用的是mocha和babel 6, ava需求是babel 7 升级了一波babel的插件，就可以玩起来了，基本基本大部分内容： @babel/core 替换 babel-core @babel/preset-* 替换 babel-preset-* 部分 @babel/plugin-* 替换 babel-plugin-*, 有的没有或者不影响，还是用原来的 修改 .babelrc, preset 和 plugin 前加@babel/ 为了保留原有的其他mocha 相关内容，单独建自己的目录，并修改package.json &quot;e2e:ava&quot;: &quot;npm run pack &amp;&amp; nyc ava test/e2e/ava&quot;, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152`ava`使用的优势：- 异步支持的好, `Promise`, `Generator`, `Async`,`Observable` ,`Callback`都支持- 用例并行执行，效率高- 集成Babel 7，无伤 ES6+### 启用ava#### 直接用ava- `npm i ava@latest -D &amp;&amp; ava` - `ava --help` 查看相应的命令行参数#### 注意点- `ava`目前只转换测试文件，有问题需要单独处理### 趟了半天的坑##### electron 2.0.4 + spectron 3.8.0 OK##### electron 6.1.4 + spectron 8.0.0 不好使##### electron 7.1.1 + spectron 9.0.0 不好使原因是 没有开启`nodeIntegration`, 尴尬 [Node Integration](https://github.com/electron-userland/spectron#node-integration) , [低级问题自问自答](https://github.com/electron-userland/spectron/issues/482)#### 解决办法#### 通过 `new BrowserWindow` 的 `preload` 脚本加载, 通过环境变量来设置```jsconst preloadPath = path.join(process.cwd(), &#x27;src/common/api/renderer-preload.js&#x27;) console.log(&#x27;preloadPath:&#x27;, preloadPath) mainWindow = new BrowserWindow(&#123; height: 800, useContentSize: true, width: 1260, webPreferences: &#123; preload: preloadPath, nodeIntegration: false &#125;&#125;) 1234// renderer-preload.jsif (process.env.NODE_ENV === &#x27;test&#x27;) &#123; window.electronRequire = require&#125; 1234567891011// Spenctron test casetest.beforeEach(async t =&gt; &#123; const app = new Application(&#123; path: electron, args: [&#x27;dist/electron/main.js&#x27;], requireName: &#x27;electronRequire&#x27;, startTimeout: 10000, waitTimeout: 10000 &#125;) await app.start() &#125;) 12// package.json 设置环境变量&quot;e2e:ava&quot;: &quot;npm run pack &amp;&amp; cross-env NODE_ENV=test nyc ava test/e2e/ava/index.js&quot;, 直接在 new BrowserWindow 的时候配上webPreferences. nodeIntegration12345678mainWindow = new BrowserWindow(&#123; height: 800, useContentSize: true, width: 1260, webPreferences: &#123; nodeIntegration: false &#125;&#125;) 主进程和渲染进程通信用了reply函数，但函数参数中还是需要传 channelId, 这个函数与event.sender.send的区别在于, send总是发送到main frame, 而 reply是发送到任意（内部调用了sendToFrame）,我错误的理解为一个是带channelId参数的，一个是不带的，其实是都需要带的 IPCMainEvent Doc ipcMain doc demo 主进程通信once注册的并发问题如果使用once注册，那么连续发送两次请求，得到的结果是一样的，需要根据请求， once 注册不同的 listener 参考资料 babel 7.x 和 webpack 4.x 配置vue项目 Upgrade to Babel 7 ava code coverage","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"Electron","slug":"前端开发/Web开发/JavaScript/Electron","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/Electron/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"客户端","slug":"客户端","permalink":"http://rawbin-.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"桌面端","slug":"桌面端","permalink":"http://rawbin-.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"Electron","slug":"Electron","permalink":"http://rawbin-.github.io/tags/Electron/"}]},{"title":"Electron在线热更新方案","slug":"cross-platform/electron/2018-07-09-electron-hot-update","date":"2021-12-31T02:37:59.943Z","updated":"2021-12-31T02:37:59.943Z","comments":true,"path":"cross-platform/electron/2018-07-09-electron-hot-update/","link":"","permalink":"http://rawbin-.github.io/cross-platform/electron/2018-07-09-electron-hot-update/","excerpt":"","text":"参考资料 如何使用electron-builder及electron-updater给项目配置自动更新 Electron应用使用electron-builder配合electron-updater实现自动更新 我是如何实现electron的在线升级热更新功能的？ Electron实现在线升级 热更新 遇到的问题 electron 热更新 Electron实现在线升级及功能的热更新 Electron 与 Vue 的性能优化","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Electron","slug":"Electron","permalink":"http://rawbin-.github.io/tags/Electron/"},{"name":"热更新","slug":"热更新","permalink":"http://rawbin-.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"在线更新","slug":"在线更新","permalink":"http://rawbin-.github.io/tags/%E5%9C%A8%E7%BA%BF%E6%9B%B4%E6%96%B0/"}]},{"title":"Electron 白屏问题","slug":"cross-platform/electron/2018-07-13-electron-white-screen","date":"2021-12-31T02:37:59.943Z","updated":"2021-12-31T02:37:59.943Z","comments":true,"path":"cross-platform/electron/2018-07-13-electron-white-screen/","link":"","permalink":"http://rawbin-.github.io/cross-platform/electron/2018-07-13-electron-white-screen/","excerpt":"","text":"一些优化方式一直白屏 升级electron版本 安装依赖问题 删除 .electron-vue/webpack.renderer.config.js 中关于白名单的配置，让所有资源都打包起来（包会变大） 123externals: [ ...Object.keys(dependencies || &#123;&#125;).filter(d =&gt; !whiteListedModules.includes(d)) ], 短暂白屏 先不显示窗口，可以显示了再显示 new BrowserWindow 的时候，设置show:false, 然后在 window 的ready-to-show 事件中显示 参考资料 解决electron-vue build 后static/下资源无法加载问题 Electron-vue静态资源路径 electron入坑指南 electron的log调试手段，可用于白屏调试 Electron踩坑指南不完全篇 Electron-builder打包后，exe运行白屏的问题 npm run build 打出来的包，安装后，什么都不显示，白屏？ electron-vue的正确build姿势 electron常见问题汇总","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"客户端","slug":"客户端","permalink":"http://rawbin-.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"桌面端","slug":"桌面端","permalink":"http://rawbin-.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF/"},{"name":"Electron","slug":"Electron","permalink":"http://rawbin-.github.io/tags/Electron/"}]},{"title":"Node PDF打印各种割字问题解决","slug":"cross-platform/nodejs/2018-08-21-node-print-pdf-problem","date":"2021-12-31T02:37:59.943Z","updated":"2021-12-31T02:37:59.943Z","comments":true,"path":"cross-platform/nodejs/2018-08-21-node-print-pdf-problem/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2018-08-21-node-print-pdf-problem/","excerpt":"","text":"macOS测试方法 运行test/test-html-print/test-html-print.js 调整代码中的format参数为A4或者A5测试不同的样例 A5 html文件为 test-*.html, A4 html文件为 test.html Chronium打印，打开node_modules/puppeteer/.local-chromium/mac-xxxxxx/chrome-mac/Chromium.app 并打开对应的 html文件，通过设置横版竖版，以及代码中的打印边距，勾选打印背景，去掉页眉页脚,打印出结果 Chrome打印，打开最新版的Chrome(最好是79以上版本更接近Chromium的内容)，打开对应html，通过设置横版竖版，以及代码中的打印边距，勾选打印背景，去掉页眉页脚,打印出结果 测试结果说明puppeteer 2.0对于test.html A4 打印说明 这个文件是原先在某个环境出现过角标割字的案例，在这个环境下没有复现,都正常 puppeteer2.0生成的test.html-A4.pdf与chrome打印的test.html-A4-chrome-print.pdf 二进制完全一样 puppeteer2.0生成的test.html-A4.pdf与对于版本的chromium打印的test.html-A4-chromium-print.pdf有少量的字节顺序不一样，但pdf显示结果看起来无差别 对于test-simple.html A5 打印说明 这个文件一直有行割字的问题 puppeteer2.0生成的test-simple.html-A5.pdf有割字现象，与浏览器打印的有换行和少量字节不一致的差异 chrome打印的test-simple.html-A5-chrome-print.pdf 与 puppeteer2.0对于版本的chromium打印的 test-simple.html-A5-chromium-print.pdf 二进制完全一致，且pdf显示正常 puppeteer 2.1.1 test.html,test-simple.html 测试结果跟 puppeteer 2.0 一致对于test-complex测试结果 puppeteer生成结果：第5题标签割字，第16题选项割字，第17题答案标签割字，第18题解析标签割字，第19题答案图片和文字割字，第20、21题答案标签割字，第27题答案文字割字，第29题解析标签割字，第31题答案文字割字，第32题解析标签割字 chrome打印结果：第7题标签和题目不在一页，第17题答案标签割字，第18题解析标签割字，第19题图形和文字割字，第21题答案标签割字，第27题标签和题目不在一页文字割字，第29题图形割字，第30题标签割字，第31题图形割字，第34题答案标签割字 结论 chrome打印本身也不行，那从工具的角度来解决问题就行不通了 从另一个方面来看，就是我们写的页面有问题或者说可以从页面本身来解决 解决办法前期有过一些其他的探索，比如 定位puppeteer, 也尝试过换一些其他的方案，都在向工具方面探索，也提过几个issue未解决，最后直接被上面的chrome 打印结果击垮，最终回过头来向代码方面探索，最终解决如下： 目前问题定位结论是display:flex引起的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;style type=&quot;text/css&quot;&gt;/*@media all !*just for debug*! &#123;*/@media print &#123; /*解决 答案选项 割字*/ .opts&#123; display: block !important; &#125; .column-4 .opt, .column-2 .opt, .column-1 .opt&#123; display: inline-block !important; &#125; .column-4 .opt&#123; width: 24.5% !important; &#125; .column-2 .opt&#123; width: 49.5% !important; &#125; /*解决 题号 割字*/ .one-page ul .outer&#123; display: block !important; position: relative !important; &#125; .timu_index&#123; position: absolute !important; margin-top: 0px !important; &#125; .outer .timu_index + div&#123; margin-left: 50px !important; &#125; /*解决 答案和解析标签 割字 */ .wrapper .tag&#123; display: block !important; clear: both; &#125; /*解决 答案解析文字图片 割字*/ .tag-content&#123; page-break-inside:auto; display: block !important; &#125; .tag-content img&#123; display: block !important; &#125; /*修复水印没撑开的问题*/ .question-stem&#123; display: block !important; &#125;&#125;&lt;/style&gt; 初步结论（待进一步探索） 这些割字问题跟flex布局有关 跟display非block有关，同时会影响print-break-*的结果","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"自动化","slug":"Web开发/前端开发/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"自动化","slug":"自动化","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"PDF","slug":"PDF","permalink":"http://rawbin-.github.io/tags/PDF/"},{"name":"字体","slug":"字体","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E4%BD%93/"}]},{"title":"Node PDF文件生成带中文字体尺寸太大问题解决","slug":"cross-platform/nodejs/2018-08-20-node-pdf-op-pdf-size","date":"2021-12-31T02:37:59.943Z","updated":"2021-12-31T02:37:59.943Z","comments":true,"path":"cross-platform/nodejs/2018-08-20-node-pdf-op-pdf-size/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2018-08-20-node-pdf-op-pdf-size/","excerpt":"","text":"关于PDF版式文件生成需要中文字体的问题 载入完整的中文字体的话，比如pingfang.ttf 那么再小的PDF都会加上整个字体的尺寸，也就是8M+，这个是不能忍的 上一次的解决办法是将唯一的那一部分文字用图片的方式替代 现在文字需要动态改变那么图片的方式已经失效 通过字体裁剪的方式解决 代码参考通过pdfkit 这个库来做的话，本身就默认字体裁剪，也就是没有上面的PDF文件过大的问题 参考 with-pdfkit.js通过pdf-lib 这个库来做，默认没有裁剪，就会出现上面的问题，看源码可以设置裁剪参数 参考 wiith-pdflib.js当然你也可以蛋疼自己裁剪 参考 with-pdflig-fontmin.js","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"自动化","slug":"Web开发/前端开发/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"自动化","slug":"自动化","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"PDF","slug":"PDF","permalink":"http://rawbin-.github.io/tags/PDF/"},{"name":"字体","slug":"字体","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E4%BD%93/"}]},{"title":"React状态设计和管理","slug":"framework/react/2018-06-28-react-state-management","date":"2021-12-31T02:37:59.943Z","updated":"2021-12-31T02:37:59.943Z","comments":true,"path":"framework/react/2018-06-28-react-state-management/","link":"","permalink":"http://rawbin-.github.io/framework/react/2018-06-28-react-state-management/","excerpt":"","text":"[TOC]","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://rawbin-.github.io/tags/React/"},{"name":"状态","slug":"状态","permalink":"http://rawbin-.github.io/tags/%E7%8A%B6%E6%80%81/"},{"name":"状态管理","slug":"状态管理","permalink":"http://rawbin-.github.io/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"}]},{"title":"JavaScript异步编程特性详解大合集","slug":"async/2018-02-28-async-javascript-all","date":"2021-12-31T02:37:59.942Z","updated":"2021-12-31T02:37:59.942Z","comments":true,"path":"async/2018-02-28-async-javascript-all/","link":"","permalink":"http://rawbin-.github.io/async/2018-02-28-async-javascript-all/","excerpt":"","text":"[TOC] JavaScript中的异步 回调函数 Promise Generator async/await 浏览器中的异步 事件监听addEventListener/attachEvent XMLHTTPRequest fetch API setTimeout/clearTimeout setInterval/clearInterval requestAnimationFrame script defer async Service Worker Node.js中的异步 EventEmitter setTimeout/clearTimeout setInterval/clearInterval setImmediate/clearImmediate process.nextTick() 第三方库处理异步 jQuery Deferred async.js Step co yepnope.js require.js Sea.js","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"异步编程","slug":"异步编程","permalink":"http://rawbin-.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"name":"迭代器","slug":"迭代器","permalink":"http://rawbin-.github.io/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"生成器","slug":"生成器","permalink":"http://rawbin-.github.io/tags/%E7%94%9F%E6%88%90%E5%99%A8/"}]},{"title":"前端多端跨端解决方案大合集","slug":"cross-platform/2018-04-28-javascript-cross-platform","date":"2021-12-31T02:37:59.942Z","updated":"2021-12-31T02:37:59.942Z","comments":true,"path":"cross-platform/2018-04-28-javascript-cross-platform/","link":"","permalink":"http://rawbin-.github.io/cross-platform/2018-04-28-javascript-cross-platform/","excerpt":"","text":"[TOC] 现有框架taro ref React chameleon ref 类Vue mpvue ref Vue uni-app ref Vue wepy ref 类Vue Antmove ref参考资料 小程序多端框架全面测评 如何写出一手好的小程序之多端架构篇 阿里 小程序云","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"小程序","slug":"小程序","permalink":"http://rawbin-.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"跨端","slug":"跨端","permalink":"http://rawbin-.github.io/tags/%E8%B7%A8%E7%AB%AF/"}]},{"title":"JavaScript 桌面客户端开发大合集","slug":"cross-platform/2018-03-28-javascript-application-dev","date":"2021-12-31T02:37:59.942Z","updated":"2021-12-31T02:37:59.942Z","comments":true,"path":"cross-platform/2018-03-28-javascript-application-dev/","link":"","permalink":"http://rawbin-.github.io/cross-platform/2018-03-28-javascript-application-dev/","excerpt":"","text":"[TOC] 相关平台库electron refnode-webkit =&gt; NW.js refhex(多年未更新) ref相关工具NW.js 启动安装器 windows NSIS Inno Setup WinRAR MacOS nw-builder appdmg Linux nw-builder 调试工具 Node Debug Node Inspector React Inspector Electron 启动安装器 windows Grunt-Electron-Installer Electron-installer-squirrel-windows electron-packager electron-builder MacOS electron-builder Linux grunt-build-atom-shell electron-packager electron-builder 调试工具 Devtron console出来后用require(&#39;devtron&#39;).install() Spectron npm install -g asar 将源代码转成归档文件 npm install -g rcedit 资源编辑 自动更新 Squirrel 测试工具 cucumber electron-forge 参考文档 Electron VS NW.js Electron 与 Vue 的性能优化 用JS开发跨平台桌面应用，从原理到实践","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"客户端","slug":"客户端","permalink":"http://rawbin-.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"桌面端","slug":"桌面端","permalink":"http://rawbin-.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF/"}]},{"title":"React组件间通信方式大合集及源码分析","slug":"framework/react/2018-06-28-react-component-communication","date":"2021-12-31T02:37:59.942Z","updated":"2021-12-31T02:37:59.942Z","comments":true,"path":"framework/react/2018-06-28-react-component-communication/","link":"","permalink":"http://rawbin-.github.io/framework/react/2018-06-28-react-component-communication/","excerpt":"","text":"[TOC]","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://rawbin-.github.io/tags/React/"},{"name":"组件通信","slug":"组件通信","permalink":"http://rawbin-.github.io/tags/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"}]},{"title":"Vue组件间通信方式大合集及源码分析","slug":"framework/vue/2018-05-28-vue-component-communication","date":"2021-12-31T02:37:59.942Z","updated":"2021-12-31T02:37:59.942Z","comments":true,"path":"framework/vue/2018-05-28-vue-component-communication/","link":"","permalink":"http://rawbin-.github.io/framework/vue/2018-05-28-vue-component-communication/","excerpt":"","text":"[TOC]","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://rawbin-.github.io/tags/Vue/"},{"name":"组件通信","slug":"组件通信","permalink":"http://rawbin-.github.io/tags/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"}]},{"title":"Vue状态设计和管理","slug":"framework/vue/2018-05-28-vue-state-management","date":"2021-12-31T02:37:59.942Z","updated":"2021-12-31T02:37:59.942Z","comments":true,"path":"framework/vue/2018-05-28-vue-state-management/","link":"","permalink":"http://rawbin-.github.io/framework/vue/2018-05-28-vue-state-management/","excerpt":"","text":"[TOC]","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://rawbin-.github.io/tags/Vue/"},{"name":"状态","slug":"状态","permalink":"http://rawbin-.github.io/tags/%E7%8A%B6%E6%80%81/"},{"name":"状态管理","slug":"状态管理","permalink":"http://rawbin-.github.io/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"}]},{"title":"React核心概念解析","slug":"framework/react/2018-06-27-react-core","date":"2021-12-31T02:37:59.942Z","updated":"2021-12-31T02:37:59.942Z","comments":true,"path":"framework/react/2018-06-27-react-core/","link":"","permalink":"http://rawbin-.github.io/framework/react/2018-06-27-react-core/","excerpt":"","text":"[TOC] JSX插值表达式propsstate生命周期事件通信","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://rawbin-.github.io/tags/React/"}]},{"title":"事件循环规范和源码分析","slug":"browser/2017-12-10-event-loop-spec-source","date":"2021-12-31T02:37:59.941Z","updated":"2021-12-31T02:37:59.941Z","comments":true,"path":"browser/2017-12-10-event-loop-spec-source/","link":"","permalink":"http://rawbin-.github.io/browser/2017-12-10-event-loop-spec-source/","excerpt":"","text":"W3C HTML 标准事件循环部分的部分翻译事件循环是用来协调事件，用户操作，脚本，渲染，网络等各个部分的机制，有两种事件循环，一种是浏览上下文事件循环，另一种是Web Worker的事件循环。 每个用户代理只是有一个浏览上下文事件循环，并且单位相关类似域浏览上下文至多有一个浏览上下文事件循环。 每个用户代理总是至少有一个浏览上下文，如果事件循环的浏览上下文消失了，那么事件循环也会消失，浏览上下文总是有一个事件循环来处理它的活动。 事件循环都有一个或多个任务队列，任务队列是任务的有序列表。 每个任务都有特定的任务来源，来自特定任务源和指向特定事件循环的任务必须总是被添加到同一个任务队列，不同任务来源的任务可能被放入不同的任务队列。 每个事件循环都有一个微任务队列，微任务是相对于任务来说的，微任务有自己专门的微任务队列，微任务可分为两种独立回调微任务和复合微任务，HTML规范中只涉及到独立回调微任务。 参考资料 W3C HTML 5.2 Event Loop whatwg Event Loop whatwg HTML 文档中文翻译 一次弄懂Event Loop（彻底解决此类面试问题） ECMAScript 2018 从Chrome源码看事件循环 理解Webkit和Chronium","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"事件循环","slug":"事件循环","permalink":"http://rawbin-.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"Javascript","slug":"Javascript","permalink":"http://rawbin-.github.io/tags/Javascript/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"http://rawbin-.github.io/tags/Event-Loop/"}]},{"title":"动态表单、页面配置规范","slug":"dev-app/2018-01-10-dynamic-page-form-config","date":"2021-12-31T02:37:59.941Z","updated":"2021-12-31T02:37:59.941Z","comments":true,"path":"dev-app/2018-01-10-dynamic-page-form-config/","link":"","permalink":"http://rawbin-.github.io/dev-app/2018-01-10-dynamic-page-form-config/","excerpt":"","text":"参考资料 页面可视化搭建工具技术要点 页面可视化搭建工具技术要点 页面可视化搭建工具前生今世 页面可视化搭建工具前生今世 page-pipeline vue-form-making vue-form-generator 飞冰 ice lab 云凤蝶 Vue+ElementUI实现表单动态渲染、可视化配置的方法 form-create form-create angular-gridster2 X-Page-Editor-Vue vue-page-designer Vue-Layout react-design-editor 有工作流 antd visual editor react-antd-visual jquery form builder react-dnd vue-smooth-dnd vue-grid-layout react-grid-layout","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"动态页面","slug":"动态页面","permalink":"http://rawbin-.github.io/tags/%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2/"},{"name":"动态表单","slug":"动态表单","permalink":"http://rawbin-.github.io/tags/%E5%8A%A8%E6%80%81%E8%A1%A8%E5%8D%95/"},{"name":"配置规范","slug":"配置规范","permalink":"http://rawbin-.github.io/tags/%E9%85%8D%E7%BD%AE%E8%A7%84%E8%8C%83/"}]},{"title":"大前端参考手册","slug":"dev-general/2017-12-07-great-fe-references","date":"2021-12-31T02:37:59.941Z","updated":"2021-12-31T02:37:59.941Z","comments":true,"path":"dev-general/2017-12-07-great-fe-references/","link":"","permalink":"http://rawbin-.github.io/dev-general/2017-12-07-great-fe-references/","excerpt":"","text":"参考资料 怎样成为全栈工程师（Full Stack Developer） 全栈增长工程师指南 Growth: 全栈增长工程师指南 全栈增长工程师实战 爆栈 免费的计算机编程类中文书籍 经典编程书籍大全 前端开发者手册 Web前端开发大系概览 （前端开发技术栈） 我的职业是前端工程师 深入理解JavaScript系列 Developer进阶书单 Modern JavaScript Web Development Serverless 架构应用开发指南 2万5千字大厂面经 | 掘金技术征文 developer roadmap GitHub最全的前端资源汇总仓库 前端开发面试题大收集 收集的前端面试题和答案 “别更新了，学不动了”之：2019，全栈开发者应该学些什么？ 设计模式 图说设计模式 史上最全设计模式导学目录（完整版） 23种设计模式全解析 深入理解JavaScript系列","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"全栈开发","slug":"前端开发/Web开发/全栈开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/tags/Web%E5%BC%80%E5%8F%91/"},{"name":"大前端","slug":"大前端","permalink":"http://rawbin-.github.io/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"全栈","slug":"全栈","permalink":"http://rawbin-.github.io/tags/%E5%85%A8%E6%A0%88/"},{"name":"后端","slug":"后端","permalink":"http://rawbin-.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"运维","slug":"运维","permalink":"http://rawbin-.github.io/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"W3C CSS2.1 规范中文翻译","slug":"web-standard/2017-12-15-w3c-css2-spec-zh","date":"2021-12-31T02:37:59.941Z","updated":"2021-12-31T02:37:59.941Z","comments":true,"path":"web-standard/2017-12-15-w3c-css2-spec-zh/","link":"","permalink":"http://rawbin-.github.io/web-standard/2017-12-15-w3c-css2-spec-zh/","excerpt":"","text":"小哥值得学习 参考资料 CSS2.1 规范中文翻译 CSS2 规范开发手册 W3C规范翻译入口 规范翻译的心得 专访｜@黯羽轻扬，CSS2.1规范中文版译者","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"W3C","slug":"W3C","permalink":"http://rawbin-.github.io/tags/W3C/"},{"name":"CSS2","slug":"CSS2","permalink":"http://rawbin-.github.io/tags/CSS2/"},{"name":"中文翻译","slug":"中文翻译","permalink":"http://rawbin-.github.io/tags/%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/"}]},{"title":"前端页面布局简明参考手册","slug":"language/css/2018-01-07-page-layout-ref","date":"2021-12-31T02:37:59.941Z","updated":"2021-12-31T02:37:59.941Z","comments":true,"path":"language/css/2018-01-07-page-layout-ref/","link":"","permalink":"http://rawbin-.github.io/language/css/2018-01-07-page-layout-ref/","excerpt":"","text":"布局方式分类固定布局 栅格布局 优势 布局可预见，更好控制行长，容易设计和制作 劣势 浏览器窗口比网页窄，内容显示不全；大屏幕下白边很多；大字体行长难以控制，用户无法控制 实现方式 固定内容块的宽度 流式布局 优势 可以避免留白，桌面浏览器用户可以控制窗口内容和宽度，没有水平滚动条 劣势 大屏显示器下行长过长，不适合阅读；内容难以预见 实现方式 设置百分比宽度 设置min-width和max-width，控制阈值 弹性布局 优势 允许文本尺寸适当变动时，提供一致的布局体验；比固定和流式布局更紧密控制行长 劣势 图像和影像不能随着文本和布局的其他部分缩放，最大文本尺寸时布局宽度可能超过浏览器宽度，在解决不同设备和浏览器的大小时不是很有用 实现方式 使用em来设置尺寸 混合布局 将像素，百分比，em等在合适的地方同时使用 响应式布局 实现方式 媒体查询，根据不同屏幕设置规则 流式布局，使用em或者百分比等相对单位设置总体宽度 弹性图片，使用相对单位确保图片再大也不会超过其容器 自适应布局Flex 布局Grid布局","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"CSS","slug":"前端开发/Web开发/CSS","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"页面布局","slug":"页面布局","permalink":"http://rawbin-.github.io/tags/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"}]},{"title":"CSS动画简明参考手册","slug":"language/css/2018-01-06-css-animation-ref","date":"2021-12-31T02:37:59.941Z","updated":"2021-12-31T02:37:59.941Z","comments":true,"path":"language/css/2018-01-06-css-animation-ref/","link":"","permalink":"http://rawbin-.github.io/language/css/2018-01-06-css-animation-ref/","excerpt":"","text":"过渡相关属性 transition-property 属性名称|all（默认）|none transition-duration 时间(默认0) transition-timing-function ease(默认)|linear|ease-in|ease-in-out|step-start|step-end|steps|cubic-bezier(#,#,#,#) transition-delay 时间(默认0) 变换属性 transform 变换函数(s)|none(默认) rotate, rotateX, rotateY, rotate3d, totateZ scale, scaleX, scaleY, scale3d, scaleZ translate, translateX, translateY, translate3d, translateZ skew, skewX, skewY transform-origin 百分比|长度|left|center|right|top|bottom 默认 50% 50% 关键帧动画 1234@keyframes animation-name&#123; keyframe &#123;property:value&#125; keyframe &#123;property:value&#125;&#125; animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-play-state animation-fill-mode backface-visibility perspective perspective-origin","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"CSS","slug":"前端开发/Web开发/CSS","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"动画","slug":"动画","permalink":"http://rawbin-.github.io/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"CSS页面元素居中简明参考手册","slug":"language/css/2018-01-05-css-align-center-ref","date":"2021-12-31T02:37:59.941Z","updated":"2021-12-31T02:37:59.941Z","comments":true,"path":"language/css/2018-01-05-css-align-center-ref/","link":"","permalink":"http://rawbin-.github.io/language/css/2018-01-05-css-align-center-ref/","excerpt":"","text":"参考资料 如何居中一个元素（终结版） CSS居中的各种实现方式 CSS实现水平垂直居中的1010种方式（史上最全） 一起搞懂 CSS 水平居中与垂直居中的16个方法 详解 CSS 居中布局技巧 15种CSS居中方式 使用CSS完成元素居中的七种方法 【基础】这15种CSS居中的方式，你都用过哪几种？ Centering in CSS: A Complete Guide","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"CSS","slug":"前端开发/Web开发/CSS","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"居中","slug":"居中","permalink":"http://rawbin-.github.io/tags/%E5%B1%85%E4%B8%AD/"},{"name":"垂直居中","slug":"垂直居中","permalink":"http://rawbin-.github.io/tags/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"},{"name":"水平居中","slug":"水平居中","permalink":"http://rawbin-.github.io/tags/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/"}]},{"title":"实战Vue.js虚拟DOM原理—实例和源码分析","slug":"framework/vue/2017-12-07-vue-virtual-dom-practice","date":"2021-12-31T02:37:59.941Z","updated":"2021-12-31T02:37:59.941Z","comments":true,"path":"framework/vue/2017-12-07-vue-virtual-dom-practice/","link":"","permalink":"http://rawbin-.github.io/framework/vue/2017-12-07-vue-virtual-dom-practice/","excerpt":"","text":"参考资料 虚拟DOM在Vue中的实现","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://rawbin-.github.io/tags/Vue-js/"},{"name":"虚拟DOM","slug":"虚拟DOM","permalink":"http://rawbin-.github.io/tags/%E8%99%9A%E6%8B%9FDOM/"},{"name":"diff算法","slug":"diff算法","permalink":"http://rawbin-.github.io/tags/diff%E7%AE%97%E6%B3%95/"}]},{"title":"git 仓库瘦身方法及相关命令解析","slug":"dev-tools/git/2017-12-18-git-slimming","date":"2021-12-31T02:37:59.941Z","updated":"2021-12-31T02:37:59.941Z","comments":true,"path":"dev-tools/git/2017-12-18-git-slimming/","link":"","permalink":"http://rawbin-.github.io/dev-tools/git/2017-12-18-git-slimming/","excerpt":"","text":"前言其实有更简单和高效的工具能搞这事BFG Repo-Cleaner, 本文纯粹是为了用Git来解决这事，而不是单纯的解决这事。 相关命令Shell 相关 ```` `` 反引号(ESC旁边)表示命令替换 ,$()表达同样的意思，在需要命令执行结果的时候使用，比如 echo $(whoami) | 管道运算符，将上一条命令的执行结果 git-verify-pack ref 获取所有文件信息，可用git verify-pack --help查看帮助 -v --verbose 展示输出结果 1git verify-pack [-v|--verbose] [-s|--stat-only] [--] &lt;pack&gt;.idx 命令输出文件列含义和顺序如下: 1SHA-1 type size size-in-packfile offset-in-packfile sort bash命令，对输入进行排序，可用sort --help查看帮助 -n --numeric-sort 用数值来比较 -r --reverse 倒序 -u --unique -k --key=KEYDEF ，KEYDEF的格式是F[.C][OPTS][,F[.C][OPTS]] , F(field)表示是第几列（默认是1），C(character)表示当前列的第几个字符（默认是1），OPTS表达排序顺序，跟sort本身的排序顺序表达一致(可选这些参数[bdfgiMhnRrV])， 我们这里用到的是第三列(size)并且用数值比较，所以命令会是sort -k 3 -n，命令也可以合写 sort -k3n head / tail 命令 截取输入中的部分结果，可用head --help 和tail --help查看帮助 head和tail参数含义相似 head参数 ，-n, --lines=[-]NUM 行数前面没有减号，表示取前n行; 行号前面带减号表示从头开始取到倒数第n行止 tail参数 ，-n, --lines=[+]NUM 行数前面没有加号，表示取后n行; 行号前面带加号表示从第n行开始取到结尾 xargs 构建参数 -n &lt;number&gt; 一次取几个作为参数 git-rev-list 按时间倒序列出提交对象 --all 列出所有能显示的引用 --objects 列出提交对象引用的对象ID awk 命令行下强大的文本处理工具 ref, 同时也是一个脚本解析命令，有自己的脚本语法规则 常用模式awk &#39;[&lt;pattern&gt;]&#123; &lt;action&gt; &#125;&#39; 使用$+列序号来引用每一行对应列的数据，比如 $1为第一列内容，$2为第二列内容 NF特殊表示列数，$NF表示最后一列内容; NR是已经处理的行数 git-filter-branch ref, 重写分支版本历史信息 --tree-filter &lt;command&gt; 用来重写树及相关内容的过滤器，参数会经过shell解析 --index-filter &lt;command&gt; 用来重写index的过滤器，跟tree-filter相似，但不迁出树对象，所以会更快；经常与git rm --cached --ignore-unmatch ...联用 --tag-name-filter &lt;command&gt; --tag-name-filter cat更新tag相关信息 prune-empty 删除由于&lt;command&gt; 操作产生的空提交 注意文档中这一小节CHECKLIST FOR SHRINKING A REPOSITORY git-for-each-ref 处理每一个引用点 --format=&lt;format&gt; %(refname) 模板字符串 git-update-ref 更新引用对象名称 -d 删除引用 git-rm ref 从工作区和暂存区删除文件 -f --force 强制删除 -r 递归删除目录下的内容 --cached 仅仅从暂存区删除，工作区的内容不变 --ignore-unmatch 没有匹配到文件也算成功执行 git-fsck 检查数据对象的连接性和有效性 --full 检查所有的数据对象 --unreachable 打印不可达的数据对象 git-reflog 引用日志信息管理 expire 子命令 --all 处理所有引用的引用日志 --expire=&lt;time&gt; 处理比设置的时间旧的入口 git-gc 清理不必要的文件，优化本地仓库 --aggressive 强化本地仓库优化，执行时间更长 --prune=&lt;date&gt; 处理指定时间之前的 git-clone ref 克隆远端仓库 --bare 不带这个选项是创建一个目标目录，同时目录下包含一个.git的目录，记录仓库相关信息，其他代码相关内容跟.git目录在同一目录下；使用这个选项，就没有其他代码相关内容了，也没有.git这个目录了，源来.git下的内容直接在这个目标目录下。所有refs/remotes/origin远端分支直接拷贝作为本地引用在refs/heads，就没有refs/remotes/了，其他跟这个相关的内容也没了。 --mirror 这也是 —bare模式的一种，但有所有远程跟踪分支引用相关的映射关系，并可以通过git remote update来更新。 -o &lt;name&gt; --origin &lt;name&gt; 改变默认的origin命名 -b &lt;name&gt; --branch &lt;name&gt; 切换到指定的分支 &lt;repository&gt; 仓库路径，支持ssh,git,http[s],ftp[s] 和类scp的服务器路径，当然也支持本地路径绝对路径或者file协议的路径 &lt;directory&gt; 目标目录名 git-push 推送到远端仓库 &lt;repository&gt; 目标远端仓库地址 &lt;src&gt;:&lt;dst&gt; 本地源（可以是分支也可以是任意版本引用）和远程目标分支，均不写的话均为当前分支；如果&lt;src&gt;不写而只写:&lt;dst&gt;表示删除远端dst分支 --all 推送所有本地存在的分支到远程，本地分支在refs/heads --purne 清理没有本地分支的远程分支 --mirror 将所有引用(所有refs下的内容，包括但不限于refs/heads,refs/remotes,refs/tags，注意区别--all)镜像到远端 -n --dry-run 走个过程，不搞实质性内容，在搞尝试性内容时很管用，很多地方都有这个选项 利用命令进行处理拿到相关文件路径 列出 git 对象及相关信息 git verify-pack -v .git/objects/pack/*.idx 将 git 对象按实际大小从小到大排列 git verify-pack -v .git/objects/pack/*.idx | sort -k3n 根据输出的情况，看需要选取的条件 比如取最大20个git verify-pack -v .git/objects/pack/*.idx | sort -k3n | tail -20 我这里取大于2M的看看情况 git verify-pack -v .git/objects/pack/*.idx | sort -k3n | awk &#39;$3 &gt; 2 * 1024 * 1024 &#123;print&#125;&#39; 从提交对象中过滤出符合条件的提交 git rev-list --objects --all | grep &quot;$(git verify-pack -v .git/objects/pack/*.idx | sort -k3n | awk &#39;&#123;if(NF &gt; 2 &amp;&amp; ($3 &gt; 2 * 1024 * 1024) &amp;&amp; length($1) == 40) &#123;print $1&#125;&#125;&#39;)&quot; (加入了过滤无关数据的条件) 把响应结果写入到文件result.txt git rev-list --objects --all | grep &quot;$(git verify-pack -v .git/objects/pack/*.idx | sort -k3n | awk &#39;&#123;if(NF &gt; 2 &amp;&amp; ($3 &gt; 2 * 1024 * 1024) &amp;&amp; length($1) == 40) &#123;print $1&#125;&#125;&#39;)&quot; &gt; result.txt 得到的结果是包含 hash 和路径的数据列表 取出大文件的路径结果，看看哪些可以删掉的 cat result.txt | awk &#39;&#123;print $2&#125;&#39; | sort -u 删除相关路径的历史提交 从上面的路径里面找出可以删除的路径，通过下面的方法删除 通提交历史中删除对应路径的命令 git filter-branch -f --prune-empty --index-filter &#39;git rm -rf --cached --ignore-unmatch &lt;path-to-remove-from-log&gt;&#39; -- --all 后续相关清理 git reflog expire --expire=now --all 重新整理所有日志 git gc --prune=now --aggressive 重新整理仓库文件存储 同步最新结果到远端 git push --all --force 仓库大会很慢，耐心等 git push --tags --force 完整的命令列表12345678910git rev-list --objects --all | grep &quot;$(git verify-pack -v .git/objects/pack/*.idx | sort -k3n | awk &#x27;&#123;if(NF &gt; 2 &amp;&amp; ($3 &gt; 2 * 1024 * 1024) &amp;&amp; length($1) == 40) &#123;print $1&#125;&#125;&#x27;)&quot; &gt; result.txtcat result.txt | awk &#x27;&#123;print $2&#125;&#x27; | sort -ugit filter-branch -f --index-filter &#x27;git rm -rf --cached --ignore-unmatch dist*.zip dist/*.zip output.zip node_modules dist&#x27; --prune-empty --tag-name-filter cat -- --allgit for-each-ref --format=&quot;%(refname)&quot; refs/original/ | xargs -n 1 git update-ref -d ## 这步搞完就没有上一步的备份了，最好先单独备份一把，也只有搞了瘦身成效才明显git reflog expire --expire=now --expire-unreachable=all --allgit fsck --full --unreachablegit repack -A -dgit gc --prune=now --aggressivegit push --all --force git push --tags --force 然并卵(有插曲)插曲现象 可以clone 这个rawbin-/git-rewrite-history-test仓库做测试，一套搞完没有效果，数据对象还在 12345678910git clone git@github.com:rawbin-/git-rewrite-history-test.gitcd git-rewrite-history-testgit rev-list --objects --all ## 查看对象，包含了dist目录和dist.zip的内容git filter-branch -f --index-filter &#x27;git rm -rf --cached --ignore-unmatch dist*.zip dist/*.zip output.zip node_modules dist&#x27; --prune-empty --tag-name-filter cat -- --allgit reflog expire --expire=now --expire-unreachable=all --allgit fsck --full --unreachablegit repack -A -dgit gc --prune=now --aggressivegit rev-list --objects --all (测出来一个可行结果) ，只需要把命令执行两遍，数据对象能被删掉 12345678git clone git@github.com:rawbin-/git-rewrite-history-test.gitcd git-rewrite-history-testgit rev-list --objects --all ## 看看对象列表的情况 git filter-branch -f --index-filter &#x27;git rm -rf --cached --ignore-unmatch dist*.zip dist/*.zip output.zip node_modules dist&#x27; --prune-empty --tag-name-filter cat -- --allgit rev-list --objects --all ## 对象列表中还是存在的git filter-branch -f --index-filter &#x27;git rm -rf --cached --ignore-unmatch dist*.zip dist/*.zip output.zip node_modules dist&#x27; --prune-empty --tag-name-filter cat -- --allgit rev-list --objects --all ## 对象列表中已经被删掉了 解释原因 一套搞完数据对象还在的原因是git filter-branch执行结果后再.git/refs/original里面还有备份，这里面的备份还会引用原有的数据对象，哪怕是经过了日志整理和垃圾回收，这些引用都会一直在以备恢复。 执行两遍能删除数据对象，是因为强制模式下的git filter-branch第二次会覆盖前一次的备份，覆盖完了之后就没有了备份，也就没有了引用，也就能全部删掉了，也就被删掉了。但整体的空间还是没有回收回来，还需要日志整理和垃圾回收 后记Git的几个核心概念： Blob 存储的文件内容，文件名和文件系统相关系统没放在这，在整个仓库里只要文件内容相同，在Git中只存储一份内容，通过ID引用 Tree 包含了对整个目录和目录下的Blob相关的名称和权限信息 Commit 是对Tree的引用，同时包含作者、提交人、提交日志及相关的父提交等信息 Tag 是对Commit的引用，同时包含Tag名称、备注和打Tag的人等信息 refs 对其他对象的引用，一般是Commit, 使用对应Commit的ID引用 参考资料 BFG Repo-Cleaner Removing sensitive data from a repository Maintaining a Git Repository git filter-branch Git Tools - Rewriting History git remove from history [remove files from git history](Remove files from git history)","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"自动化","slug":"Web开发/前端开发/JavaScript/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://rawbin-.github.io/tags/Git/"},{"name":"仓库","slug":"仓库","permalink":"http://rawbin-.github.io/tags/%E4%BB%93%E5%BA%93/"},{"name":"瘦身","slug":"瘦身","permalink":"http://rawbin-.github.io/tags/%E7%98%A6%E8%BA%AB/"}]},{"title":"浏览器兼容处理方案汇总","slug":"browser/2017-12-05-browser-compatibility","date":"2021-12-31T02:37:59.940Z","updated":"2021-12-31T02:37:59.940Z","comments":true,"path":"browser/2017-12-05-browser-compatibility/","link":"","permalink":"http://rawbin-.github.io/browser/2017-12-05-browser-compatibility/","excerpt":"","text":"参考资料样式兼容 respond.js reset-css minireset.css normalize.css 脚本兼容 W3 Help 兼容性 mobile Hack HTML5 Please Modernizr HTML5 Cross Browser Polyfills html5shiv 让IE8 及更低版本的IE 识别section、 article、nav 等HTML5 元素 polyfill polyfills selectivizr 让IE（6/7/8）支持::first-child 等高级CSS 选择符 IE9.js 修复从IE6 到IE9 的很多bug 和缺损功能 CSS3PIE 让IE6 到IE9 支持圆角、背景渐变、边框图片、盒阴影、RGBa 颜色等可视化的CSS3 功能 -prefix-free 为需要厂商前缀的CSS3 声明添加前缀 boderBoxModel.js IE6和IE7支持CSS3 box-sizing","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器兼容","slug":"浏览器兼容","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"},{"name":"polyfill","slug":"polyfill","permalink":"http://rawbin-.github.io/tags/polyfill/"},{"name":"特性检测","slug":"特性检测","permalink":"http://rawbin-.github.io/tags/%E7%89%B9%E6%80%A7%E6%A3%80%E6%B5%8B/"}]},{"title":"Webkit源码分析铺路","slug":"browser/2017-12-01-webkit-src-overview","date":"2021-12-31T02:37:59.940Z","updated":"2021-12-31T02:37:59.940Z","comments":true,"path":"browser/2017-12-01-webkit-src-overview/","link":"","permalink":"http://rawbin-.github.io/browser/2017-12-01-webkit-src-overview/","excerpt":"","text":"1 Chrome 版本比较 Chromium 不是Chrome，但Chrome的内容基本来源于Chromium，这个是开源的版本，小时级别的更新 Canary 是试验版，翻译过来就是金丝雀，金丝雀对瓦斯等毒气很敏感，浓度稍高就会停止鸣叫甚至挂掉，金丝雀是瓦斯等毒气检测的土办法，这个场景在《寻龙诀》中黄渤的操作中也能看到。哈哈 扯远了，这个是daily build 版本。 Dev 是开发版，weekly build版本 Beta 是测试版，monthly build版本 Stable 是稳定版，不定期更新，一般也是一个月左右一次 更新频率 Chromium &gt; Chrome Canary &gt; Chrome Dev &gt; Chrome Beta &gt; Chrome Stable Chrome Dev、Chrome Beta 和 Chrome Stable三者只能同时出现一个 Chromium 、Chrome Canary 和 剩下的任意一个可共存 2 Chrome/Chromium源码获取 可以说Chromium是Chrome的开源版本，但Chrome本身不开源 从Chromium官网 点击Chromium 到Chromium首页 选择Get the Code: Checkout, Build, &amp; Run Chromium 这里我们以Mac 环境为例，介绍源码获取 我们只需要获取源码不进行编译，可以简单点，如果需要编译可以参考这里进行操作。 首先配置好梯子（我用 lantern, 我的邀请码 YPV2DMN），编辑~/.gitconfig，配置VPN代理 12345## 配置信息在lanter的设置=&gt;高级设置里面可以拿到，比如我的类似于下面的[http]proxy = http://your-socks5-host:1080 # http://127.0.0.1:57047[https]proxy = http://your-socks5-host:1080 # http://127.0.0.1:57047 然后获取搞源码的工具（需要用上自带的梯子）， 1git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 编辑~/.bashrc 或者 ~/.zshrc （具体看到底用的哪个，都用可以都搞上），添加上面的工具路径 1export PATH=$PATH:/path/to/depot_tools 找一个地方放Chromium的源码 12mkdir chromium &amp;&amp; cd chromiumfetch chromium --no-history 更新现有的搞出来的Chromium源码 12git rebase-updategclient sync 3 源码结构参考资料 Chromium 官网 Chromium 文档汇总 Chromium 设计文档 Chromium 开发者文档 Chromium 源代码结构 chromium编码规范","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"事件循环","slug":"事件循环","permalink":"http://rawbin-.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"EasyUI 扩展实战","slug":"dev-3rd-libs/2017-11-22-easyui-extend","date":"2021-12-31T02:37:59.940Z","updated":"2021-12-31T02:37:59.940Z","comments":true,"path":"dev-3rd-libs/2017-11-22-easyui-extend/","link":"","permalink":"http://rawbin-.github.io/dev-3rd-libs/2017-11-22-easyui-extend/","excerpt":"","text":"基本概念对于每一个插件 xxx 来说，有如下几部分内容，见文档 属性 定义在每个插件的默认值对象里面 jQuery.fn.xxx.defaults 方法 定义在每个插件的方法对象里面 jQuery.fn.xxx.methods, 调用方式为$(&quot;selector&quot;).xxx(&#39;methodName&#39;,methodParams)，每个方法两个参数，第一个为jQuery对象（必传），第二个为传入的参数 事件 定义在每个插件的默认值对象里面 jQuery.fn.xxx.defaults 实战预热 有了上面的基础之后，有扩展就覆盖原有配置属性，随时可以定义自己的扩展 先 下载 EasyUI源码，以便后续看具体的内容 EasyUI 可以免费用，但不开源，部分代码是压缩的，但不影响代码分析 未压缩的版本再src目录里面（内容不全） 所有内容再 plugins 里面（带压缩的，内容是全的） 翻看src下的各个插件的代码（都是插件，jQuery插件） 共有的特征 $.fn.xxx 以jQuery插件的方式定义 $.fn.xxx.defaults 定义插件默认属性值 $.fn.xxx.methods 定义插件方法集合 $.fn.xxx.parseOptions 定义解析插件配置的方法 $.fn.xxx.parseData 部分插件才有的解析数据的方法 参考资料 EasyUI思想、用法解析 EasyUI doc Datagrid doc EasyUI 代码下载 EasyUI Datagrid 列拖拽 动态的改变列显示的顺序 Easyui-Datagrid—表头灵活显示 Easyui-Datagrid—表头灵活拖动","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript开发","slug":"Web开发/前端开发/JavaScript开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://rawbin-.github.io/tags/jQuery/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://rawbin-.github.io/tags/EasyUI/"},{"name":"Combobox","slug":"Combobox","permalink":"http://rawbin-.github.io/tags/Combobox/"},{"name":"Datagrid","slug":"Datagrid","permalink":"http://rawbin-.github.io/tags/Datagrid/"}]},{"title":"内网穿透工具","slug":"dev-env/2017-11-25-nat-ddns-tools","date":"2021-12-31T02:37:59.940Z","updated":"2021-12-31T02:37:59.940Z","comments":true,"path":"dev-env/2017-11-25-nat-ddns-tools/","link":"","permalink":"http://rawbin-.github.io/dev-env/2017-11-25-nat-ddns-tools/","excerpt":"","text":"参考资料 可以实现内网穿透的几款工具 可以实现内网穿透的几款工具 内网穿透的几种方式 ngrok sunny-ngrok ittun echosite natapp 小米球 localtunnel pangolin pptun spike lanproxy frp 花生壳 nat123","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"网络工具","slug":"Web开发/网络工具","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"ngrok","slug":"ngrok","permalink":"http://rawbin-.github.io/tags/ngrok/"},{"name":"内网穿透工具","slug":"内网穿透工具","permalink":"http://rawbin-.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/"}]},{"title":"MacOS 设置命令行或终端代理","slug":"dev-env/2017-12-05-macos-cmd-proxy","date":"2021-12-31T02:37:59.940Z","updated":"2021-12-31T02:37:59.940Z","comments":true,"path":"dev-env/2017-12-05-macos-cmd-proxy/","link":"","permalink":"http://rawbin-.github.io/dev-env/2017-12-05-macos-cmd-proxy/","excerpt":"","text":"在所有事开始之前我们需要有一个梯\\子，我用 lantern, 我的邀请码 YPV2DMN 单一命令配置代理 如果只是单一的命令不能连接，可以单独设置 比如执行如下命令 1git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 得到的结果 1fatal: unable to access &#x27;https://chromium.googlesource.com/chromium/tools/depot_tools.git/&#x27;: Failed to connect to chromium.googlesource.com port 443: Operation timed out 解决这个问题可以给git单独设置代理，编辑~/.gitconfig 并加入如下内容 12345## 配置信息在lanter的设置=&gt;高级设置里面可以拿到，比如我的类似于下面的[http]proxy = http://127.0.0.1:57047 # http://your-socks5-host:port[https]proxy = http://127.0.0.1:57047 # http://your-socks5-host:port 配置完成后重新执行相关git操作即可 执行命令的时候确定是否使用代理 上面单一命令的配置存在几个问题 用不用这个代理需要来回改配置文件 这个配置只适合单一的命令 可以通过proxychains-ng 来实现使用时代理，比如像下面这样 12345$ proxychains4 curl www.google.com[proxychains] config file found: /usr/local/etc/proxychains.conf[proxychains] preloading /usr/local/Cellar/proxychains-ng/4.13/lib/libproxychains4.dylib[proxychains] DLL init: proxychains-ng 4.13[proxychains] Strict chain ... 127.0.0.1:57047 ... 119.28.87.227:80 ... OK 安装proxychains-ng 1brew install proxychains-ng 然后编辑/usr/local/etc/proxychains/conf, 并加入如下内容 1234[ProxyList]http 127.0.0.1 57047#https 127.0.0.1 57047#socks4 127.0.0.1 57048 这样配置完了之后不一定能生效，具体依赖于MacOS的版本，原因可以参考 proxychains-ng 关于 Mac 上的系统完整性保护 Configuring System Integrity Protection 详情可以参考，过程是重启MacOS，按住Command+R 在出现Logo或者进度条的时候松手，进去执行一条命令，禁用系统完整性保护，当然你也可以 通过 ProxyChains-NG 实现终端下任意应用代理 故事：试图不关闭 SIP 在 macOS Sierra 上使用 proxychains-ng 如果你也不想动系统，再来看看其他方法 通过配置系统环境变量，设置命令行或终端代理 这里面也有几种配置方法 单次配置，只对当前终端生效 直接在当前终端执行如下命令 12export http_proxy=http://127.0.0.1:57047export https_proxy=http://127.0.0.1:57047 更改配置文件，在所有终端生效 修改.~/bashrc或者~/.zshrc并加入如下内容 123export http_proxy=http://127.0.0.1:57047export https_proxy=http://127.0.0.1:57047 执行source ~/.bashrc 或者 source ~/.zshrc让配置在当前终端生效 重新开启新的终端配置可以生效 上面的配置方法在切换的时候还是有点慢，可以通过小脚本的方式来封装一层 修改.~/bashrc或者~/.zshrc并加入如下内容 123456789# Set Proxyfunction setproxy() &#123; export &#123;http,https,ftp&#125;_proxy=&quot;http://127.0.0.1:57047&quot;&#125;# Unset Proxyfunction unsetproxy() &#123; unset &#123;http,https,ftp&#125;_proxy&#125; 执行source ~/.bashrc 或者 source ~/.zshrc让配置在当前终端生效 这样就可以通过简单的setproxy和unsetproxy来实现代理的开和关 那么问题来了，老师，这个系统环境变量到底从哪冒出来的，为啥搞搞就好使了呢？ 系统环境变量追本溯源 从哪儿来？ 翻了Bash的文档 没找着 搜了ABS 也没搜到 找了 bash源码 里面自然也不会有 查了 linux源代码 里面当然也没有 从这篇 文章中转换了下思路 结论 这些变量都是各个应用自己实现的 比如翻了git的源代码http.c中就找到了 123456789101112131415161718192021222324/* * CURL also examines these variables as a fallback; but we need to query * them here in order to decide whether to prompt for missing password (cf. * init_curl_proxy_auth()). * * Unlike many other common environment variables, these are historically * lowercase only. It appears that CURL did not know this and implemented * only uppercase variants, which was later corrected to take both - with * the exception of http_proxy, which is lowercase only also in CURL. As * the lowercase versions are the historical quasi-standard, they take * precedence here, as in CURL. */if (!curl_http_proxy) &#123; if (http_auth.protocol &amp;&amp; !strcmp(http_auth.protocol, &quot;https&quot;)) &#123; var_override(&amp;curl_http_proxy, getenv(&quot;HTTPS_PROXY&quot;)); var_override(&amp;curl_http_proxy, getenv(&quot;https_proxy&quot;)); &#125; else &#123; var_override(&amp;curl_http_proxy, getenv(&quot;http_proxy&quot;)); &#125; if (!curl_http_proxy) &#123; var_override(&amp;curl_http_proxy, getenv(&quot;ALL_PROXY&quot;)); var_override(&amp;curl_http_proxy, getenv(&quot;all_proxy&quot;)); &#125;&#125; 翻了curl的源代码 url.c中也找到了 12345678910111213141516171819202122232425262728293031/* If proxy was not specified, we check for default proxy environment * variables, to enable i.e Lynx compliance: * * http_proxy=http://some.server.dom:port/ * https_proxy=http://some.server.dom:port/ * ftp_proxy=http://some.server.dom:port/ * no_proxy=domain1.dom,host.domain2.dom * (a comma-separated list of hosts which should * not be proxied, or an asterisk to override * all proxy variables) * all_proxy=http://some.server.dom:port/ * (seems to exist for the CERN www lib. Probably * the first to check for.) * * For compatibility, the all-uppercase versions of these variables are * checked if the lowercase versions don&#x27;t exist. */char proxy_env[128];const char *protop = conn-&gt;handler-&gt;scheme;char *envp = proxy_env;char *prox; /* Now, build &lt;protocol&gt;_proxy and check for such a one to use */while(*protop) *envp++ = (char)tolower((int)*protop++); /* append _proxy */strcpy(envp, &quot;_proxy&quot;); /* read the protocol proxy: */prox = curl_getenv(proxy_env); 引出来的结论 参考资料 Linux 内核源代码 GNU Bash Bash 参考手册 Advanced Bash-Scripting Guide Linux Proxy Server Settings – Set Proxy For Command Line Bash configure proxy for corporate network Proxy server 命令行配置代理服务器 让终端走代理的几种方法 Mac OSX终端走shadowsocks代理 Linux bash终端设置代理（proxy）访问 Bash Script - Setting Local Environment Variables (Proxy) How to configure proxy settings on Ubuntu 18.04 how to configure proxy server in linux Are HTTP_PROXY, HTTPS_PROXY and NO_PROXY environment variables standard?","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://rawbin-.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"软件开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"软件开发/Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"命令行配置","slug":"命令行配置","permalink":"http://rawbin-.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE/"},{"name":"命令行代理","slug":"命令行代理","permalink":"http://rawbin-.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86/"},{"name":"终端代理","slug":"终端代理","permalink":"http://rawbin-.github.io/tags/%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86/"}]},{"title":"Android 制作第三方包","slug":"dev-env/2017-12-06-android-3rd-jars","date":"2021-12-31T02:37:59.940Z","updated":"2021-12-31T02:37:59.940Z","comments":true,"path":"dev-env/2017-12-06-android-3rd-jars/","link":"","permalink":"http://rawbin-.github.io/dev-env/2017-12-06-android-3rd-jars/","excerpt":"","text":"参考资料Android Studio Android 简介 探索 Android Studio 压缩代码和资源 Android Studio如何引用so、arr、jar包 Gradle打包 Java Gradle入门指南之插件管理（类型、导入及java plugin使用） Java Gradle入门指南之依赖管理（添加依赖、仓库、版本冲突） 可能是最通用全面的Android studio打包jar方法 Android项目实战（二十四）：项目包成jar文件，并且将工程中引用的jar一起打入新的jar文件中 Android studio 将 Module 打包成 Jar 包 android studio 将引用第三方jar和.so的项目打包jar并混淆 gradle shadow 插件 利用gradle shadowjar构建包含依赖的JAR包 通用 Gradle打包混淆Jar, 合并第三方引用的Jar (Gradle 3.0) ProGuard代码混淆 (通用)Android App代码混淆终极解决方案 Android开发之代码混淆 ProGuard Manual 同步到iOS 平台 Java to Object-C 语言文档 Groovy Gradle","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"Android开发","slug":"Web开发/Android开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/Android%E5%BC%80%E5%8F%91/"},{"name":"移动端开发","slug":"Web开发/Android开发/移动端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/Android%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://rawbin-.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://rawbin-.github.io/tags/Java/"},{"name":"第三方包","slug":"第三方包","permalink":"http://rawbin-.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/"}]},{"title":"Vue源码和配置相关实战","slug":"framework/vue/2017-12-06-vue-dev-practice","date":"2021-12-31T02:37:59.940Z","updated":"2021-12-31T02:37:59.940Z","comments":true,"path":"framework/vue/2017-12-06-vue-dev-practice/","link":"","permalink":"http://rawbin-.github.io/framework/vue/2017-12-06-vue-dev-practice/","excerpt":"","text":"参考资料Vue源码分析 Vue.js源码分析 Vue技术内幕 Vue.js 技术揭秘 Vue Router源码分析 整体流程 Vue实战小集合 Vue.js2.0源码图文剖析(1)–观察者系统 vue2源码框架和流程分析 Vue Router Hisory相关配置 HTML5 History 模式 多项目vue-router去掉# vue路由history模式刷新404问题解决方案 Vue路由History mode模式中页面无法渲染的原因及解决 vue,一路走来（11）–HTML5 History模式 vue-router开启HTML5的history模式后nginx配置 VUE路由history模式坑记–NGINX vue history 模式nginx配置及配置后刷新 404 的解决办法! 在nginx上部署vue项目(history模式)的方法 Vue 资源路径写法 处理静态资源 引用静态资源 处理资源路径 Handling Static Assets Vue Component Spec sass-loader App Handling Assets Vue打包项目图片等静态资源的处理 Vue.js中的图片引用路径 Webpack+Vue2.0工程图片路径问题 vue webpack打包后.css文件里面的背景图片路径错误解决方法 webpack+vue中使用别名路径引用静态图片地址 webpack vue 项目打包生成的文件,资源文件报404问题的修复方法(总结篇) 深层作用选择器 Scoped CSS 资源打包模板 HTML 和静态资源 html-webpack-plugin html-webpack-plugin详解 lodash template","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://rawbin-.github.io/tags/Vue/"},{"name":"Vue Router","slug":"Vue-Router","permalink":"http://rawbin-.github.io/tags/Vue-Router/"},{"name":"Vuex","slug":"Vuex","permalink":"http://rawbin-.github.io/tags/Vuex/"}]},{"title":"微前端相关参考","slug":"architecture/2017-11-07-micro-frontend","date":"2021-12-31T02:37:59.939Z","updated":"2021-12-31T02:37:59.939Z","comments":true,"path":"architecture/2017-11-07-micro-frontend/","link":"","permalink":"http://rawbin-.github.io/architecture/2017-11-07-micro-frontend/","excerpt":"","text":"框架 single-spa 参考资料 micro frontends 微前端的那些事儿 微前端 - 将微服务理念延伸到前端开发中 微前端 - 将微服务理念延伸到前端开发中 图 用微前端的方式搭建类单页应用 微前端的设计理念与实践初探 微前端的那些事儿 如何实现前端微服务化？ 实施前端微服务化的六七种方式 用微前端的方式搭建类单页应用 用微前端的方式搭建类单页应用 「微前端」- 将微服务理念扩展到前端开发（理论篇） 「微前端」- 将微服务理念扩展到前端开发（实践篇） 「微前端」- 将微服务理念扩展到前端开发（理论篇） 「微前端」- 将微服务理念扩展到前端开发（实战篇） 微前端架构选型指南 微前端架构选型指南 微前端与大前端","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"微前端","slug":"微前端","permalink":"http://rawbin-.github.io/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"前端架构","slug":"前端架构","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"}]},{"title":"前端综合参考","slug":"dev-general/2017-11-07-fe-ref","date":"2021-12-31T02:37:59.939Z","updated":"2021-12-31T02:37:59.939Z","comments":true,"path":"dev-general/2017-11-07-fe-ref/","link":"","permalink":"http://rawbin-.github.io/dev-general/2017-11-07-fe-ref/","excerpt":"","text":"参考资料 年终回顾，为你汇总一份「前端技术清单」 前端进阶 The whole web at maximum FPS: How WebRender gets rid of jank 大前端的技术原理和变迁史 大前端方向技术规划 网站性能调优开发工具: Lighthouse, Puppeteer 以及进阶部分丨 Google 开发者大会 2018 腾讯发布前端组件框架 Omi，全面拥抱 Web Components","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"微前端","slug":"微前端","permalink":"http://rawbin-.github.io/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"前端架构","slug":"前端架构","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"}]},{"title":"搭建npm 私有源，私有npm仓库","slug":"dev-env/2017-11-15-npm-registry","date":"2021-12-31T02:37:59.939Z","updated":"2021-12-31T02:37:59.939Z","comments":true,"path":"dev-env/2017-11-15-npm-registry/","link":"","permalink":"http://rawbin-.github.io/dev-env/2017-11-15-npm-registry/","excerpt":"","text":"在github 上搜索private npm, 并将排序改为recently updated或者其他想要的结果 cnpmjs verdaccio 参考资料 private npm npm私有仓库搭建 搭建NPM私有库 团队需要一个私有npm 使用verdaccio搭建npm私有仓库","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://rawbin-.github.io/tags/npm/"},{"name":"cnpm","slug":"cnpm","permalink":"http://rawbin-.github.io/tags/cnpm/"},{"name":"sinppia","slug":"sinppia","permalink":"http://rawbin-.github.io/tags/sinppia/"},{"name":"npm私有仓库","slug":"npm私有仓库","permalink":"http://rawbin-.github.io/tags/npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"},{"name":"npm私有源","slug":"npm私有源","permalink":"http://rawbin-.github.io/tags/npm%E7%A7%81%E6%9C%89%E6%BA%90/"}]},{"title":"Web前端性能监控参考","slug":"performance/2017-10-31-web-log-monitor-ref","date":"2021-12-31T02:37:59.939Z","updated":"2021-12-31T02:37:59.939Z","comments":true,"path":"performance/2017-10-31-web-log-monitor-ref/","link":"","permalink":"http://rawbin-.github.io/performance/2017-10-31-web-log-monitor-ref/","excerpt":"","text":"参考资料 别再让你的web页面在用户浏览器端裸奔 阿里云前端监控 网站统计中的数据收集原理及实现 你是如何搭建 Web 前端性能监控系统的？ 开发完第一版前端性能监控系统后的总结 Performance — 前端性能监控利器 前端性能-监控起步 7 天打造前端性能监控系统 网站数据统计分析之一：日志收集原理及其实现 网站数据统计分析之一：日志收集原理及其实现 如何优雅地上报前端监控日志 【数据可视化之采集】如何设计一个前端监控系统","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"Vue","slug":"Vue","permalink":"http://rawbin-.github.io/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"http://rawbin-.github.io/tags/Webpack/"}]},{"title":"Web应用安全评估与问题解决过程","slug":"security/2017-11-15-web-security-assess","date":"2021-12-31T02:37:59.939Z","updated":"2021-12-31T02:37:59.939Z","comments":true,"path":"security/2017-11-15-web-security-assess/","link":"","permalink":"http://rawbin-.github.io/security/2017-11-15-web-security-assess/","excerpt":"","text":"Web安全参考 综述 《Web之困：现代Web应用安全指南》 《Web应用安全权威指南》 《揭秘Web应用程序攻击技术》 《黑客大曝光：Web应用安全机密与解决方案》 《黑客大曝光Web应用程序安全》 总结结论 《Web安全开发指南》 《Web应用安全威胁与防治：基于OWASP TOP 10与ESAPI》 工具 《Web安全深度剖析》 《黑客攻防 Web安全实战详解》 字符编码 《Web应用安全权威指南》 浏览器安全 《Web之困：现代Web应用安全指南》 《黑客攻防技术宝典：浏览器实战篇》 身份认证 《Web应用漏洞侦测与防御：揭秘鲜为人知的攻击手段和防御技术》 《Web应用安全威胁与防治：基于OWASP TOP 10与ESAPI》 《黑客攻防技术宝典：Web实战篇》 Cookie欺骗 《黑客Web脚本攻击与防御技术核心剖析]》 《反黑风暴 网络渗透技术攻防高手修炼》 注入攻击 《Web应用漏洞侦测与防御：揭秘鲜为人知的攻击手段和防御技术》 《Web应用安全威胁与防治：基于OWASP TOP 10与ESAPI》 《Web安全深度剖析》 《SQL注入攻击与防御》 《黑客攻防技术宝典：Web实战篇》 《白帽子讲Web安全》 XSS 《XSS跨站脚本攻击与防御》 《Web应用安全威胁与防治：基于OWASP TOP 10与ESAPI》 《Web安全深度剖析》 《黑客攻防技术宝典：Web实战篇》 《白帽子讲Web安全》 《黑客Web脚本攻击与防御技术核心剖析]》 CSRF 《Web应用漏洞侦测与防御：揭秘鲜为人知的攻击手段和防御技术》 《Web应用安全威胁与防治：基于OWASP TOP 10与ESAPI》 《Web安全深度剖析》 《白帽子讲Web安全》","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"Web安全","slug":"前端开发/Web开发/Web安全","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://rawbin-.github.io/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"CSRF","slug":"CSRF","permalink":"http://rawbin-.github.io/tags/CSRF/"},{"name":"XSS","slug":"XSS","permalink":"http://rawbin-.github.io/tags/XSS/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://rawbin-.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"前端安全","slug":"前端安全","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"}]},{"title":"JavaScript中的金额（钱）数据处理，始终保留两位小数","slug":"language/ecma-javascript/2017-11-20-js-number-fixed","date":"2021-12-31T02:37:59.939Z","updated":"2021-12-31T02:37:59.940Z","comments":true,"path":"language/ecma-javascript/2017-11-20-js-number-fixed/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2017-11-20-js-number-fixed/","excerpt":"","text":"JavaScript保留两位有效数字问题一 舍入规则不统一12345678const floatNumbers = [0.015,0.025,0.035,0.045,0.055,0.065,0.075,0.085,0.095];const addOne = item =&gt; item + 1;const printToFixed2 = item =&gt; &#123; console.log(item,&#x27;.toFixed(2) //&#x27;,item.toFixed(2))&#125;;floatNumbers.map(printToFixed2);floatNumbers.map(addOne).map(printToFixed2) 在Chrome 71 中运行的结果 和 Firefox 63 中结果一样，如下 1234567891011121314151617180.015.toFixed(2) // &quot;0.01&quot;0.025.toFixed(2) // &quot;0.03&quot;0.035.toFixed(2) // &quot;0.04&quot;0.045.toFixed(2) // &quot;0.04&quot;0.055.toFixed(2) // &quot;0.06&quot;0.065.toFixed(2) // &quot;0.07&quot;0.075.toFixed(2) // &quot;0.07&quot;0.085.toFixed(2) // &quot;0.09&quot;0.095.toFixed(2) // &quot;0.10&quot;1.015.toFixed(2) // &quot;1.01&quot;1.025.toFixed(2) // &quot;1.02&quot;1.035.toFixed(2) // &quot;1.03&quot;1.045.toFixed(2) // &quot;1.04&quot;1.055.toFixed(2) // &quot;1.05&quot;1.065.toFixed(2) // &quot;1.06&quot;1.075.toFixed(2) // &quot;1.07&quot;1.085.toFixed(2) // &quot;1.08&quot;1.095.toFixed(2) // &quot;1.09&quot; 这个结果跟咱们平常理解的四舍五入不一样（0.015，0.025的舍入方法不一样），跟银行家舍入法也不一样(0.035，0.045的舍入值一样) 问题二 二进制小数本身就是一个坑（特性） 计算 28908.75 * 2.82 列竖式算 得到的结果是 81522.6750，四舍五入保留两位小数得到 81522.68 用程序算( python, node,js) 得到的结果是 81522.67499999999, 四舍五入保留两位小数得到 81522.67 寻求解决办法 片面的办法很容易出来，比如这个, 一顿牛逼的操作，把问题一中的问题直接片杀，但问题二却无动于衷 也可以暴力直接按照我们想要的结果直接重写 亦或是直接通过放大的方式转成整数来处理，规避这个问题 但我们终究还是想前前后后说个清楚，知其所以然 追本溯源必要的内容 先上点理论 IEEE 754 图解：JavaScript中Number的一些表示上/下限 Number.prototype.toFixed Math.round 再上个工具 VisualNumeric64 参考 《深入理解计算机系统》第三版 关于信息的表示和处理 浮点数理论 跟浮点相对应的事定点，定点表示的小数点固定在最低位的右边 浮点数：二进制小数点不固定的表达数的方式 对实数采用规格化形式的标准科学计数法优点：简化了浮点数的数据交换；简化了浮点算术算法；提高了用一个字存储的数的精度，因为无用的前导零可能占用的位被二进制小数点右边的有效位替代了 浮点数内容 符号位 放在最高位，便于比较大小，0正、1负 尾数 位于浮点数的尾数字段，其值在0到1之间 指数 位于浮点数的指数字段，表示小数点的位置；指数的底或者基是隐含的 特殊的位模式表示的特殊值，运算过程加减法比乘除法更复杂《计算机组成与体系结构性能设计》 32位表示的范围-(2-2^-23)* 2^128 和 -2^-127之间的负数, 2^-127和(2-2^-23)*2^128之间的正数 不是补码的形式？ 浮点表示的数不想定点那样沿数轴均匀分布，浮点数越靠近原点数越密集，越远离原点，数越稀疏？ 浮点数表示的问题 溢出 又分为阶值上下溢和有效值上下溢 溢出（上溢）数值太大，正的指数太大而导致指数域表示不了的情况 溢出（下溢）数值太小，负的指数太大而导致指数域表示不了的情况 为了解决浮点数的溢出问题，采用更大的指数表示方式 单精度 浮点数由一个32位的字表示 双精度 浮点数由两个32位的字表示 不够精确 整数可以精确表示，浮点数只能表示无法表示的小数的近似值 为了让表示的值最接近，中间结果的计算增加了两位，需要硬件支持 保护位 在浮点数中间计算中，在右边多保留的两位中的首位；用于提高舍入精度 舍入位 在浮点数中间计算中，在游标多保留的两位中的第二位；使浮点中间结果满足浮点格式得到最接近的数 粘贴位 用来区分舍入位右边的数据是否非零，如果非零，这一位为1 算术逻辑单元的寄存器的位数宽度是包含了保护位的宽度的，溢出的位数也能有地方放 IEEE 754提供了几种舍入模型 总是向上舍入 总是向下舍入 截断舍入 向最近的偶数舍入（粘贴位） 给出了当数值在中间的时候的舍入方式，美国国税局（IRS）总是将0.5向上舍入，也就是我们的四舍五入。比四舍五入更公平的舍入方式是当值为0.5的时候，有一半的时间向上舍入，一半的时间向下舍入。IEEE 754中如果最后一位是奇数就加1，如果偶数就截去。 比如超出可保存23位的多余位为10010，则多余位的值超过了最低可表示位值的一半，这种情况下，正确的答案是最低可表示位加1，即入到可表示的数；现在考虑多余位是01111，这种情况多余位的值小于最低可表示位值的一半，正确的答案是简单去掉多余位（截断）。对于多余位10000这种特殊情况，此时结果位于两个可表示数值的严格中点，一种可选的办法是截断，这样简单；但截断的问题是给一个计算序列带来小的但可累计的偏差效应；另一种可选的办法是基于一个随机数来决定是舍还是入，于是平均而言无偏差累积效应，但无法产生一个可预期的计算结果；IEEE采取的方法是强迫结果为偶数，若计算结果是严格位于两个可表示的数的正中间，则当结果的最低可表示位是1时，结果向上入，当最低可表示位为0时，结果向下舍； 同一个浮点数用科学计数的方式有很多种表达 规格化，让浮点数位数第一位始终是1，这样同一个数只有唯一一个表示了，同时这个1和小数点也能隐含省略掉了，规格化的过程就是将非规格化的数字中的小数点移动到最左一个1右边。 IEEE 754 隐藏了规格化二进制数的前导位1，增加了1位精度 规定指数带偏阶（偏移量）2^k-1(k为指数的位数)，单精度偏阶127，双精度偏阶1023，这样能扩大数值表示范围，比如单精度的0-128，进行移位之后能表示-127到128之间的数， IEEE 754-1985规定了浮点数的表示，IEEE 754-2008，在原来的基础上增加了 半精度（16位）和四精度（128位） 单精度格式（32位）1位符号位，8位指数位，23位有效值；双精度格式（64位）1位符号位，11位指数位，52位有效值 规定了舍入模型 规定了特殊情况及相应的处理方法，以使浮点运算能产生一致的、可预期的结果 IEEE 754是从1976年跟 8087协处理器设计同时进行的由Inter赞助的 一些特殊的实例探讨 108830.40 / 861 = 126.4 计算机算出来为126.39999999999999 28908.75 * 2.82 = 81522.6750 计算机算出来为 81522.67499999999 参考资料 《计算机组成与设计 硬件软件接口》第五版 《计算机组成与体系结构性能设计》第八版 《深入理解计算机系统》第三版 为什么(2.55).toFixed(1)等于2.5？ JS toFixed 为什么(2.55).toFixed(1)等于2.5？ 为什么0.1 + 0.2不等于0.3？ 从标准原理出发理解 JavaScript 数值精度 Number().toFixed() Rounding Errors: Broken But Fixable Rounding Numbers in JavaScript JavaScript 浮点数运算的精度问题 ROUNDING AND TRUNCATING NUMBERS IN JAVASCRIPT JavaScript Number Rounding Decimals in JavaScript Round to at most 2 decimal places (only if necessary) 如何避开JavaScript浮点数计算精度问题（如0.1+0.2!==0.3） JavaScript 格式化数字、金额、千分位、保留几位小数、舍入舍去 javaScript 中 toFixed() 精度问题及解决方案 toFixed计算错误(依赖银行家舍入法的缺陷)解决方法 Javascript中toFixed计算错误(依赖银行家舍入法的缺陷)解决方法 JavaScript 浮点数精度之谜 js浮点数精度问题的前世今生？ JS的浮点数计算精度丢失问题解决方案 JavaScript 浮点数陷阱及解法 JS四舍五入 javascript中toFixed()方法详解","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"四舍五入","slug":"四舍五入","permalink":"http://rawbin-.github.io/tags/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5/"}]},{"title":"Git 概念详解","slug":"dev-tools/git/2017-11-10-git-concept","date":"2021-12-31T02:37:59.939Z","updated":"2021-12-31T02:37:59.939Z","comments":true,"path":"dev-tools/git/2017-11-10-git-concept/","link":"","permalink":"http://rawbin-.github.io/dev-tools/git/2017-11-10-git-concept/","excerpt":"","text":"分布式版本管理系统优点 能将代码库完整地复制到本地 运行速度快 临时作业的提交易于管理 分支、合并简单方便 可以不受地点的限制进行协作开发 缺点 系统中没有真正意义上的最新版本 没有真正意义上的版本号 工作流程的配置过于灵活，易于产生混乱 思维方式的习惯需要一定的时间 Git概念 配置文件（优先级依次降低） .git/config 为特定版本库的配置文件 ~/.gitconfig 为当前用户的配置文件 --global /etc/gitconfig 为当前系统的配置文件 --system 版本库 裸版本库，没有工作目录，没有检出分支，不能用于正常开发 开发版本库，最常用的 工作中使用的是本地版本库或者当前版本库，共享和交换文件的版本库为远程版本库 分支 远程追踪分支与版本库关联，追踪远程分支中的变化refs/remotes 本地追踪分支和远程追踪分支对应，用于收集本地开发和远程追踪分支的变更 文件分类 tracked（已追踪的） ignored（被忽略的） untracked（未追踪的） 对象类型（commit可以打tag，commit包含tree，tree包含至少一个blob） blob tree commit tag 索引（index） 提交（commit） 相对提交 除了跟提交外，其他每一个提交都有至少一个父提交 使用^x来选择第x个父提交（多个父提交来源于merge）,单独的^表示父级提交 使用~来选择上一代提交，~n表示向上n代提交，单独的~表示父级提交 使用@来表示，相对的版本,比如HEAD@&#123;10&#125; 提交范围 ..表示一个范围，start..end表示start可达的但end不可达的内容（结合差）,start 和 end分别为能表示提交的标识，比如commitid 或者 相对提交等，范围的结果是前开后闭的区间，不包括start但包括end；也可以省略start或者end，省略的一方默认HEAD ...同样表示一个范围，start...end表示start和end不同时可达的内容 引用（reference）.git/refs/ 本地分支名 .git/refs/heads/ 远程跟踪分支名 .git/refs/remotes 标签名 .git/refs/tags HEAD 当前分支的最新提交 ORIG_HEAD 类似merge、reset这样的操作留下的操作前HEAD的保存 FETCH_HEAD fetch操作是获取的所有分支HEAD的列表 MERGE_HEAD merge操作时要写到HEAD里面的内容 MERGE_MSG 记录合并失败的信息 MEGE_MODE 合并标识状态 Git 操作 获得帮助 输入git 并回车，看到git相关帮助和提示 输入git help xxx来查看子命令相关的帮助 初始化仓库git init 会在当前目录下创建一个.git的目录，包含了相关的版本库相关的信息 版本库克隆 git clone clone过程原始版本库中的refs/heads下的本地分支，会成为新的克隆版本库refs/remotes下的远程跟踪分支，原始版本库中的refs/remotes下的远程分支不会克隆 refs/tags会被克隆，hooks、配置文件、reflog、stash 不会被克隆 添加跟踪 git add 删除跟踪 git rm 带跟踪的移动或者改名 git mv 切换分支、拉取文件 git checkout git checkout branch -- path/to/file 拉取branch中的文件 日志查看 git log 比较差异 git diff 单行最后一次变更查看 git blame 提交内容 git commit git commit --amend 修改最后一次提交 二分查找 git bisect 分支管理 git branch 更详细的分支信息git show-branch 展示的是二位矩阵，破折号上面表示分支的信息，破折号下面表示提交的信息 +表示当前行的提交存在于当前列的分支中 *表示存在于活动分支中的提交 -表示当前提交为一个合并提交 分支合并 git merge 冲突文件状态 git status --merge或者 git ls-files -u 重置状态 git reset --soft, index和working copy保持不变，只改变HEAD --mixed working copy 保持不变，HEAD和index改变 --hard working copy,index,HEAD都会改变 引入提交的变更 git cherry-pick git cherry-pick commitid 在当前分支引入commitid的变更 git cherry-pick start..end 新版的git中，支持引入一个范围的变更 以新的提交抵消特定提交 git revert git rebase branch 让当前分支基于最新的 branch git rebase base target 使 target 分支基于 base 分支的最新提交 临时保持状态 git stash 引用日志 git reflog 获取引用信息 git rev-parse 远程版本信息管理 git remote 抓取远程信息 git fetch 抓取远程信息并合并 git pull 推送本地信息到远程 git push 修改版本库信息 git filter-branch git rev-parse git rev-list 参考资料 Git Glossary","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://rawbin-.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"Git","permalink":"http://rawbin-.github.io/tags/Git/"}]},{"title":"Vue CLI 中 webpack 4 升级指南","slug":"dev-tools/webpack/2017-11-03-vue-webpack-upgrade","date":"2021-12-31T02:37:59.939Z","updated":"2021-12-31T02:37:59.939Z","comments":true,"path":"dev-tools/webpack/2017-11-03-vue-webpack-upgrade/","link":"","permalink":"http://rawbin-.github.io/dev-tools/webpack/2017-11-03-vue-webpack-upgrade/","excerpt":"","text":"Vue CLI webpack 2.6.1 升级 webpack 4 升级到babel 7 安装babel升级工具 npm i babel-upgrade -g 参考 在工程目录下执行 npx babel-upgrade .根据输出结果增加package.json中的内容 增加babel 配置，原有的preset废弃了，直接用 env 12345678910&#123; &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, &#123; &quot;useBuiltIns&quot;: &quot;entry&quot; &#125; ] ]&#125; 安装webpack npm i webpack@latest -D 更新html打包插件 npm i html-webpack-plugin@latest -D 解决如下异常 1TypeError: compilation.mainTemplate.applyPluginsWaterfall is not a function 更新Vue Loader npm i vue-loader@latest -D ,并通过webpack配置加载VueLoaderPlugin 123456789101112131415161718// webpack.base.config.jsconst VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;)module.exports = &#123; module: &#123; rules: [ // ... 其它规则 &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27; &#125; ] &#125;, plugins: [ // 请确保引入这个插件！ new VueLoaderPlugin() ]&#125; 解决如下异常 123TypeError: Cannot read property &#x27;vue&#x27; of undefinedvue-loader was used without the corresponding plugin. Make sure to include VueLoaderPlugin in your webpack config. 修改配置文件 webpack.dev.conf.js 增加mode=development，修改配置文件webpack.prod.conf.js 增加 mode=development 123456789const devWebpackConfig = merge(baseWebpackConfig, &#123; mode:&#x27;development&#x27;, //webpack.dev.conf.js&#125;const webpackConfig = merge(baseWebpackConfig, &#123; mode:&#x27;production&#x27;, // webpack.prod.conf.js&#125; 消除如下警告 12The &#x27;mode&#x27; option has not been set, webpack will fallback to &#x27;production&#x27; for this value. Set &#x27;mode&#x27; option to &#x27;development&#x27; or &#x27;production&#x27; to enable defaults for each environment.You can also set it to &#x27;none&#x27; to disable any default behavior. 移除 webpack.prod.conf.js中的 UglifyJsPlugin相关内容，解决如下异常 1Error: webpack.optimize.UglifyJsPlugin has been removed, please use config.optimization.minimize instead. 移除webpack.prod.conf.js中的 CommonChunkPlugin相关内容，解决如下异常 1Error: webpack.optimize.CommonsChunkPlugin has been removed, please use config.optimization.splitChunks instead. 增加webpack.optimize.CommonsChunkPlugin相关对应的配置在webpack.prod.conf.js 123456789101112131415161718192021222324252627282930mode:&#x27;production&#x27;,optimization:&#123; minimize:true, runtimeChunk:&#123; name:&#x27;manifest&#x27; &#125;, splitChunks:&#123; name:true, cacheGroups:&#123; vendor:&#123; reuseExistingChunk:true, test:function (module,chunks) &#123; // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &#x27;../node_modules&#x27;) ) === 0 ) &#125; &#125;, app:&#123; minChunks:3 &#125; &#125; &#125;, namedModules:true, namedChunks:true,&#125;, 安装 copy-webpack-plugin npm i copy-webpack-plugin@latest -D, 解决如下问题 1TypeError: compilation.contextDependencies.push is not a function 安装css提取插件 npm i mini-css-extract-plugin -D 修改配置文件webpack.prod.conf.js , 替换 extra-text-webpack-plugin, 同时更新utils.js中的内容 123456789//webpack.prod.conf.js 直接替换const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;) //utils.jsif (options.extract) &#123; return[MiniCssExtractPlugin.loader].concat(loaders)&#125; else &#123; return [&#x27;vue-style-loader&#x27;].concat(loaders)&#125; 解决如下异常 1234//webpack.prod.conf.js 直接替换const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;) //utils.js 升级webpack-dev-server npm i webpack-dev-server@latest -D，同时修改配置文件package.json，完成之后需要更新webpack.dev.conf.js修改类似的内容，删除dev-client相关内容，解决__webpack_hmr 404问题，其实不影响热更新 参考 123456789101112131415161718192021222324252627282930313233343536373839404142package.json//&quot;dev&quot;: &quot;node build/dev-server.js&quot;,&quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,//webpack.dev.conf.jsdevServer: &#123; clientLogLevel: &#x27;warning&#x27;, historyApiFallback: &#123; rewrites: [ &#123;from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, &#x27;/output/index.html&#x27;)&#125;, ], &#125;, hot: true, contentBase: false, // since we use CopyWebpackPlugin. compress: true, host: config.dev.host, port: config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123;warnings: false, errors: true&#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: config.dev.poll, &#125;, before(app) &#123; if (config.dev.withMock) &#123; app.use(mockPlugin(&#123; mockConf: &#x27;./mock/mock-conf.js&#x27; &#125;)) &#125; &#125;&#125;// add hot-reload related code to entry chunks// Object.keys(baseWebpackConfig.entry).forEach(function(name) &#123;// baseWebpackConfig.entry[name] = [&#x27;./build/dev-client&#x27;].concat(baseWebpackConfig.entry[name])// &#125;) 在webpack.base.conf.js中删除scss相关loader，解决如下异常 1Invalid CSS after &quot;...load the styles&quot;: expected 1 selector or at-rule, was &quot;var content = requi&quot; 暂时删掉webpackdashboard插件，解决dev-server 如下问题 1Worker error Error: No code sections found Vue CLI webpack 3.6.1 升级 webpack 4 升级到babel 7 安装babel升级工具 npm i babel-upgrade -g 参考 在工程目录下执行 npx babel-upgrade .根据输出结果增加package.json中的内容，并做必要的调整，比如babel-polyfill 增加babel 配置，原有的preset废弃了，直接用 env 12345678910&#123; &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, &#123; &quot;useBuiltIns&quot;: &quot;entry&quot; &#125; ] ]&#125; 安装webpack npm i webpack@latest -D 安装webpack-dev-server npm i webpack-dev-server@latest -D 安装webpack-cli npm i webpack-cli@latest -D 更新html打包插件 npm i html-webpack-plugin@latest -D 解决如下异常 1TypeError: compilation.mainTemplate.applyPluginsWaterfall is not a function 更新Vue Loader npm i vue-loader@latest -D ,并通过webpack配置加载VueLoaderPlugin 123456789101112131415161718// webpack.base.config.jsconst VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;)module.exports = &#123; module: &#123; rules: [ // ... 其它规则 &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27; &#125; ] &#125;, plugins: [ // 请确保引入这个插件！ new VueLoaderPlugin() ]&#125; 解决如下异常 123TypeError: Cannot read property &#x27;vue&#x27; of undefinedvue-loader was used without the corresponding plugin. Make sure to include VueLoaderPlugin in your webpack config. 修改配置文件 webpack.dev.conf.js 增加mode=development，修改配置文件webpack.prod.conf.js 增加 mode=development 123456789const devWebpackConfig = merge(baseWebpackConfig, &#123; mode:&#x27;development&#x27;, //webpack.dev.conf.js&#125;const webpackConfig = merge(baseWebpackConfig, &#123; mode:&#x27;production&#x27;, // webpack.prod.conf.js&#125; 消除如下警告 12The &#x27;mode&#x27; option has not been set, webpack will fallback to &#x27;production&#x27; for this value. Set &#x27;mode&#x27; option to &#x27;development&#x27; or &#x27;production&#x27; to enable defaults for each environment.You can also set it to &#x27;none&#x27; to disable any default behavior. 安装css提取插件 npm i mini-css-extract-plugin -D 修改配置文件webpack.prod.conf.js , 替换 extra-text-webpack-plugin, 同时更新utils.js中的内容以及webpack.base.conf.js 123456789101112131415//webpack.prod.conf.js 直接替换const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;) //utils.jsif (options.extract) &#123; return[MiniCssExtractPlugin.loader].concat(loaders)&#125; else &#123; return [&#x27;vue-style-loader&#x27;].concat(loaders)&#125;// webpack.base.conf.js&#123;test: /\\.scss$/,loaders: [&quot;style-loader&quot;,MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;sass-loader&quot;]&#125;, 解决如下异常 123Module build failed (from ./node_modules/mini-css-extract-plugin/dist/loader.js):ModuleParseError: Module parse failed: Unexpected character &#x27;@&#x27; (1:0)You may need an appropriate loader to handle this file type. 增加webpack.optimize.CommonsChunkPlugin相关对应的配置在webpack.prod.conf.js 123456789101112131415161718192021222324252627282930mode:&#x27;production&#x27;,optimization:&#123; minimize:true, runtimeChunk:&#123; name:&#x27;manifest&#x27; &#125;, splitChunks:&#123; name:true, cacheGroups:&#123; vendor:&#123; reuseExistingChunk:true, test:function (module,chunks) &#123; // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &#x27;../node_modules&#x27;) ) === 0 ) &#125; &#125;, app:&#123; minChunks:3 &#125; &#125; &#125;, namedModules:true, namedChunks:true,&#125;, 特别注意 babel 7 配置文件有特殊变化，node_modules中需要转码的，babel配置文件需要使用babel.config.js babel 7 支持jsx 需要升级插件版本 参考 参考 github issue 或者直接安装GitHub版本npm i https://github.com/vuejs/babel-plugin-transform-vue-jsx.git -D","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"打包工具","slug":"前端开发/打包工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"Vue","slug":"Vue","permalink":"http://rawbin-.github.io/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"http://rawbin-.github.io/tags/Webpack/"}]},{"title":"Webpack 4 配置实战疑点详解","slug":"dev-tools/webpack/2017-11-03-advanced-webpack-config","date":"2021-12-31T02:37:59.939Z","updated":"2021-12-31T02:37:59.939Z","comments":true,"path":"dev-tools/webpack/2017-11-03-advanced-webpack-config/","link":"","permalink":"http://rawbin-.github.io/dev-tools/webpack/2017-11-03-advanced-webpack-config/","excerpt":"","text":"引言本文不是一个完整的配置指南，而是在一个完整配置的基础上进行优化或者实现一些特殊需求的内容，不是一个完整的配置参考，但能给出参考入口，同时也能将文档没写清楚的内容做一下详细解释。 基本配置optimization 文档参考– webpack本身会自动对代码块进行分割，条件规则如下 新的可共享的块或者从node_modules里面来的模块 新的大约30KB（压缩前大小）的块 按需加载最大并行请求数量要求不超过5个 初始页面最大并行请求数量要求不超过3个 默认值如下 1234567891011121314151617181920212223242526module.exports = &#123; //... optimization: &#123; splitChunks: &#123; chunks: &#x27;async&#x27;, minSize: 30000, maxSize: 0, // 优先级 maxInitialRequest/maxAsyncRequests &lt; maxSize &lt; minSize minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: &#x27;~&#x27;, name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125;&#125;; optimization.runtimeChunk 可选值 true和multiple,还有 single 参考 true和multiple是一个意思， 这里需要注意下，在配置html-webpack-plugin的时候，需要配置runtime-$&#123;entry&#125; 或者是 runtime optimization.splitChunks.chunks 制定需要优化的代码块 all 同步和异步模块都进行打包优化，在所有块中共享块 async 只针对异步模块进行打包优化，在异步块中共享块 initial 只针对同步块进行打包优化，在同步块中共享块 Function , optimization.splitChunks.cacheGroups 作为代码块分组的内容，作用替代CommonsChunkPlugin,test、priority、reuseExistingChunk 只能在cacheGroups下面每个group中设置 多页打包，提取公共内容 1234567cacheGroups: &#123; commons: &#123; name: &#x27;commons&#x27;, chunks: &#x27;initial&#x27;, minChunks: 2 &#125;&#125; node_modules下面的内容单独打包 1234567cacheGroups: &#123; commons: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: &#x27;vendors&#x27;, chunks: &#x27;all&#x27; &#125;&#125; 注意事项 默认会有vendors-$&#123;entry&#125;这个注入块 vendors-$&#123;entry&#125;在配置了多个 cacheGroups的情况下，不一定会出这个注入块（有优先级、size、minChunks等条件的约束） 配置成html-webpack-plugin chunks的时候需要注意这个问题 待解决 default 控制了什么内容 webpack-dev-server 文档参考 增加一个API Mock 中间件的配置，插件源码参考, 放setup ,before配置里面都可以 123456789101112module.exports = &#123; //... devServer: &#123; setup: function(app, server) &#123; if (config.dev.withMock) &#123; app.use(mockPlugin(&#123; mockConf: &#x27;./mock/mock-conf.js&#x27; &#125;)) &#125; &#125; &#125;&#125;; host配置为0.0.0.0可以支持外部访问，比如用IP地址来访问 historyApiFallback 配置 history 模式下的路由解析 12345historyApiFallback: &#123; rewrites: [ &#123;from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, &#x27;index.html&#x27;)&#125;, ],&#125;, hot webapck-dev-server 内置了热更新，只需要配置hot=true即可，使用webpack-dev-middleware的话还需要单独配置热更新的内容 https 配置启用https，可以使用webpack-dev-server内置的证书，也可以自己提供证书 overlay 报错直接在页面上显示 123456789module.exports = &#123; //... devServer: &#123; overlay: &#123; warnings: true, errors: true &#125; &#125;&#125;; html-webpack-plugin 打包js注入模板 文档参考 默认可以解析 lodash templates, 常用的如下： 使用 &lt;%= variable %&gt; 或者 &lt;% $&#123;variable&#125; %&gt; 来展示变量值 使用&lt;%- variable %&gt; 来对变量值进行HTML转义 使用 &lt;% //js code %&gt; 来嵌入JavaScript代码 问题1，使用chunks 设置内容的时候，同样的配置在npm run dev下，会多出来一个vendors-$&#123;entry&#125;的注入项，如果chunks中没设置，会导致页面无法渲染，没有报错 原因：默认有vendors组，会将node_modules 里面的自动打包，并且根据根据entry命名 vendors-$&#123;entry&#125;类似于runtime 解决：直接不设置chunks，使用自动的配置；或者禁用vendors 组（设置cacheGroups.vendors:false）， web-webpack-plugin 针对多页打包有优化 web-webapck-plugin script-ext-html-webpack-plugin 增强的html-webpack-plugin 更多精细控制 文档参考 优化分析工具 打包时间衡量 speed-measure-webpack-plugin 打包模块依赖查看 [webpack-bundle-analyzer] 命令行看板 webpack-dashboard 增强版打包看板 jarvis 性能优化 启用babel-loader cacheDirectory 增加happypack（再Webpack4中启用babel-loader Cache后引入几乎无改善） 修改webpack.base.conf.js 将babel-loader缓存 happypack-loader 12345678910111213141516&#123; test: /\\.js$/, // loader: &#x27;babel-loader?cacheDirectory&#x27;, loader:&#x27;happypack/loader?id=babelloader&#x27;, // use: [&#123; // loader:&#x27;happypack/loader&#x27;, // options:&#123; // id:&#x27;babelloader&#x27; // &#125; // &#125;],&#125;// 增加对vue-loader的配置Object.assign(vueLoaderConfig.loaders, &#123; js: &#x27;happypack/loader?id=babelloader&#x27;,&#125;) 修改webpack.prod.conf.js 增加babel-loader 插件配置 1234new HappyPack(&#123; id:&#x27;babelloader&#x27;, loaders:[&#x27;babel-loader?cacheDirectory&#x27;]&#125;), 异常解决 Error: options/query provided without loader (use loader + options) in 将上面的改动use的写法，改成loader的写法 dll打包的方式，优化效果也不明显，使用optimization.splitChunks.cacheGroups 来优化浏览器长期缓存 参考资料 加快Vue项目的开发速度 Vue项目Webpack优化实践，构建效率提高50% Webpack4优化之路 从实践中寻找webpack4最优配置 手摸手，带你用合理的姿势使用webpack4（下） webpack SplitChunksPlugin实用指南 Webpack 4 配置最佳实践 Webpack 4 配置最佳实践 Webpack 打包优化之速度篇 vue-loader-happypack 使用happypack将vuejs项目webpack初始化构建速度提升50% React 16 加载性能优化指南 webpack4之splitChunks拆拆拆 一步一步的了解webpack4的splitChunk插件 趁webpack5还没出，先升级成webpack4吧 webpack4.0各个击破（4）—— Javascript &amp; splitChunk Webpack4之SplitChunksPlugin规则 Webpack4学习笔记（三）——代码分割（多入口） WebpackOptions.json 手摸手，带你用合理的姿势使用webpack4（上） 手摸手，带你用合理的姿势使用webpack4（上） 高性能webpack配置 chunks 详解-Webpack 4 — Mysterious SplitChunks Plugin Webpack 4 Course Code Spliting with SplitChunksPlugin webpack 4: 模式(mode)和优化项(optimization)说明","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"打包工具","slug":"前端开发/打包工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"Vue","slug":"Vue","permalink":"http://rawbin-.github.io/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"http://rawbin-.github.io/tags/Webpack/"}]},{"title":"JavaScript引擎参考","slug":"browser/2017-10-05-javascript-engine","date":"2021-12-31T02:37:59.938Z","updated":"2021-12-31T02:37:59.938Z","comments":true,"path":"browser/2017-10-05-javascript-engine/","link":"","permalink":"http://rawbin-.github.io/browser/2017-10-05-javascript-engine/","excerpt":"","text":"参考资料 [译] JavaScript 引擎基础：原型优化 【译】JavaScript的工作原理：引擎，运行时和调用堆栈的概述 【译】JavaScript的工作原理：事件循环及异步编程的出现和 5 种更好的 async/await 编程方式 【译】JavaScript的工作原理：事件循环及异步编程 【译】JavaScript的工作原理：内存管理和4种常见的内存泄漏 【译】JavaScript的工作原理：V8引擎内部+关于如何编写优化代码的5个技巧 JavaScript是如何工作的: CSS 和 JS 动画底层原理及如何优化它们的性能 [译] 通过垃圾回收机制理解 JavaScript 内存管理","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"前端框架","slug":"前端开发/Web开发/前端框架","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaScript引擎","slug":"JavaScript引擎","permalink":"http://rawbin-.github.io/tags/JavaScript%E5%BC%95%E6%93%8E/"},{"name":"V8","slug":"V8","permalink":"http://rawbin-.github.io/tags/V8/"}]},{"title":"混合开发跳转","slug":"cross-platform/2017-10-05-hybrid-jump","date":"2021-12-31T02:37:59.938Z","updated":"2021-12-31T02:37:59.938Z","comments":true,"path":"cross-platform/2017-10-05-hybrid-jump/","link":"","permalink":"http://rawbin-.github.io/cross-platform/2017-10-05-hybrid-jump/","excerpt":"","text":"参考资料 H5唤起APP指南(附开源唤端库)","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"前端框架","slug":"前端开发/Web开发/前端框架","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"混合开发","slug":"混合开发","permalink":"http://rawbin-.github.io/tags/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"},{"name":"hybrid","slug":"hybrid","permalink":"http://rawbin-.github.io/tags/hybrid/"}]},{"title":"SSO 单点登录","slug":"dev-general/2017-10-05-sso","date":"2021-12-31T02:37:59.938Z","updated":"2021-12-31T02:37:59.938Z","comments":true,"path":"dev-general/2017-10-05-sso/","link":"","permalink":"http://rawbin-.github.io/dev-general/2017-10-05-sso/","excerpt":"","text":"参考资料 前端关于单点登录的知识 前后端分离使用 Token 登录解决方案","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"前端框架","slug":"前端开发/Web开发/前端框架","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SSO","slug":"SSO","permalink":"http://rawbin-.github.io/tags/SSO/"},{"name":"单点登录","slug":"单点登录","permalink":"http://rawbin-.github.io/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"}]},{"title":"Vue Router History Mode 适配填坑实战","slug":"framework/vue/2017-10-05-vue-router-history-mode","date":"2021-12-31T02:37:59.938Z","updated":"2021-12-31T02:37:59.938Z","comments":true,"path":"framework/vue/2017-10-05-vue-router-history-mode/","link":"","permalink":"http://rawbin-.github.io/framework/vue/2017-10-05-vue-router-history-mode/","excerpt":"","text":"缘由 使用Hash Mode开发的一套大系统，完全成型 由于各种跳转的问题，nginx的转发会导致#后面的路径丢失 想试试History Mode 环境 Vue-Cli 早期版本，webpack 2.6 相关配置基础配置 将Vue Router mode设置为history,并将跳转路径中带#的hash路由改为history对应的方式 webpack-dev-middleware 不带dev-server相关内容，只处理内容的映射,需要配合connect-history-api-fallback来做，默认给了一个默认的映射，但多级路由页面刷新还是会出现404 historyApiFallback日志 配置connect-history-api-fallback 1234// handle fallback for HTML5 history httpapp.use(require(&#x27;connect-history-api-fallback&#x27;)(&#123; verbose:true //开启日志信息&#125;)) 本地路由404 即使配置了这样的情况，还是会出现路由点击跳转好使，刷新页面404的情况，原因是刷新页面的地址被proxyTable匹配到了，找去了服务端（因为ProxyMiddleware在connect-history-api-fallback中间件前面），没有走Fallback，解决办法是把所有服务相关的转发都加上api后缀或者使用connect-history-api-fallback的rewrites配置来做，前提是中间件的加载位置要在代理中间件前面。 本地图片404 原有图片是直接在Vue组件里面利用相对路径写的，对于history模式来说，总会根据当前路径加上莫须有的前缀，这里直接将所有图片路径写上绝对路径就好了 /static/xxx Web Server 路由404 将打包后的内容部署到Web Server根目录，刷新页面路由会出现404，根据Vue Router官网文档配置 Web Server即可解决相关问题，比如nginx 配置，就会再找不到的情况下转到 index.html 通过router 解析路由 123location / &#123; try_files $uri $uri/ /index.html;&#125; 然而，更多时候我们的应用不是部署在根目录的，而是在某个路径下比如 app-test，这个时候最好的方式是我们引用的资源路径都跟着走相对路径，打包出来自带光环，但看看前面图片路径的情况则不尽然。这个时候我们加载相关页面各种图片资源404，刷新页面路由会报500，上面的nginx转发规则已经不适用了。 Web Server 路由500 上面官方文档里面的nginx配置已经不适合带路径目录的项目了，需要干掉。 应用增加base /app-test/ 路由首先加上一个base ,这样路由跳转的时候才不会越界 12345export default new Router(&#123; mode:&#x27;history&#x27;, base:&#x27;/app-test/&#x27;, routes&#125;) build.assetsPublicPath 值改为 /app-test/，这样打包路径相关的资源会加上这个前缀 dev.assetsPublicPath 值改为 /app-test/，这样本地dev server 路径能跟服务端访问一致 配置本地Server 转发 12345// handle fallback for HTML5 history httpapp.use(require(&#x27;connect-history-api-fallback&#x27;)(&#123; verbose:true, index:&#x27;/app-test/index.html&#x27;,&#125;)) Vue组件模板中使用@/../static/images/xxx.png引用图片, 其中 @为src的别名 参考 vue-loader Vue组件中SCSS style 使用~/../static/images/xxx.png引用图片，其中~使后面的解析为模块路径， ~@/代表src参考 sass-loader 或者 css-loader 或者 vue cli 在 js 中使用的话，按相对于src的路径写，import或者require都ok， 对应nginx配置需要改为 123location /app-test &#123; try_files $uri $uri/ /app-test/index.html;&#125; 实例代码在 这 github 相对路径适配问题 上面增加base的情况适用于固定的部署方式，换个路径需要改代码重新打包，我们希望有一种方式自动适配路径，改到什么路径改改ng配置就行，代码不用动 首先修改config/index.js中的路径为相对路径 1234567891011121314151617181920212223@@ -9,7 +9,7 @@ module.exports = &#123; // Paths assetsSubDirectory: &#x27;static&#x27;,- assetsPublicPath: &#x27;/app-test/&#x27;,+ assetsPublicPath: &#x27;./&#x27;, proxyTable: &#123;&#125;, // Various Dev Server settings@@ -45,12 +45,12 @@ module.exports = &#123; build: &#123; // Template for index.html- index: path.resolve(__dirname, &#x27;../app-test/index.html&#x27;),+ index: path.resolve(__dirname, &#x27;../dist/index.html&#x27;), // Paths- assetsRoot: path.resolve(__dirname, &#x27;../app-test&#x27;),+ assetsRoot: path.resolve(__dirname, &#x27;../dist&#x27;), assetsSubDirectory: &#x27;static&#x27;,- assetsPublicPath: &#x27;/app-test/&#x27;,+ assetsPublicPath: &#x27;./&#x27;, 然后修改build/utils.js调整css 抽取的路径 1234567 return ExtractTextPlugin.extract(&#123; use: loaders, fallback: &#x27;vue-style-loader&#x27; fallback: &#x27;vue-style-loader&#x27;,+ publicPath:&#x27;../../&#x27; &#125;) 最后调整下src/router/index.js动态获取路由，这里面加了个标识，是为了解决目录名和路由名分不开的问题，比如/path/to/dir/dist/path/to/router, 就用中间这个dist来区分出那部分是部署的目录名哪部分是路由路径 1234567891011+const identifier = &#x27;dist/&#x27;+const getBasePath = () =&gt; &#123;+ const path = location.pathname+ return path.substr(0, path.lastIndexOf(identifier) + identifier.length)+&#125;+ export default new Router(&#123; mode: &#x27;history&#x27;,- base: &#x27;/app-test/&#x27;,+ base: getBasePath(), 参考资料 Vue history模式下配置相对路径 [ ]","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"前端框架","slug":"前端开发/Web开发/前端框架","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://rawbin-.github.io/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"http://rawbin-.github.io/tags/Webpack/"},{"name":"Cli","slug":"Cli","permalink":"http://rawbin-.github.io/tags/Cli/"}]},{"title":"Webpack4 升级相关参考","slug":"dev-tools/webpack/2017-10-05-webpack","date":"2021-12-31T02:37:59.938Z","updated":"2021-12-31T02:37:59.938Z","comments":true,"path":"dev-tools/webpack/2017-10-05-webpack/","link":"","permalink":"http://rawbin-.github.io/dev-tools/webpack/2017-10-05-webpack/","excerpt":"","text":"Vue CLI 升级参考 Webpack 4 升级全教程 vue-cli 构建 vue 升级 webpack4 基于Vue cli生成的Vue项目的webpack4升级 Vue项目升级到Webpack 4.x初步踩坑总结 vue项目升级webpack4指南 Webpack4 新特性 及 Vue-cli项目升级 多页应用 Webpack4 配置优化与踩坑记录 参考资料 webpack4.x最详细入门讲解 使用webpack4打造自己的前端工作流 Webpack4+ 多入口程序构建 Webpack 4 配置最佳实践 Webpack 4 配置最佳实践 Webpack 4 配置最佳实践 Webpack 4 和单页应用入门 Webpack 4 和单页应用入门 Webpack4 那点儿东西 vue cli 平稳升级webapck4 webpack性能优化不完全指北 vue-cli中的webpack4一步到位填坑记 基于webpack4搭建vue2、vuex多页应用 用webpack4带你实现一个vue的打包的项目 Webpack4优化之路 webpack4实操笔记 开发必备的webpack4 webpack4-用之初体验，一起敲它十一遍 webpack4初探 vue2 + koa2 + webpack4 的SSR之旅 【翻译】Webpack 4 教程：从0配置到生产模式 Webpack 4 教程：从零配置到生产发布（2018） Webpack 4 使用指南 webpack4之基础篇 Webpack 4 不完全迁移指北 Webpack4 那点儿东西 精读《webpack4.0 升级指南》 精读《webpack4.0 升级指南》 Webpack 4进阶–从前的日色变得慢 ，一下午只够打一次包","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"前端框架","slug":"前端开发/Web开发/前端框架","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"打包工具","slug":"打包工具","permalink":"http://rawbin-.github.io/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"},{"name":"Webpack","slug":"Webpack","permalink":"http://rawbin-.github.io/tags/Webpack/"}]},{"title":"EasyUI 思想、用法解析","slug":"dev-3rd-libs/2017-10-01-easyui-combo-search","date":"2021-12-31T02:37:59.937Z","updated":"2021-12-31T02:37:59.937Z","comments":true,"path":"dev-3rd-libs/2017-10-01-easyui-combo-search/","link":"","permalink":"http://rawbin-.github.io/dev-3rd-libs/2017-10-01-easyui-combo-search/","excerpt":"","text":"思路 是用jQuery插件方法，在jQuery上扩展功能，在$.fn（prototype）上增加对象方法，让选择器结果对象可使用新增方法 通过继承合并的方式，让高层组件（combotree）拥有基层组件(combo,tree)所有的属性、方法和事件的并集 过程（以$.fn.myPlugin为例） 首先是注册myPlugin插件到jQuery原型上，其实就是一个返回jQuery对象的函数 当调用的时候，会判断当前DOM对象上是否有myPlugin 的data属性，没有就初始化，并写入这个data属性，有了的话就直接调用 初始化过程 设置默认值，$.fn.myPlugin.defaults，这个我们可以在定制组件初始化之前改，来改变默认行为 初始化配置，$.fn.myPlugin.parseOptions(this) ，扫描一遍现有的元素属性配置，这也是为什么HTML里面配置了EasyUI的类，就能直接渲染对象的原因 我们配置的DOM元素没有直接被使用，而是被隐藏起来了，新的功能组件是按照对象属性配置生成的 获取文本组件对应DOM元素的方法$(selector).textbox(&#39;textbox&#39;) 获取下拉树种的文本框``$(selector).combotree(‘textbox’)` 获取下拉树种的树``$(selector).combotree(‘tree’)` 实战（给EasyUI combotree 增加模糊查询 ） 参考资料里面给了一个实现的方法，写的代码量稍大，可以更简单 实现模糊查询 首先是给文本框绑定input事件 然后是让树形结构的展示通过文本框的过滤，tree对象默认有这个过滤 filter默认值 对于多值combotree，需要切换fous时，保存并清空原值，blur时合并值并展示 12345678910function enableComboTreeSearch(selector)&#123; var $combotree = $(selector); var $textbox = $combotree.combotree(&#x27;textbox&#x27;); var $tree = $combotree.combotree(&#x27;tree&#x27;); $textbox.removeAttr(&#x27;readonly&#x27;); //让可输入 $textbox.removeAttr(&#x27;disabled&#x27;); $textbox.on(&#x27;input propertychange&#x27;,function()&#123; $tree.tree(&#x27;doFilter&#x27;,this.value); //利用默认的filter进行过滤 &#125;);&#125; 参考资料 EasyUI组件解析实现思路 combotree和combobox模糊查询","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://rawbin-.github.io/tags/jQuery/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://rawbin-.github.io/tags/EasyUI/"}]},{"title":"前端性能优化参考","slug":"performance/2017-09-11-fe-performance","date":"2021-12-31T02:37:59.937Z","updated":"2021-12-31T02:37:59.937Z","comments":true,"path":"performance/2017-09-11-fe-performance/","link":"","permalink":"http://rawbin-.github.io/performance/2017-09-11-fe-performance/","excerpt":"","text":"参考资料 前端优化 深度讲解：web前端性能优化 [译] 2019 前端性能优化年度总结 — 第一部分 浏览器渲染性能 jankFree性能优化资料 Web高性能动画 CSS性能优化 京东PLUS会员项目前端性能优化实践","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web前端","slug":"Web开发/前端开发/Web前端","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"性能","slug":"性能","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"前端页面静态资源缓存和不缓存填坑实战","slug":"protocol/2017-10-05-http-cache-practice","date":"2021-12-31T02:37:59.937Z","updated":"2021-12-31T02:37:59.937Z","comments":true,"path":"protocol/2017-10-05-http-cache-practice/","link":"","permalink":"http://rawbin-.github.io/protocol/2017-10-05-http-cache-practice/","excerpt":"","text":"缓存控制关键点HTTP协议头HTTP 1.0 协议头 Expires 绝对时间点，0或者无效时间建议解释为立即过期 If-Modified-Since 绝对时间点，GET请求中的条件过期，如果有满足条件的变更则返回新资源，否则返回304 Last-Modified 绝对时间点，上一次数据变更的时间点 Pragma ‘no-cache’，扩展字段为key=value的形式 HTTP 1.1协议头 Cache-Control public 任何缓存都能存 private 共享缓存不能存 no-cache 任何缓存都不能存 no-store 不能存相关数据 max-age=delta-seconds 保质期 ETag 实体标签名称，W/前缀表示弱校验 Expires 过期时间点 If-Modified-Since 绝对时间点，GET请求中的条件过期，如果有满足条件的变更则返回新资源，否则返回304 If-Unmodified-Sice 绝对时间点 If-Match 逗号分隔的多个EntityTag或者* If-None-Match 逗号分隔的多个EntityTag或者* Last-Modified 绝对时间点，上一次数据变更的时间点 Pragma ‘no-cache’，扩展字段为key=value的形式 HTTP缓存机制过期机制 减少网络交互次数 优先级 Cache-Control:max-age &gt; Expires，都没有的话由实现端来定 多个过期时间，Date字段最新的优先 验证机制 减少网络带宽占用 Last-Modified Dates 之后没改就不用传 Entity Tag，时间精度要求高，不便于用修改时间或者用时间有问题的场景 强验证和弱验证，有点变化就要更新的算强验证 Entity Tag本身为强验证，可以设置为弱验证 HTTP/1.1服务器 推荐的是设置一个强EntityTag 和一个Last-Modified值 HTTP/1.1客户端 有EntityTag就必须用If-Match 或者 If-None-Match去校验 只有Last-Modified就应该用If-Modified-Since 都有的话都要 参考资料 实践这一次，彻底搞懂浏览器缓存 RFC 搜 HTTP RFC 1945 HTTP 1.0 RFC 2068 HTTP 1.1 RFC 2616 HTTP 1.1 RFC 7234 HTTP Caching RFC 7540 HTTP 2","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"前端框架","slug":"前端开发/Web开发/前端框架","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"缓存","slug":"缓存","permalink":"http://rawbin-.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"HTTP","slug":"HTTP","permalink":"http://rawbin-.github.io/tags/HTTP/"}]},{"title":"浏览器缓存 HTTP缓存参考","slug":"protocol/2017-10-05-http-cache","date":"2021-12-31T02:37:59.937Z","updated":"2021-12-31T02:37:59.938Z","comments":true,"path":"protocol/2017-10-05-http-cache/","link":"","permalink":"http://rawbin-.github.io/protocol/2017-10-05-http-cache/","excerpt":"","text":"参考资料 前端优化：浏览器缓存技术介绍 实践这一次，彻底搞懂浏览器缓存 Vue SPA 项目，浏览器和 nginx 反向代理缓存问题解决实方案 浅谈浏览器http的缓存机制 HTTP 缓存的四种风味与缓存策略 HTTP缓存是如何实现 chromium源码阅读–HTTP Cache 缓存详解 缓存详解 HTTP 缓存的那些事儿 HTTP 缓存的那些事儿 浅谈浏览器http的缓存机制 大公司里怎样开发和部署前端代码？ asset pipeline cache docs 彻底弄懂HTTP缓存机制及原理 彻底弄懂HTTP缓存机制及原理 Google Developer HTTP缓存 浅谈Web缓存 HTTP缓存是如何实现 彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法 HTTP—-HTTP缓存机制 漫谈 Web 缓存 HTTP 缓存机制 – 客户端缓存","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"前端框架","slug":"前端开发/Web开发/前端框架","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"缓存","slug":"缓存","permalink":"http://rawbin-.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"HTTP","slug":"HTTP","permalink":"http://rawbin-.github.io/tags/HTTP/"}]},{"title":"Node 和 Webpack 的 require 问题","slug":"cross-platform/nodejs/2017-09-10-nodejs-webpack-require","date":"2021-12-31T02:37:59.937Z","updated":"2021-12-31T02:37:59.937Z","comments":true,"path":"cross-platform/nodejs/2017-09-10-nodejs-webpack-require/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2017-09-10-nodejs-webpack-require/","excerpt":"","text":"1 Webpack require不支持动态加载 webpack module method webpack module config and use case webpack module resolve webpack module api 2 NodeJS 模块循环依赖加载问题3 参考手册 Node 循环依赖之源码解析 Node.js 中的循环依赖 性能优化 - 查看 webpack 打包后所有的依赖关系（webpack 可视化工具） webpack analyse webpack源码分析 webpack 源码分析","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/categories/JavaScript/"},{"name":"Web开发","slug":"JavaScript/Web开发","permalink":"http://rawbin-.github.io/categories/JavaScript/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"JavaScript/Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/JavaScript/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"Webpack","slug":"Webpack","permalink":"http://rawbin-.github.io/tags/Webpack/"}]},{"title":"Vue高阶组件实践参考","slug":"framework/vue/2017-09-11-vue-hoc","date":"2021-12-31T02:37:59.937Z","updated":"2021-12-31T02:37:59.937Z","comments":true,"path":"framework/vue/2017-09-11-vue-hoc/","link":"","permalink":"http://rawbin-.github.io/framework/vue/2017-09-11-vue-hoc/","excerpt":"","text":"参考资料 探索Vue高阶组件 HOC(高阶组件)在vue中的应用 HOC(高阶组件)在vue中的应用 探索Vue高阶组件 Discussion: Best way to create a HOC Easier-to-use HOC method 为何在React中推荐使用HOC，而不是mixins来实现组件复用。但在Vue中，很少有HOC的尝试？ High-Order Components in Vue.js vue-hoc Mixins Considered Harmful","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web前端","slug":"Web开发/前端开发/Web前端","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"Web开发/前端开发/Web前端/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://rawbin-.github.io/tags/Vue/"},{"name":"HOC","slug":"HOC","permalink":"http://rawbin-.github.io/tags/HOC/"}]},{"title":"Vue工程化最佳实践","slug":"framework/vue/2017-10-03-vue-best-practice","date":"2021-12-31T02:37:59.937Z","updated":"2021-12-31T02:37:59.937Z","comments":true,"path":"framework/vue/2017-10-03-vue-best-practice/","link":"","permalink":"http://rawbin-.github.io/framework/vue/2017-10-03-vue-best-practice/","excerpt":"","text":"参考资料 Vue.js 代码优化浅谈 Webpack官方文档 webpack增量打包多页应用 Vue 2.x + Webpack 3.x + Nodejs 多页面项目框架（上篇——纯前端多页面） Vue 2.x + Webpack 3.x + Nodejs 多页面项目框架（下篇——多页面VueSSR+热更新Server） 多页为王：webpack多页应用架构专题系列 多页为王：webpack多页应用架构专题系列 vue-cli + webpack 多页面实例配置优化方法 vue多页面应用打包配置 webpack2打包vue与Boostrap并进行多页面打包以及公共js部分的提取 详解vue-cli + webpack 多页面实例配置优化方法 vue多页面开发和打包的正确姿势 vue-cli之webpack3构建全面提速优化 vue多页面开发和打包正确处理方法 使用 webpack 3 构建高性能的应用程序 webpack性能优化 详解vue-cli之webpack3构建全面提速优化 webpack 不适合多页面应用？你写的插件还不够多 使用 Webpack 打包时的 “多页” 实践 从4个方面优化你的Vue项目","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"前端框架","slug":"前端开发/Web开发/前端框架","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://rawbin-.github.io/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"http://rawbin-.github.io/tags/Webpack/"},{"name":"Mock","slug":"Mock","permalink":"http://rawbin-.github.io/tags/Mock/"},{"name":"多页打包","slug":"多页打包","permalink":"http://rawbin-.github.io/tags/%E5%A4%9A%E9%A1%B5%E6%89%93%E5%8C%85/"}]},{"title":"移动端二维码扫描实现","slug":"dev-3rd-libs/2017-09-04-qrcode-scan","date":"2021-12-31T02:37:59.936Z","updated":"2021-12-31T02:37:59.936Z","comments":true,"path":"dev-3rd-libs/2017-09-04-qrcode-scan/","link":"","permalink":"http://rawbin-.github.io/dev-3rd-libs/2017-09-04-qrcode-scan/","excerpt":"","text":"1 参考手册 二维码扫描功能如何接近微信识别率 zxing jsqrcode zbar cordova phonegap barcodescanner","categories":[{"name":"Codova","slug":"Codova","permalink":"http://rawbin-.github.io/categories/Codova/"},{"name":"Phonegap","slug":"Codova/Phonegap","permalink":"http://rawbin-.github.io/categories/Codova/Phonegap/"},{"name":"Hybrid","slug":"Codova/Phonegap/Hybrid","permalink":"http://rawbin-.github.io/categories/Codova/Phonegap/Hybrid/"},{"name":"Web开发","slug":"Codova/Phonegap/Hybrid/Web开发","permalink":"http://rawbin-.github.io/categories/Codova/Phonegap/Hybrid/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Codova/Phonegap/Hybrid/Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Codova/Phonegap/Hybrid/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Hybrid","slug":"Hybrid","permalink":"http://rawbin-.github.io/tags/Hybrid/"},{"name":"Codova","slug":"Codova","permalink":"http://rawbin-.github.io/tags/Codova/"},{"name":"Phonegap","slug":"Phonegap","permalink":"http://rawbin-.github.io/tags/Phonegap/"}]},{"title":"当我问表单校验的面试题时，我期望得到什么样的答案","slug":"dev-general/2017-09-04-interview-validation","date":"2021-12-31T02:37:59.936Z","updated":"2021-12-31T02:37:59.936Z","comments":true,"path":"dev-general/2017-09-04-interview-validation/","link":"","permalink":"http://rawbin-.github.io/dev-general/2017-09-04-interview-validation/","excerpt":"","text":"面试题校验用户名表单，长度为8-10位的数字和字母组合的字符串，用JavaScript实现一个校验函数。 1 解决过程1.1 首先确认题目需求（几乎没有人确认过，当然也没有人写对过）1.1.1 题目要求 长度8-10位 只包含数字和字母 JS校验函数 1.1.2 Tips 几乎没人确认过 没人写对过 如果这里有问题，后面肯定对不了 1.2 其次分析思路（转换为可以写代码的等价逻辑表达，也没人写对过）1.2.1 等价逻辑转换一 包含字母 包含数字 只能是数字和字母 长度8-10位 ​ 1.2.2 等价逻辑转换二 不 全为数字 不 全为字母 只能是数字和字母 长度8-10位 1.2.3 等价逻辑转换三 所有字符ASCII码在数字和字母的范围内 长度8-10位 1.2.4 Tips 即使前面需求理解清楚，这里转换不等价也得不到正确的结果 有了这里面的等价分解，最基本的TestCase也就有了，便于后面做校验 即使写不出代码来，这里能说清楚也行 说不清楚也行，需要能看到不断尝试，积极思考的过程 1.3 然后是核心代码实现（清一色的正则，我们也先说正则）1.3.1 使用零宽正向先行断言1.3.1.1 代码实现1/^(?=.*\\d.*)(?=.*[a-zA-Z].*)[0-9a-zA-Z]&#123;8,10&#125;$/.test(str) 1.3.1.2 代码解释 (?=)表达正向先行断言，满足条件的其他匹配结果才为真，即括号内的表达式匹配整个匹配结果才为真 可以出现在代码的任意位置 不占用最终的匹配宽度 这里表达既包含数字又包含字母的只包含数字和字母的8-10位的字符串 1.3.1.3 逻辑表达 包含数字 包含字母 8-10位的数字和字母的组合（全匹配） 1.3.2 使用零宽负向先行断言1.3.2.1 代码实现1/^(?!\\d+$)(?![a-zA-Z]+$)[0-9a-zA-Z]&#123;8,10&#125;$/.test(str) 1.3.2.2 代码解释 (?!) 表达负向先行断言，满足非条件的其他匹配结果才为真，即括号内的表达式不匹配整个匹配结果才为真 可以出现在代码的任意位置 不占用最终的匹配宽度 这里表达不全为数字且不全为字母的只包含数字和字母的8-10位的字符串 1.3.2.3 逻辑表达 不全为数字的（全匹配） 不全为字母的（全匹配） 8-10位的数字和字母的组合（全匹配） 1.3.2.41.3.3 如果不知道上面的方式，可以拆分一下1.3.3.1 代码实现1!/^\\d+$/.test(str) &amp;&amp; !/^[a-zA-Z]+$/.test(str) &amp;&amp; /^[0-9a-zA-Z]&#123;8,10&#125;$/.test(str) 1.3.3.2 代码解释 不解释了，直接的逻辑表达 1.3.3.3 逻辑表达 不全为数字的（全匹配） 不全为字母的（全匹配） 8-10位的数字和字母的组合（全匹配） 1.3.4 如果不知道正则怎么玩，也可以用字符判断的方式1.3.4.1 代码实现12345678910111213141516171819202122//考虑记不住ASCII码var rangeChars = &#x27;09azAZ&#x27;;var char0Code = rangeChars.charCodeAt(0),char9Code = rangeChars.charCodeAt(1),charaCode = rangeChars.charCodeAt(2),charzCode = rangeChars.charCodeAt(3),charACode = rangeChars.charCodeAt(4),charZCode = rangeChars.charCodeAt(5);Array.from(str).every(char =&gt; &#123; return &#x27;0&#x27; &lt;= char &amp;&amp; char &lt;= &#x27;9&#x27; || &#x27;a&#x27; &lt;= char &amp;&amp; char &lt;= &#x27;z&#x27; || &#x27;A&#x27; &lt;= char &amp;&amp; char &lt;= &#x27;Z&#x27; &#125;);Array.from(str).some(char =&gt; &#123; return &#x27;0&#x27; &lt;= char &amp;&amp; char &lt;= &#x27;9&#x27;&#125;);Array.from(str).some(char =&gt; &#123; return &#x27;a&#x27; &lt;= char &amp;&amp; char &lt;= &#x27;z&#x27; || &#x27;A&#x27; &lt;= char &amp;&amp; char &lt;= &#x27;Z&#x27; &#125;);8 &lt;= str.length &amp;&amp; str.length &lt;= 10 1.4 最后是结果的输出1234567891011121314export const validationUtil = &#123; isNameValid:(str) =&gt; &#123; //调用isNameValid 的同时，不应该有判断undefind,判断null的过程，表单取出来的不会有这俩值 str += &#x27;&#x27;; str = str.trim(); return str.indexOf(&#x27;_&#x27;) === -1 &amp;&amp; /\\d/.test(str) &amp;&amp; /\\w/.test(str) &amp;&amp; /^\\w&#123;8,10&#125;$/.test(str); &#125;， isNameValid2:(str) =&gt; &#123; //调用isNameValid 的同时，不应该有判断undefind,判断null的过程，表单取出来的不会有这俩值 str += &#x27;&#x27;; str = str.trim(); return /^(?!\\d+$)(?![a-zA-Z]+$)[0-9a-zA-Z]&#123;8,10&#125;$/.test(str); &#125;&#125; 2 常见问题 校验不写trim 正则不写首尾匹配 /^[0-9a-zA-Z]{8,10}$/ 作为题目结果 自己写出来的正则，自己也不知道啥意思 3 参考资料3.1 正则书籍 基础 学习正则表达式 正则表达式必知必会 神奇的匹配 进阶 精通正则表达式 正则指引 3.2 正则工具 分析调试工具 Regex Buddy, Regex Magic Match Tracer 正则表达式101 regex101 regexr 可视化分析 regulex regexper","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://rawbin-.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"校验","slug":"校验","permalink":"http://rawbin-.github.io/tags/%E6%A0%A1%E9%AA%8C/"},{"name":"面试题","slug":"面试题","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"面试","slug":"面试","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"前端工程师成长之多读好书","slug":"dev-general/2017-09-09-fe-growing-up-book","date":"2021-12-31T02:37:59.936Z","updated":"2021-12-31T02:37:59.937Z","comments":true,"path":"dev-general/2017-09-09-fe-growing-up-book/","link":"","permalink":"http://rawbin-.github.io/dev-general/2017-09-09-fe-growing-up-book/","excerpt":"","text":"1 引言乱七八糟的书看了很多，有一本讲JavaScript的印象特别深开篇说的是”JavaScript是Java的脚本语言”，但还是看完了，最后忘了书名。 下面列的这些都是看过后至少记得起书名的，也有部分是经常看的书，一起列出来，推荐给爱学习的同学。 2 前端技术2.1 综合 《现代前端技术解析》 《Web前端开发最佳实践》 《Web前端工程师修炼之道》 《编写高质量代码-Web前端开发修炼之道》 《响应式Web设计 HTML5和CSS3实战》 第二版 《响应式设计、改造与优化》 2.2 基础2.2.1 HTML &amp;&amp; HTML5 《HTML与CSS基础教程》第八版 《HTML与XHTML权威指南》第六版 《HTML5与CSS3实战指南》 《HTML5和CSS3权威指南》 《HTML5与CSS3设计模式》 2.2.2 CSS &amp;&amp; CSS3 《CSS世界》 《CSS核心技术详解》 《CSS权威指南》 第三版 《CSS设计指南》第三版 《精通CSS-高级Web标准解决方案》第二版 《图解CSS3-核心技术与案例实战》 ​ 2.2.3 JavaScript &amp;&amp; ES6+ 《看透JavaScript:原理、方法与实践》 《实战ES2015:深入现代JavaScript 应用开发》 《学习JavaScript数据结构与算法》 第二版 《ES6标准入门》第三版 《JavaScript忍者秘籍》第二版 《JavaScript学习指南》第三版 《You Don’t Know JS》《你不知道的JS》 《JavaScript权威指南》第六版 《JavaScript高级程序设计》 第三版 《JavaScript核心概念及实践》 《JavaScript面向对象编程指南》第二版 《JavaScript DOM编程艺术》第二版 《JavaScript语言精粹》 《动态函数式编程语言精髓与编程实践》 2.3 性能优化 《Web性能权威指南》 《高性能JavaScript》 《JavaScript性能优化：度量、监控与可视化》 《高性能网站建设指南》 《高性能网站建设进阶指南》 《大型网站性能监测、分析与优化》 《网站性能监测与优化》 《高效前端-Web高效编程与优化实践》 《速度与激情-以网站性能提升用户体验》 2.4 安全 《Web前端黑客技术揭秘》 《白帽子讲Web安全》 《黑客攻防技术宝典 Web实战篇》第二版 《Web应用安全威胁与防治 基于OWASP Top 10与ESAPI》 《Web之困-现代Web应用安全指南》 《Web安全开发指南》 《Web应用安全权威指南》 《黑客攻防技术宝典 浏览器实战篇》 《XSS跨站脚本攻击剖析与防御》 2.5 工程化 &amp;&amp; 自动化 《深入浅出Webpack》 《深入PostCSS Web设计》 《前端工程化体系设计与实践》 《Web前端测试与集成- Jasmine/Selenium/Protractor/Jenkins的最佳实践》 《Web前端自动化构建-Gulp、Bower和Yeoman开发指南》 2.6 协议 《Web性能权威指南》 《图解HTTP》 《HTTP权威指南》 《HTTPS权威指南》 《图解TCP-IP》 2.7 浏览器 《浏览器工作原理》 文章 《Webkit技术内幕》 2.8 架构 《JavaScript框架设计》第二版 《前端架构设计》 《JavaScript开发框架权威指南》 《大型JavaScript应用实践最佳指南》 《JavaScript框架高级编程》 《JavaScript设计模式与开发实践》 《JavaScript设计模式》 《JavaScript模式》 3 学点其他的3.1 所谓的全栈 Web开发者技能路线图 教你成为全栈工程师 《全栈增长工程师指南》 《全栈应用开发-精益实践》 《Web全栈工程师的自我修养》 《Web开发权威指南》 《JavaScript快速全栈开发》 《单页Web应用-JavaScript从前端到后端》 《全栈开发之道-MongoDB+Express+AngularJS+Node.js》 《全端Web开发-使用JavaScript和Java》 3.2 程序设计 《代码大全》第二版 《修改代码的艺术》 《重构-改善既有代码的设计》 《代码整洁之道》 3.3 计算机基础 《深入理解计算机系统》第三版 《计算机是怎样跑起来的》 《程序是怎样跑起来的》 《网络是怎样连接的》","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"全栈开发","slug":"前端开发/Web开发/全栈开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://rawbin-.github.io/tags/HTML5/"},{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://rawbin-.github.io/tags/HTML/"},{"name":"CSS3","slug":"CSS3","permalink":"http://rawbin-.github.io/tags/CSS3/"},{"name":"ES6","slug":"ES6","permalink":"http://rawbin-.github.io/tags/ES6/"}]},{"title":"IE8跨域请求中问题解决","slug":"dev-app/cors/2017-09-04-jquery-ie8-cors","date":"2021-12-31T02:37:59.936Z","updated":"2021-12-31T02:37:59.936Z","comments":true,"path":"dev-app/cors/2017-09-04-jquery-ie8-cors/","link":"","permalink":"http://rawbin-.github.io/dev-app/cors/2017-09-04-jquery-ie8-cors/","excerpt":"","text":"1 No Transport2 Access Denied3 参考手册 XDomainRequest – Restrictions, Limitations and Workarounds IE8 jQuery CORS jQuery-ajaxTransport-XDomainRequest cors with jQuery jQuery ajax问题 利用CORS实现跨域请求 IE8 With CORS xdomain ie8-9 cors polyfill jQuery IE8 CORS xdr.js xhr-xdr-adapter","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/categories/JavaScript/"},{"name":"Web开发","slug":"JavaScript/Web开发","permalink":"http://rawbin-.github.io/categories/JavaScript/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"JavaScript/Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/JavaScript/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://rawbin-.github.io/tags/jQuery/"},{"name":"IE8","slug":"IE8","permalink":"http://rawbin-.github.io/tags/IE8/"},{"name":"CORS","slug":"CORS","permalink":"http://rawbin-.github.io/tags/CORS/"}]},{"title":"页面布局 固定布局 流式布局  响应式布局 自适应布局","slug":"dev-app/2017-08-08-css-layout","date":"2021-12-31T02:37:59.935Z","updated":"2021-12-31T02:37:59.935Z","comments":true,"path":"dev-app/2017-08-08-css-layout/","link":"","permalink":"http://rawbin-.github.io/dev-app/2017-08-08-css-layout/","excerpt":"","text":"1 布局方式1.1 静态/固定布局站点使用固定的宽度（通常是像素宽度），改变浏览器的宽度或者用不同的设备上查看站点的展示效果一样，这会在小屏设备上引入横向滚动条，对移动设备体验不友好。 1.1.1 优势 设计简单，维护方便 不用考虑图片的尺寸问题 1.1.2 劣势 在大屏设备上会有大量白边 不适应不同的设备，对用户不友好，不利于搜索引擎优化 1.2 流式布局站点使用百分比宽度（或者其他相对宽度，某些内容也可以固定宽度），页面相对于不同的浏览器或者不同设备的宽度，流式适应。 1.2.1 优势 比固定宽度更友好 不同设备上展现白边较少 1.2.2 劣势 需要保证设计在不同的设备上没有问题，有时候具有挑战性 固定宽度的内容（比如图片和视频），不能根据不同对的屏幕进行适配 大屏设备上需要确保内容足够，以减少过度的白边 1.3 自适应布局针对特定的设备尺寸进行断点划分，或者针对特定的设备有不同的设计，需要针对新设备进行设计。 1.3.1 优势 根据不同的设备类型进行专门设计适配，对用户友好 移动设备可以感知用户环境 设计者可以基于智能设备的用户数据优化广告投放 1.3.2 劣势 不便于对不同的屏幕尺寸使用不同的布局，成本相对较高，每一种尺寸都是新的一套 在创建不同屏幕尺寸不同布局的时候不能覆盖所有的设备，尤其是新出来的设备 1.4 响应式布局在流式布局的基础上，针对不同宽度的设备进行不同的设计，不需要针对新设备进行设计。 1.4.1 优势 比自适应加载更快，所有设备只有一个主布局 对搜索引擎友好，容易实现 1.4.2 劣势 实现难度较高，需要一个完整的开发测试流程来保证在所有设备上好使 元素位置会移动，广告可能会丢失 下载时间较长 2 自适应布局和响应式布局区别 自适应 响应式 设备识别 使用服务端或者客户端代码来检测设备 使用媒体查询来检测设备 实现方式 提供单独的HTML或页面，使用CSS根据屏幕大小来改变内容展现 使用弹性图片和流式网格来适配图片 内容优化 内容预先选择，只有针对设备的需要的内容才会被下载 不管什么设备都会下载所有内容，不管是否需要 设备优化 使用不同的模板，针对不同的设备进行优化 对所有设备使用同一个模板 特性 使用脚本来支撑不同的设备和屏幕尺寸，检测不同的设备类型来改变站点的展现行为 包含所有的移动端和桌面浏览器支持的特性 性能 只加载用户设备需要的资源，加载较快；图片针对特定的设备分辨率优化，减少文件尺寸和加载时间 加载针对所有设备的资源，加载较慢；加载全尺寸的图片通过压缩来适配用户设备 开发 对已经存在的站点来使用可适应的模板 整个站点重建 部署 门槛较高，开发者需要扎实的JavaScript 设计和实现曲线陡峭，用户体验需要根据不同的设备定制 不需要站点重建；需要扎实的JavaScript和CSS知识；不同的设备性能表现良好 对新站点更容易实现；需要站点重建；不同设备上性能表现较差 2.1 参考资料 关于移动端适配，你必须要知道的 [【原创】移动端高清、多屏适配方案]([http://www.html-js.com/article/Mobile-terminal-H5-mobile-terminal-HD-multi-screen-adaptation-scheme%203041](http://www.html-js.com/article/Mobile-terminal-H5-mobile-terminal-HD-multi-screen-adaptation-scheme 3041)) 前端响应式布局原理与方案（详细版） CSS布局方案 前端布局基础概述 Static Fixed Adaptive Responsive区别样例 UXPin responsive vs adaptive Adaptive Web Design vs. Responsive Web Design Adaptive vs Responsive Design Web Design 101: Adaptive Vs. Responsive Design Fixed vs Fluid vs Adaptive vs Responsive Layout What’s the Difference Between Fixed, Fluid, Adaptive, and Responsive Web Design? Responsive vs. Adaptive vs. Fluid Design Adaptive vs. Responsive Web Design: Quantifying the Difference on Mobile Difference between responsive and adaptive What’s the difference between adaptive and responsive web design? Responsive Web Design Responsive design 和 Adaptive design 的区别？ 布局类型及其应用场景区别 布局类型区别 布局样例参考 布局样例参考站点 响应式和自适应区别 响应式与自适应设计:设计师的最佳选择是什么? Is adaptive better than responsive design? Responsive vs. Adaptive Design: What’s the Best Choice for Designers? Adaptive Web Design Responsive Web Design adaptive vs responsive 详解响应式布局设计 Responsive vs Adaptive Design The Pros and Cons of Adaptive Web Design difference between responsive and adaptive Responsive Web Design – What It Is And How To Use It adaptive vs responsive design What is Adaptive Design and is It Different from Responsive Design CSS布局解决方案（终结版）","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"响应式布局","slug":"响应式布局","permalink":"http://rawbin-.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"},{"name":"自适应布局","slug":"自适应布局","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"},{"name":"流式布局","slug":"流式布局","permalink":"http://rawbin-.github.io/tags/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"},{"name":"固定布局","slug":"固定布局","permalink":"http://rawbin-.github.io/tags/%E5%9B%BA%E5%AE%9A%E5%B8%83%E5%B1%80/"},{"name":"布局","slug":"布局","permalink":"http://rawbin-.github.io/tags/%E5%B8%83%E5%B1%80/"}]},{"title":"Web前端技术概览","slug":"dev-general/2017-08-07-web-fe-outline","date":"2021-12-31T02:37:59.935Z","updated":"2021-12-31T02:37:59.935Z","comments":true,"path":"dev-general/2017-08-07-web-fe-outline/","link":"","permalink":"http://rawbin-.github.io/dev-general/2017-08-07-web-fe-outline/","excerpt":"","text":"1 计算机网络历史 1969年10月29 10:30(美国西部时间)，互联网前身ARPANet(Advanced Research Project Agency) 加州大学洛杉矶分校UCLA（University of California at Los Angeles）和斯坦福大学研究院SURI（Stanford University Research Institute）的两台主机通过电话线连接，并发送“LOG”单词，LO发送完就崩溃 1983年6月23日 第一个DNS包得到正式响应（当时整个互联网是仅有几百台主机） 2 浏览器 1990年秋 浏览器雏形诞生 1990年12月25日 Web诞生，首台Web服务器通信成功 1993年3月15日 图形浏览诞生（Mosaic） 1994年 Mosaic公司创建，后来更名为Netscape 微软购买Mosaic许可证，并将源代码用在IE1.0中 3 Web标准 1991年 CERN 正式发布Web技术标准3.1 HTML 1997年 12月 1998年 4月 1999年 12月 HTML4.01 2000年 1月 XHTML 1.0基于 HTML 4.01 2001年 5月 XHTML 1.1 2011年 HTML5草案 2014年10月28日 HTML5正式版 3.2 CSS 1996年12月 CSS 1.0 1998年5月 CSS 2.0 3.3 DOM 1998年10月 DOM Level 1 2000年11月 DOM Level 2 2003年 DOM Level 3 3.4 JavaScript/ECMAScript 1997年 ECMAScript 1.0 1998年6月 ECMAScript 2.0 1999年12月 ECMAScript 3.0 2000年 ECMAScript 4.0开始酝酿 2007年10月 ECMAScript草案发布 2008年7月 由于技术委员会分歧太大，终止ECMAScript 4.0开发，将小幅更改的版本放入ECMAScript 3.1，后来改为ECMAScript 5.0 2009年12月 ECMAScript 5.0发布 2011年6月 ECMAScript 5.1发布 2013年3月 ECMAScript 6草案封版 2013年12月 ECMAScript 6草案发布 2015年6月 ECMAScript 6正式发布","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://rawbin-.github.io/tags/HTML/"}]},{"title":"前端开发标准模板","slug":"dev-env/2017-08-09-fe-dev-template","date":"2021-12-31T02:37:59.935Z","updated":"2021-12-31T02:37:59.935Z","comments":true,"path":"dev-env/2017-08-09-fe-dev-template/","link":"","permalink":"http://rawbin-.github.io/dev-env/2017-08-09-fe-dev-template/","excerpt":"","text":"1 HTML2 CSS3 JavaScript","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://rawbin-.github.io/tags/HTML/"}]},{"title":"Vue从入门到上手","slug":"framework/vue/2017-08-06-leaning-vue","date":"2021-12-31T02:37:59.935Z","updated":"2021-12-31T02:37:59.935Z","comments":true,"path":"framework/vue/2017-08-06-leaning-vue/","link":"","permalink":"http://rawbin-.github.io/framework/vue/2017-08-06-leaning-vue/","excerpt":"","text":"1 Vue 学习的内容 风格指南 组件 单文件组件 vue-loader vue-router vuex 组件组件结构1234567891011121314151617181920&#123; el:&#x27;#app&#x27;, //组件模板 template:&#x27;&#x27;, //vm的原始数据 data:&#123; &#125;, //计算属性，所有原始数据的变形，每个属性可以有getter(get)何setter(set) computed:&#123; &#125;, //组件的操作方法 methods:&#123; &#125;, components:&#123; &#125;&#125; 组件生命周期2 beforeCreated 在实例初始化完成之后，数据监测和事件监听配置之前调用 3 created 在实例创建完成后被立即调用，此时已经完成数据监测和事件监听配置，挂载还未完成，$el 还不存在 4 beforeMount 在DOM挂载之前被调用，相关的 render 函数手册被调用 5 mounted 在el 被新创建的vm.$el替换，并挂载到了实例上后调用，此时子组件不一定都挂载完成，要全部DOM Ready，需要在下一个事件循环vm.$nextTick中处理 6 beforeUpdate 在虚拟DOM重新渲染和更新之前调用，此时更改数据会被合并到一次更新中 7 updated 在本次虚拟DOM重新渲染和更新之后调用，避免在此回调中更新数据（可能导致一直渲染），可以考虑使用计算属性和 watcher 取代这里面的数据更新需求，此时子组件不一定都更新完成，要全部组件都更新完成的状态，需要在下一个事件循环 vm.$nextTick 中处理 8 beforeDestory 实例销毁之前调用，这里实例仍然可用 9 destroyed Vue实例销毁后调用，这个时候实例及其相关的属性监听器，子组件，事件监听器等都已被销毁 组件定义12345678var TestComponent = Vue.extend(&#123; template:&#x27;&#x27;， //定义组件时必须是函数 data:function()&#123; &#125;&#125;) 组件注册10 局部注册12345678910var TestComponent = Vue.extend(&#123;&#125;)var Wrapper = Vue.extend(&#123; template:` &lt;sub-component&gt;&lt;/sub-component&gt; `, components:&#123; &#x27;sub-component&#x27;:TestComponent &#125;&#125;) 11 全局注册123var TestComponent = Vue.extend(&#123;&#125;)Vue.component(&#x27;test-component&#x27;,TestComponent) 组件接收外部数据12 字符串类型1234567&lt;sub-component data-from-prop=&#x27;dataObj&#x27;&gt;&lt;/sub-component&gt;var TestComponent = Vue.extend(&#123; props:[&#x27;dataFromProp&#x27;], template:&#x27;outer data:&#123;&#123; dataFromProp &#125;&#125;&#x27;&#125;); 123456789101112131415&lt;sub-component data-from-prop=&#x27;dataObj&#x27;&gt;&lt;/sub-component&gt;var TestComponent = Vue.extend(&#123; props:&#123; dataFromProp:&#123; type:String, //[String,Number] required:true, default:function()&#123; return &#x27;&#x27; //&#123;&#125; &#125; &#125; &#125;, template:&#x27;outer data:&#123;&#123; dataFromProp &#125;&#125;&#x27;&#125;); 组件通信13 避免紧耦合 需要访问父组件和根组件的内容通过props传进来 使用自定义事件 $on,$emit .sync 绑定，$emit(‘update:xxx’) $ref属性访问 ref属性绑定的子组件 14 占位子组件 slot标签 组件实例15 组件实例结构1234567891011121314151617181920var viewModel = new Vue(&#123; el:&#x27;#app&#x27;, //vm的原始数据 data:&#123; &#125;, //计算属性，所有原始数据的变形，每个属性可以有getter(get)何setter(set) computed:&#123; &#125;, //监听自定义事件 events:&#123; &#125;, //组件的操作方法 methods:&#123; &#125;&#125;); 16 事件操作16.1 事件绑定 events属性 this.$on 方法 123456789101112var viewModel = new Vue(&#123; el:&#x27;#app&#x27;, //监听自定义事件 events:&#123; &#125;, //组件的操作方法 methods:&#123; &#125;&#125;); 16.2 事件触发 this.$emit this.$dispatch this.$broadcast 组件状态管理 store 初始化并存储所有的状态 actions 所有的操作定义和分发，调用mutation函数（传入参数）来更新store mutations 所有的状态转换 17 组件状态过滤123456789101112&#123; vuex:&#123; getters:&#123; stateA:function(state)&#123; return state &#125; &#125;, actions:&#123; &#125; &#125;&#125; 18 严格模式123new Vuex.Store(&#123; strict:true //process.NODE_ENV !== &#x27;production&#x27;&#125;); 19 中间件1234new Vuex.Store(&#123; middlewares:[testMiddleware]&#125;); 组件生命周期 初始化事件和生命周期 init 在实例开始初始化的时候调用，此时数据监测，事件绑定和Watcher都尚未初始化。 beforeCreate 在实例初始化之后，数据监测和事件配置之前调用 初始化注入和反射 created 在实例创建之后调用，此时实例已经结束解析选项，这意味着已建立：数据绑定、计算属性、方法、Watcher\\事件回调。此时还没有开始DOM编译， $el还不存在。 判断有没有el选项，再判断有没有template选项；有el直接再判断有没有template选项，没el等vm.$mount(el)调用后再判断；有template直接编译作为模板，没有就用el的outerHTML作为模板 beforeMount 在挂载开始之前被调用 ：相关的render函数首次被调用 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。 注意 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated beforeDestory 实例销毁之前调用。在这一步，实例仍然完全可用 destoryed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 工程化Webpack配置模板 webpack 基于Webpack和vue-loader的目录结构和配置，支持热部署、代码检查、测试和CSS提取 webpack-simple 基于Webpack和vue-loader的目录结构和配置 browserify 基于Browserify和vueify的结构，支持热部署、代码检查及单元测试 browserify-simple 基于Browserify和vueify的结构 simple 单个引入Vue.js的index.html页面 20 webpack 配置模板目录结构 build webpack相关配置和脚本 config 配置文件区分开发、测试和线上环境 src 源码和资源文件 static 不需要webpack处理的静态资源 test 存放测试文件 21 webpack 配置代理12345678910proxyTable:&#123; &#x27;/api&#x27;:&#123; target:&#x27;http://demo.baiwang.com&#x27;, changeOrigin:true, pathRewrite:&#123; &#x27;^/api&#x27;:&#x27;/api&#x27; &#125; &#125;&#125; 问题解决vue npm install 安装不上的问题将如下内容放入到 .bashrc中 1234export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node/export NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node/export CHROMEDRIVER_CDNURL=https://npm.taobao.org/mirrors/chromedriverexport SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass 22 参考资料 Vuex源码分析 探索Vue高阶组件 Node.js实战:使用Egg.js+Vue.js+Docker构建渐进式、可持续集成与交付应用","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"HTML5","slug":"Web开发/前端开发/JavaScript/HTML5","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/HTML5/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://rawbin-.github.io/tags/Vue/"}]},{"title":"使用Jenkins进行持续集成和自动部署","slug":"automatic/2017-08-02-jenkins-ci-auto-deploy","date":"2021-12-31T02:37:59.934Z","updated":"2021-12-31T02:37:59.934Z","comments":true,"path":"automatic/2017-08-02-jenkins-ci-auto-deploy/","link":"","permalink":"http://rawbin-.github.io/automatic/2017-08-02-jenkins-ci-auto-deploy/","excerpt":"","text":"1 Jenkins部署1.1 简单的部署过程 下载Jenkins包 配置Java环境 启动Jenkins包 CentOS下的脚本如下: 123456yum install -y wget screen javaif [ ! -f &quot;jenkins.war&quot;]; then wget http://mirrors.jenkins.io/war-stable/latest/jenkins.warfiscreen java -jar jenkins.war 1.2 简单的进入过程 打开浏览器，访问 http://192.168.1.2:8080,IP地址换成你自己的主机 进入登录界面，使用上面命令行控制台里面的密码进行登录 安装推荐的插件或者自己选择插件安装 设定管理员的账号和密码 进入Jenkins配置主界面 2 Jenkins 配置2.1 参考资料 Jenkins Gitlab持续集成打包平台搭建 Jenkins官方文档 Use Jenkins Gitlab Jenkins CI","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://rawbin-.github.io/tags/Jenkins/"},{"name":"CI","slug":"CI","permalink":"http://rawbin-.github.io/tags/CI/"},{"name":"Deploy","slug":"Deploy","permalink":"http://rawbin-.github.io/tags/Deploy/"}]},{"title":"JIRA相关概念","slug":"dev-env/2017-08-03-jira-concept","date":"2021-12-31T02:37:59.934Z","updated":"2021-12-31T02:37:59.934Z","comments":true,"path":"dev-env/2017-08-03-jira-concept/","link":"","permalink":"http://rawbin-.github.io/dev-env/2017-08-03-jira-concept/","excerpt":"","text":"1 项目归类（Project Category） 项目（Project） 2 项目（Project） 项目（Project） 3 问题类型(Issue Type) 问题类型(Issue Type) 问题类型方案(Issue Type Scheme) 4 工作流 工作流(Workflow) 工作流方案(Workflow Scheme) 5 界面(Screen) 界面(Screen) 界面方案(Screen Scheme) 问题类型界面方案(Issue Type Screen Scheme) 6 字段（Field） 自定义字段（Custom Field） 字段配置（Field Configuration） 字段配置方案（Field Configuration Scheme）","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://rawbin-.github.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"Bug管理","slug":"项目管理/Bug管理","permalink":"http://rawbin-.github.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Bug%E7%AE%A1%E7%90%86/"},{"name":"流程管理","slug":"项目管理/Bug管理/流程管理","permalink":"http://rawbin-.github.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Bug%E7%AE%A1%E7%90%86/%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"JIRA","slug":"JIRA","permalink":"http://rawbin-.github.io/tags/JIRA/"},{"name":"Confluence","slug":"Confluence","permalink":"http://rawbin-.github.io/tags/Confluence/"}]},{"title":"HTML HTML4 HTML5 简明参考手册","slug":"language/2017-07-06-html-ref-all","date":"2021-12-31T02:37:59.934Z","updated":"2021-12-31T02:37:59.934Z","comments":true,"path":"language/2017-07-06-html-ref-all/","link":"","permalink":"http://rawbin-.github.io/language/2017-07-06-html-ref-all/","excerpt":"","text":"1 参考资料 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"浏览器原理","slug":"浏览器原理","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"nginx 路径转发、反向代理配置小结","slug":"nginx/2017-08-04-nginx-transform","date":"2021-12-31T02:37:59.934Z","updated":"2021-12-31T02:37:59.935Z","comments":true,"path":"nginx/2017-08-04-nginx-transform/","link":"","permalink":"http://rawbin-.github.io/nginx/2017-08-04-nginx-transform/","excerpt":"","text":"1 基本的转发规则1.1 location 匹配之前先做uri的标准化，解码，解析相对路径和可能的压缩，以及多个斜杠处理为单斜杠 可以用正则匹配或者前缀匹配，正则匹配用~和~*表示大小写敏感和不敏感 先检查前缀匹配的，选出最长的，再检查正则的，取第一个匹配的，如果没有正则匹配的就用前缀的1.1.1 匹配优先级(更明确的结果优先) 参考 先处理直接（前缀）匹配的内容，匹配长度最长的优先作为目标配置备选 如果直接（前缀）匹配的内容 使用了 ^~ 或者 =,就直接使用匹配的配置作为目标配置 再处理正则匹配的内容，按在配置文件中出现顺序匹配，找到第一个匹配的配置是目标配置 正则没找到就用前缀匹配的配置作为目标配置 1.1.2 匹配规则 = 严格匹配，匹配上就终止搜索 ^~ 前缀匹配，优先级高于正则匹配 ~ 正则匹配，区分大小写匹配 ~*正则匹配， 不区分大小写匹配 /uri 前缀匹配，优先级在正则之后 /通用匹配 带@前缀的是一个具名location的定义，被用来作为请求重定向，不能嵌套，也不能包含嵌套的location，不能用正则 反向代理的时候，/xxx/ 会正常匹配，/xxx 会301重定向到/xxx/，如果不想这样，需要定义一个严格匹配来处理 1.2 alias 参考 用于在URL和文件系统路径之间实现映射 使用环境 location 别名路径的值可以是除了$document_root和$realpath_root中的 如果location指定了正则表达式，正则表达式需要有捕获组，同时alias中需要有对捕获组的引用 如果location匹配了别名路径的最后一段，最好用root来替代alias 1234location /i/&#123; # 不能用于含有正则表达式的location，可以使用rewrite和root组合实现 alias /path/to/images/; #/i/top.gif =&gt; /path/to/images/top.gif&#125; 1.3 root 参考 用来指定请求的文档根目录 默认值 root html 使用环境 http ,server ,location, if in location 别名路径的值可以是除了$document_root和$realpath_root中的 root只是直接将请求路径加到根路径上，如果有改动需要用alias ​ 123locateion /i/&#123; root /path/to/images/; #/i/top.gif =&gt; /path/to/images/i/top.gif&#125; 1.4 rewrite 参考 根据表达式来重定向URI，或者修改字符串 重写字符串只对相对路径有效，如果想匹配主机名，需要使用if rewrite 按照在配置文件中的出现顺序执行 以https://, http://, $scheme 开头的重写结果将直接返回给客户端 last 终止处理当前的rewrite相关指令，会对rewrite所在的server重新发起请求（容易导致死循环，所以一般在根location中或者直接在server中写rewrite推荐用last，非跟location使用break），浏览器地址不变；使用alias指令时必须使用last break 终止处理当前的rewrite块，不再匹配后面的规则，浏览器地址不变；使用proxy_pass指令时要用break;在location中的设置的break,location中后续的请求处理还会继续 redirect 临时重定向返回302， 浏览器地址会显示跳转后的URL，爬虫不会更新URL，在重写URL不是以http://,https://,$scheme开头的情况下使用。 permanent 永久重定向返回301，浏览器地址会显示跳转后的URL，爬虫会更新URL 重写参数默认会拼在替换的url后面，如果不要的话，在替换的后面加上? 正则如果带有大括号，需要将这个匹配规则放入单引号或者双引号中 1.5 if 条件 参考 变量名 false值为 空字符串或者以0开始的字符串 变量比较使用 = 或者 != * 和 ~ 表示正则表达式匹配，*表示不区分大小写，~表示不区分大小写 !* 和 !与上面两个刚好相反，表示不匹配 -f 和 !-f 用来判断文件是否存在 -d 和 !-d 用来判断目录是否存在 -e 和 !-e 用来判断文件或目录是否存在 -x 和 !-x 用来判断文件是否可执行 正则在()分组内的值可以通过$1-$99取到 1.6 try_files 路径从root 和 alias指令指定的地方找， 加一个/在后面的话可以找目录 前面都找不到就内部重定向到最后一个指定的uri 最后一个uri可以是一个命名的 @xxx的uri，也可以是 =404 这样的code 1.7 一些已知的坑（敲黑板，注意事项） rewrite 规则执行后，还会从头走一遍匹配规则（当做新请求进来吧），一不小心就写成死循环了 proxy_pass 后面不带/会拼上location匹配的路径，带上/会干掉匹配的路径 alias 后面不带/不表示目录，会直接拼上 root 后面带不带/都表示目录 rewrite URL重写的时候默认会带上查询字符串，最终URL带上？表示不拼参数 2 反向代理反向代理 proxy_pass 出现301的问题 需求 将 /apiprefix/ 反向代理到 / 下面 1234## nginx.conflocation /apiprefix/ &#123; proxy_pass http://127.0.0.1/;&#125; 现象 浏览器出现访问了/apiprefix/path/to/api然后变为/path/to/api nginx日志里面出现 /apiprefix/path/to/api 301，/path/to/api 301 的日志 解决办法 12345## nginx.conflocation /apiprefix &#123; proxy_pass http://127.0.0.1/; proxy_set_header Host $http_host;&#125; 原因分析 proxy_set_header 默认值为 $proxy_host 参考资源 nginx docs proxy_set_header proxy_pass反向代理配置中url后面加不加/的说明 nginx reverse proxy odd 301 redirect Nginx reverse proxy with 301 redirect under https nginx负载均衡（5种方式）、rewrite重写规则及多server反代配置梳理 Nginx 日志、Rewrite及403报错信息处理等","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"开发环境","slug":"Web开发/前端开发/开发环境","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://rawbin-.github.io/tags/nginx/"},{"name":"反向代理","slug":"反向代理","permalink":"http://rawbin-.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"},{"name":"静态服务器","slug":"静态服务器","permalink":"http://rawbin-.github.io/tags/%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Gulp简明参考手册","slug":"dev-tools/2017-07-05-gulp-ref-all","date":"2021-12-31T02:37:59.934Z","updated":"2021-12-31T02:37:59.934Z","comments":true,"path":"dev-tools/2017-07-05-gulp-ref-all/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2017-07-05-gulp-ref-all/","excerpt":"","text":"1 参考资料 [][7] ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"浏览器原理","slug":"浏览器原理","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"HTML5 JavaScript 图片粘贴 拖拽上传","slug":"dev-app/javascript/2017-08-01-html5-js-clipboard","date":"2021-12-31T02:37:59.934Z","updated":"2021-12-31T02:37:59.934Z","comments":true,"path":"dev-app/javascript/2017-08-01-html5-js-clipboard/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2017-08-01-html5-js-clipboard/","excerpt":"","text":"÷÷ 1 参考资料 W3C Clipboard API W3C File API pasteboard github pasteboard.co HTML5应用之文件拖拽上传 paste image into textarea Access Clipboard Images with JavaScript capture the clipboard 图片上传插件ImgUploadJS：用HTML5 File API 实现截图粘贴上传、拖拽上传 图片粘贴上传 从剪贴板粘贴文件上传 div中粘贴图片并上传服务器 div中拖拽图片文件并上传服务器 知乎回答问题编辑框用 Ctrl+V 粘贴图片是如何实现的？ ImageClipboard 剪切板粘贴上传图片功能的javascript实现 图片的粘贴上传","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"HTML5","slug":"Web开发/前端开发/JavaScript/HTML5","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/HTML5/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://rawbin-.github.io/tags/HTML5/"},{"name":"clipboard","slug":"clipboard","permalink":"http://rawbin-.github.io/tags/clipboard/"},{"name":"File API","slug":"File-API","permalink":"http://rawbin-.github.io/tags/File-API/"}]},{"title":"CSS CSS2.1 CSS3 简明参考手册","slug":"language/css/2017-07-07-css-ref-all","date":"2021-12-31T02:37:59.934Z","updated":"2021-12-31T02:37:59.934Z","comments":true,"path":"language/css/2017-07-07-css-ref-all/","link":"","permalink":"http://rawbin-.github.io/language/css/2017-07-07-css-ref-all/","excerpt":"","text":"1 参考资料 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"浏览器原理","slug":"浏览器原理","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"JavaScript ECMAScript ES6 ESNext 简明参考手册","slug":"language/ecma-javascript/2017-07-08-js-ref-all","date":"2021-12-31T02:37:59.934Z","updated":"2021-12-31T02:37:59.934Z","comments":true,"path":"language/ecma-javascript/2017-07-08-js-ref-all/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2017-07-08-js-ref-all/","excerpt":"","text":"1 参考资料 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"浏览器原理","slug":"浏览器原理","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"HTML5 JavaScript文件操作API详解","slug":"dev-app/javascript/2017-08-01-html5-js-fileapi","date":"2021-12-31T02:37:59.934Z","updated":"2021-12-31T02:37:59.934Z","comments":true,"path":"dev-app/javascript/2017-08-01-html5-js-fileapi/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2017-08-01-html5-js-fileapi/","excerpt":"","text":"1 十六进制内容查看 Sublime Text 安装 HexViewer插件 Visual Studio Code 安装 HexDump插件 VIM + xxd命令查看十六进制 123vim -b FILENAME#进入vim 界面后:%!xxd. # %代表当前文件, !表示后面的命令执行 xxd转换二进制为16进制 ​ 参考资料 W3C Clipboard API W3C File API 《HTML5和CSS3权威指南 第三版》 《JavaScript权威指南 第六版》 VIM 命令行 Wikipedia List of File Signatures File Signatures Table W3C Graphics Index W3C Graphics Home JPEG GIF PNG","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"HTML5","slug":"Web开发/前端开发/JavaScript/HTML5","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/HTML5/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://rawbin-.github.io/tags/HTML5/"},{"name":"File API","slug":"File-API","permalink":"http://rawbin-.github.io/tags/File-API/"}]},{"title":"前后端联调实践总结","slug":"dev-env/2017-07-03-fe-be-debug","date":"2021-12-31T02:37:59.933Z","updated":"2021-12-31T02:37:59.933Z","comments":true,"path":"dev-env/2017-07-03-fe-be-debug/","link":"","permalink":"http://rawbin-.github.io/dev-env/2017-07-03-fe-be-debug/","excerpt":"","text":"[TOC] 1 联调的认知和感触1.1 认知（讨论） 为什么要联调？ 联调都干些什么？ 1.2 联调的问题 联调就是后端不好好写单元测试与集成测试，让前端发请求调用以达到测试的目的；前端不好好写Mock和测试，让后端输出数据以达到测试的目的。 1.3 更正确地认识 联调是前后端一起见证靠谱的测试结果 给需求方提供一个正确的需求验证环境 尽早暴露前后端实现的问题 2 联调必备技能2.1 DNS与HOSTS DNS（Domain Name System）的认识 DNS提供将域名解析为IP 域名只是便于记忆，真正起作用的还是IP GFW作用，HOST翻墙 域名解析顺序 浏览器缓存&gt;浏览器代理&gt;HOST文件&gt;系统DNS缓存 本地DNS服务器&gt;上级DNS&gt;…&gt;顶级DNS 2.2 HOST配置的姿势 直接修改HOSTS文件 使用Chrome应用 HostAdmin App，也有Firefox插件HostAdmin 使用HOST管理工具 SwitchHosts 使用Charles/Fiddler HOST配置 使用FEKit/YKit 代理配置 Jerry Proxy 2.3 更改HOST不即时生效问题2.3.1 原因 浏览器有HOST缓存 浏览器复用了原有HOST的Socket连接 2.3.2 解决办法 重启浏览器或者打开新的浏览器 使用Charles/Fiddler等代理，避免此问题 使用Chrome工具，强行重置Socket连接 2.4 代理服务配置 Chrome浏览器代理SwitchySharp 或者 SwitchyOmega 系统代理使用Charles/Fiddler 抓取请求包 2.5 代理服务HTTPS抓包问题 打不开页面？ 需要根据Charles Help菜单中规则添加Charles根证书 某些包解不开？需要在Charles代理设置里面配置具体的解包域名 线上证书不安全？解包后再封的包跟原来的有些区别，需要单独打开对应页面进行信任 3 特定场景的调试姿势3.1 PC/Touch页面 配置前后端环境 配置HOST 直接使用浏览器及浏览器模拟器调试 如果只是前端更改，在不影响数据的情况下，可以使用线上页面调试 3.2 App页面3.2.1 真机调试 手机上安装Beta包，使用数据线连上电脑 允许调试或者开启Inspect 通过chrome://inspect 或者Safari的开发者工具进行调试 3.2.2 模拟器调试 Xcode模拟器 搞一个可以在模拟器里面跑的App 将App拖入模拟器，然后打开，用Safari开发者工具调试 3.3 微信调试 TBS Studio Android系统下基于Webview的应用调试（腾讯家的） 微信开发者工具 微信jsAPI相关调试 weinre 通用的调试工具 spy-debugger 集成了weinre，简化了配置 更多真机调试参考这里 4 如何更有效地联调4.1 明确前后端的约定 根据需求一起约定交互的内容 包括但不限于如下内容 接口名称、请求路径、请求方式 返回字段结构、对应字段名和字段类型以及字段边界值 异常情况数据约定 一份逼真的样例数据 前端可以根据这个数据造出各种数据 4.2 后端对约定的履行 根据约定实现相应的需求 使用Postman 进行接口测试 使用浏览器进行接口jsonp功能测试 4.3 前端对约定的履行 根据约定实现相应的需求 Mock数据 使用FEKit Mock数据 使用YKit Mock数据 使用Charles/Fiddler 代理接口响应 任意其他Mock，代理，转发工具获取Mock数据 通过变换Mock数据，进行功能测试 4.4 真正的联调 前端完成自测 后端完成自测 一起验证需求的实现 4.5 友情建议 远离关键路径，合理调配时间——别拖后腿 把握全局进度，提高整体效率——别浪费时间 积极沟通交流，主动推进联调——别甩锅","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"后端开发","slug":"后端开发","permalink":"http://rawbin-.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"调试","slug":"调试","permalink":"http://rawbin-.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"移动端调试","slug":"移动端调试","permalink":"http://rawbin-.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"}]},{"title":"YKit Mock 简明参考手册","slug":"dev-tools/2017-07-03-ykit-mock-ref","date":"2021-12-31T02:37:59.933Z","updated":"2021-12-31T02:37:59.933Z","comments":true,"path":"dev-tools/2017-07-03-ykit-mock-ref/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2017-07-03-ykit-mock-ref/","excerpt":"","text":"[TOC] 1 YKit Mock配置1.1 设计 使用Mockjs YKit Mock数据使用 Mockjs, 相应的Mockjs文档和示例 Mockjs的语法规范 Mockjs数据规则参考mockJSON, FEKit也使用了这个规则 1.2 YKit Mock启动方式 ykit server启动时如果配置了mock插件会自动启动mock server ykit server mock=false 方式启动可以不启动mock server 如果使用了ykit server并配置了mock，直接访问mock接口无法访问，需要先访问mock文件对应项目的某个资源，让ykit加载到对应的mock配置，这种情况会在项目上一层启动ykit server的时候出现。 1.3 YKit Mock配置文件 默认搜索项目根目录下的mock.js 或者 mock.json,推荐使用mock.js 可以自定义配置文件的路径，在YKit的配置文件ykit.js或者ykit-xxx.js中修改 123456789module.exports = &#123; plugins: [&#123; name: &#x27;mock&#x27;, options: &#123; confPath: &#x27;./tests/mockdata/mockconf.js&#x27; &#125; &#125;], // ...&#125;; ​ mock文件支持两种配置方式 FEKit原来支持的方式 key=&gt;value形式, 其中key为路径的匹配规则，value为对应的mock数据指向； pattern=&gt;respondwith形式，其中pattern为路径匹配规则,respondwith为对应的mock数据指向； 1234567module.exports = &#123; &#x27;/uri/to/api&#x27;:&#x27;relative/path/to/mock/data/file&#x27;, rules:[&#123; pattern: &quot;/uri/pattern/to/match&quot;, respondwith:&#x27;relative/path/to/mock/data/file&#x27;, &#125;]&#125; ​ YKit 增加的方式 123456789101112131415161718192021222324module.exports = [&#123; // pattern:&#x27;/api/list.json&#x27;, // responder:&#x27;./data/listData.json&#x27;&#125;, &#123; pattern: /^\\/api\\/(\\w+)\\.json.*$/, responder: &#x27;./data/$1Data.mockjson&#x27;&#125;, &#123; pattern: /^\\/api\\/(\\w+)\\.json.*$/, responder: &#x27;./data/$1Data.js&#x27;&#125;, &#123; pattern: &#x27;/api/list.json&#x27;, responder: &#123; &quot;ret&quot;: true, &quot;data&quot;: [&#123; &quot;name&quot;: &quot;Li Lei&quot;, &quot;email&quot;: &quot;lilei@test.com&quot;, &quot;registerDateTime&quot;: &quot;2020-10-01 22:11:11&quot; &#125;, &#123; &quot;name&quot;: &quot;Han Meimei&quot;, &quot;email&quot;: &quot;hanmeimei@test.com&quot;, &quot;registerDateTime&quot;: &quot;2020-10-01 22:11:11&quot; &#125;] &#125;&#125;] json文件的配置跟上面直接出的数据一样 mockjson的数据有些区别，如下 123456789101112&#123; &quot;ret|0-1&quot;:true, &quot;data|2-5&quot;:[&#123; &quot;name&quot;:&quot;@last @first&quot;, &quot;email&quot;:&quot;@email&quot;, &quot;registerDateTime&quot;: &quot;@date(&#x27;yyyy-MM-dd&#x27;) @time(&#x27;HH:mm:ss&#x27;)&quot; &#125;,&#123; &quot;name&quot;:&quot;@last @first&quot;, &quot;email&quot;:&quot;@email&quot;, &quot;registerDateTime&quot;: &quot;@date(&#x27;yyyy-MM-dd&#x27;) @time(&#x27;HH:mm:ss&#x27;)&quot; &#125;]&#125; ​ YKit对jsonp和直接函数的支持 12345678910111213141516171819202122module.exports = [&#123; pattern: &#x27;/api/list.json&#x27;, responder:function(req,res)&#123; //两个参数 //这里可以有更多其他的处理过程 res.end(JSON.stringify(&#123; &quot;ret&quot;: true, &quot;data&quot;: [&#123; &quot;name&quot;: &quot;Li Lei&quot;, &quot;email&quot;: &quot;lilei@test.com&quot;, &quot;registerDateTime&quot;: &quot;2020-10-01 22:11:11&quot; &#125;, &#123; &quot;name&quot;: &quot;Han Meimei&quot;, &quot;email&quot;: &quot;hanmeimei@test.com&quot;, &quot;registerDateTime&quot;: &quot;2020-10-01 22:11:11&quot; &#125;] &#125;)) &#125;&#125;,&#123; pattern: &#x27;/api/list.json&#x27;, responder: &#x27;./data/listData.json&#x27;, jsonp:&#x27;jsCallback&#x27; //配置callbackKey&#125;] ​ YKit Mock比 FEKit Mock强大的地方 可以支持多个工程的mock文件，fekit只能同时用一个 YKit匹配的URL支持正则匹配到数据路径，这样可以批量造数据而配置一个规则，不用一个一个配 Mockjs 比 MockJSON强大得多，支持中文mock数据，可谓青出于蓝而胜于蓝 2 YKit Proxy 配置2.1 设计 YKit Proxy 使用了蛟神写的一个牛逼的代理服务Jerry Proxy,主要功能 HOST 管理 代理服务 请求日志和断点 网络限速 2.2 YKit Proxy 代理配置2.2.1 Jerry Proxy 启动 使用sudo ykit server -x 启动带代理服务的ykit server 使用ykit server启动日志中的[JerryProxy] Available on: http://127.0.0.1:\\d+/jerry中的URL访问代理服务器的界面 2.2.2 Jerry Proxy 配置2.2.2.1 服务器组配置 这里配置环境以及每套环境对应的机器，方便在HOST管理的地方被引用到 2.2.2.2 URL MAP 请求转发的配置，支持转到本地文件，或者转发到其他页面 2.2.2.3 代理面板 配置是否使用HTTPS代理和网络限速 配置HOST分组，Jerry Proxy会为每一个发现的YKit工程新建一个对应的分组 HOST 规则的配置，参考添加规则的说明 3 代码地址 所有的代码可以在**这里**找到。 4 参考资料 YKit mock 插件源码 Mockjs github Mockjs 文档 Jerry Proxy","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"前端工程化","slug":"Web开发/前端开发/前端工程化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"开发工具","slug":"Web开发/前端开发/前端工程化/开发工具","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"YKit","slug":"YKit","permalink":"http://rawbin-.github.io/tags/YKit/"},{"name":"Mock","slug":"Mock","permalink":"http://rawbin-.github.io/tags/Mock/"},{"name":"模拟数据","slug":"模拟数据","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE/"},{"name":"测试数据","slug":"测试数据","permalink":"http://rawbin-.github.io/tags/%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/"}]},{"title":"Rollup简明参考手册","slug":"dev-tools/2017-07-02-rollup-ref-all","date":"2021-12-31T02:37:59.933Z","updated":"2021-12-31T02:37:59.933Z","comments":true,"path":"dev-tools/2017-07-02-rollup-ref-all/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2017-07-02-rollup-ref-all/","excerpt":"","text":"1 参考资料 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"浏览器原理","slug":"浏览器原理","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"YKit简明参考手册","slug":"dev-tools/2017-07-03-ykit-ref-all","date":"2021-12-31T02:37:59.933Z","updated":"2021-12-31T02:37:59.933Z","comments":true,"path":"dev-tools/2017-07-03-ykit-ref-all/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2017-07-03-ykit-ref-all/","excerpt":"","text":"1 参考资料 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"浏览器原理","slug":"浏览器原理","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"Grunt简明参考手册","slug":"dev-tools/2017-07-04-grunt-ref-all","date":"2021-12-31T02:37:59.933Z","updated":"2021-12-31T02:37:59.934Z","comments":true,"path":"dev-tools/2017-07-04-grunt-ref-all/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2017-07-04-grunt-ref-all/","excerpt":"","text":"1 参考资料 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"浏览器原理","slug":"浏览器原理","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"FEKit简明参考手册","slug":"dev-tools/fekit/2017-07-01-fekit-ref-all","date":"2021-12-31T02:37:59.933Z","updated":"2021-12-31T02:37:59.933Z","comments":true,"path":"dev-tools/fekit/2017-07-01-fekit-ref-all/","link":"","permalink":"http://rawbin-.github.io/dev-tools/fekit/2017-07-01-fekit-ref-all/","excerpt":"","text":"1 参考资料 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"浏览器原理","slug":"浏览器原理","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"YKit简明参考手册","slug":"dev-tools/webpack/2017-07-02-webpack-ref-all","date":"2021-12-31T02:37:59.933Z","updated":"2021-12-31T02:37:59.933Z","comments":true,"path":"dev-tools/webpack/2017-07-02-webpack-ref-all/","link":"","permalink":"http://rawbin-.github.io/dev-tools/webpack/2017-07-02-webpack-ref-all/","excerpt":"","text":"1 参考资料 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"浏览器原理","slug":"浏览器原理","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"深入理解JavaScript事件循环之浏览器源码分析","slug":"browser/2017-06-16-event-loop-browser","date":"2021-12-31T02:37:59.932Z","updated":"2021-12-31T02:37:59.932Z","comments":true,"path":"browser/2017-06-16-event-loop-browser/","link":"","permalink":"http://rawbin-.github.io/browser/2017-06-16-event-loop-browser/","excerpt":"","text":"1 Chrome 版本比较 Chromium 不是Chrome，但Chrome的内容基本来源于Chromium，这个是开源的版本，小时级别的更新 Canary 是试验版，翻译过来就是金丝雀，金丝雀对瓦斯等毒气很敏感，浓度稍高就会停止鸣叫甚至挂掉，金丝雀是瓦斯等毒气检测的土办法，这个场景在《寻龙诀》中黄渤的操作中也能看到。哈哈 扯远了，这个是daily build 版本。 Dev 是开发版，weekly build版本 Beta 是测试版，monthly build版本 Stable 是稳定版，不定期更新，一般也是一个月左右一次 更新频率 Chromium &gt; Chrome Canary &gt; Chrome Dev &gt; Chrome Beta &gt; Chrome Stable Chrome Dev、Chrome Beta 和 Chrome Stable三者只能同时出现一个 Chromium 、Chrome Canary 和 剩下的任意一个可共存 2 Chrome/Chromium源码获取 可以说Chromium是Chrome的开源版本，但Chrome本身不开源 从Chromium官网 点击Chromium 到Chromium首页 选择Get the Code: Checkout, Build, &amp; Run Chromium 这里我们以Mac 环境为例，介绍源码获取 我们只需要获取源码不进行编译，可以简单点，如果需要编译可以参考这里进行操作。 首先配置好梯子，编辑~/.gitconfig，配置VPN代理 1234[http]proxy = socks5://your-socks5-host:1080[https]proxy = socks5://your-socks5-host:1080 首先获取搞源码的工具（需要自带梯子），git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 编辑``~/.bashrc或者~/.zshrc` （具体看到底用的哪个，都用可以都搞上），添加上面的工具路径 1export PATH=$PATH:/path/to/depot_tools 找一个地方放Chromium的源码 12mkdir chromium &amp;&amp; cd chromiumfetch chromium --no-history 更新现有的搞出来的Chromium源码 12git rebase-updategclient sync 3 源码结构4 参考资料 Chromium 官网 Chromium 文档汇总 Chromium 设计文档 Chromium 开发者文档 Chromium 源代码结构","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"事件循环","slug":"事件循环","permalink":"http://rawbin-.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"深入理解JavaScript事件循环之结构概览","slug":"browser/2017-06-16-event-loop-overview","date":"2021-12-31T02:37:59.932Z","updated":"2021-12-31T02:37:59.932Z","comments":true,"path":"browser/2017-06-16-event-loop-overview/","link":"","permalink":"http://rawbin-.github.io/browser/2017-06-16-event-loop-overview/","excerpt":"","text":"1 引言从2007年大学课程接触JavaScript以来，到现在（2017年）已经整整十个年头了；期间处理过当时主流的浏览器的兼容，比如IE6、7、8，Opera，Firefox，Safari（那会Chrome用的还很少，少数geek同学用），一半的兼容处理靠的是搜索引擎然后甚至是复制粘贴；十年时间浏览器市场也经历了重大的变迁，Chrome、Firefox、Safari以及微软痛定思痛换了壳还换了引擎的Edge成了几大主流。JavaScript规范也从近十年前的小修小补到目前把这十年的积淀都甩了出来，从Java脚本语言（不少人这么认为吧，甚至还有书这么写的，这里纠正一下，Java和JavaScript曾经有过一些勾搭，但关系不是这样的，或者说这俩没关系）到能自己撑起一片天，现在不理解一些JavaScript核心实现机制了，都不好意思说自己是搞前端的了。 翻了五六十本（这里没写错，就是五-六-十-本）关于JavaScript的书，也没有找到一个能帮助更好理解事件循环的地方，看到的绝大多数也就是“有一个循环，有一个事件队列，循环不断地取队列里面的事件来执行”，网上也基本上千篇一律是这个说法，对于浏览器里面的事件循环，我们看完上面的说法得到的感觉是“哦，对，原来是这样啊，新技能Get”。然而放到NodeJS里面，这种说法又说不过去了。直到有一天翻到《深入浅出Node.js》，对事件循环有了更清晰的认识，逐渐摒弃阮一峰老师什么是 Event Loop？以及后来所谓的修正版JavaScript 运行机制详解：再谈Event Loop，这些还不是我想要的内容，因为没法解释process.nextTick,setImmediate,setTimeout这几个的区别。偶然的机会在NodeJS官网翻到了The Node.js Event Loop, Timers, and process.nextTick()，使用多个多不同优先级的事件队列来处理，对NodeJS的理解有了一个空前的感觉，这是这么多年来看到的这些资料里面没有过的。然后这也是更加清晰的阐述了原理，也没法解释应用中的类似Promise的异步与这些异步函数之间的优先级的问题。是时候好好捋一捋这里面的东东了。 这里准备搞的是关于整个疑问的分析思路和事件循环的源码分析，抛开源码讲原理无异于耍流氓；仗着源码胡讲原理更是害己害人，所以小生这里也是诚惶诚恐、战战兢兢、如履薄冰~~ 其实就是梳理一个思路，然后各个击破，翻翻源码，讲讲整个过程和原理，也没什么大不了的，don&#39;t panic。 HTML 规范中 定时器和事件循环 ECMAScript 规范 job，job queue 2 参考资料 《深入浅出Node.js》 Promise的队列与setTimeout的队列有何关联？ 一次弄懂Event Loop（彻底解决此类面试问题） The Node.js Event Loop, Timers, and process.nextTick() 前端基础进阶（十二）：深入核心，详解事件循环机制 总是一知半解的Event Loop 事件循环-深入理解Node.js：核心思想与源码分析 JavaScript：彻底理解同步、异步和事件循环(Event Loop) Event loop in JavaScript Promise介绍–异步篇 理解Promise简单实现的背后原理 libuv.org ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"事件循环","slug":"事件循环","permalink":"http://rawbin-.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"}]},{"title":"Web自动化之Headless Chrome开发工具库更新—更高层级的API","slug":"automatic/2017-06-14-headless-chrome-devlib2","date":"2021-12-31T02:37:59.932Z","updated":"2021-12-31T02:37:59.932Z","comments":true,"path":"automatic/2017-06-14-headless-chrome-devlib2/","link":"","permalink":"http://rawbin-.github.io/automatic/2017-06-14-headless-chrome-devlib2/","excerpt":"","text":"1 引言在 《Web自动化之Headless Chrome开发工具库》 一文中我们使用chrome-remote-interface这个ChromeDevTools协议的NodeJS实现做了一个简单的实例，并在《Web自动化之Headless Chrome编码实战》一文中使用简单封装的库做了一个获取性能参数和一个抓取搜索引擎搜索结果的示例。 我们可以看到chrome-remote-interface本身是对ChromeDevTools的一个相对底层的包装，我们在使用的过程中很少有比较贴近浏览器层面的API调用，在开发过程中对底层Websocket命令了解更多，却比如类似于PhantomJS，SlimerJS那样的API来调用，可以简单比较下ChromeDevTools Protocol API和puppeteer API的区别。 Chrome 团队专门针对这个搞了一个NodeJS库puppeteer,专门针对Headless Chrome的NodeJS 开发库。 2 问题的解决在上面示例代码抓取搜素引擎结果的例子中，需要填入搜索词，触发搜索按钮的点击操作，然后等结果返回后，抓取页面结果，这里使用的方式是setTimeout，这种方式实际应用就不太靠谱了，时间长了浪费时间效率低，时间短了拿不到数据，即使时间合适了，网络状况的变化也会变成时间长或者短的问题，针对和这个问题提了一个issue,没有什么简单快捷的好办法。直到·puppeteer·的出现，让我们可以重审这个问题(其实这几个月也出了些其他的类似的工具，参考)。 2.1 要实现的需求 打开百度首页 搜索 Web自动化 headless chrome 抓取搜索结果 在新的库下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const puppeteer = require(&#x27;puppeteer&#x27;);puppeteer.launch(&#123; headless:false&#125;).then(async browser =&gt; &#123; const page = await browser.newPage(); await page.goto(&#x27;https://www.baidu.com&#x27;); await page.evaluate(() =&gt; &#123; const inputElement = document.getElementById(&#x27;kw&#x27;); inputElement.value = &#x27;Web自动化 headless chrome&#x27;; const submitElement = document.getElementById(&#x27;su&#x27;); submitElement.click(); &#125;); // 这部分代码真正有效，但不太靠谱 // setTimeout(() =&gt; &#123; // page.evaluate(() =&gt; &#123; // let resultList = []; // const linkBlocks = document.querySelectorAll(&#x27;div.result.c-container&#x27;); // for (let block of Array.from(linkBlocks)) &#123; // let targetObj = block.querySelector(&#x27;h3&#x27;); // resultList.push(&#123; // title: targetObj.textContent, // link: targetObj.querySelector(&#x27;a&#x27;).getAttribute(&#x27;href&#x27;) // &#125;); // &#125; // return resultList; // &#125;).then((searchResult) =&gt; &#123; // console.log(searchResult) // browser.close(); // &#125;); // &#125;,3000); // 这部分代码真正靠谱 但不太有效，有异常，但异常跟站点相关。 // https://github.com/GoogleChrome/puppeteer/issues/597 // await page.waitFor(&#x27;div.result.c-container&#x27;).then(() =&gt; &#123; // page.evaluate(() =&gt; &#123; // let resultList = []; // const linkBlocks = document.querySelectorAll(&#x27;div.result.c-container&#x27;); // for (let block of Array.from(linkBlocks)) &#123; // let targetObj = block.querySelector(&#x27;h3&#x27;); // resultList.push(&#123; // title: targetObj.textContent, // link: targetObj.querySelector(&#x27;a&#x27;).getAttribute(&#x27;href&#x27;) // &#125;); // &#125; // return resultList; // &#125;).then((searchResult) =&gt; &#123; // console.log(searchResult) // browser.close(); // &#125;); // &#125;)&#125;); 实现的代码量减少了一半多，这就是高级别API带来的优势。 然而，暂时还是没有摆脱使用setTimeout这种前面谈到的不太靠谱的方式，对于可以用API操控的URL跳转，完全可以用带waitUntil的options参数的API来调用（到API文档里面去搜waitUntil）。 如下使用的例子 123456789101112131415161718192021222324252627282930313233343536373839404142const puppeteer = require(&#x27;puppeteer&#x27;);puppeteer.launch(&#123; headless:false&#125;).then(async browser =&gt; &#123; const page = await browser.newPage(); page.on(&#x27;load&#x27;,() =&gt; &#123; console.log(&#x27;load event fired&#x27;); &#125;); await page.goto(&#x27;https://dujia.qunar.com&#x27;).catch(() =&gt; &#123; &#125;); await page.evaluate(() =&gt; &#123; const inputElement = document.getElementById(&#x27;arriveSearchText&#x27;); inputElement.value = &#x27;三亚&#x27;; const submitElement = document.querySelector(&#x27;[item=&quot;commit&quot;]&#x27;); submitElement.click(); &#125;); await page.waitFor(&#x27;.dj-list-content&#x27;).then(() =&gt; &#123; page.evaluate(() =&gt; &#123; let resultList = []; const linkBlocks = document.querySelectorAll(&#x27;.unit.calendar-list-con&#x27;); for (let block of Array.from(linkBlocks)) &#123; let targetObj = block.querySelector(&#x27;.has_title_dom&#x27;); resultList.push(&#123; title: targetObj.textContent, link: targetObj.getAttribute(&#x27;href&#x27;) &#125;); &#125; return resultList; &#125;).then((searchResult) =&gt; &#123; // console.log(searchResult) // browser.close(); &#125;); &#125;)&#125;); 3 问题解决TimeoutError: Navigation Timeout Exceeded page.setDefaultTimeout Error: Protocol error (Page.setLifecycleEventsEnabled): Target closed close 前加 waitFor延时 ref 手动改改源码 [ref](https://lucifaer.com/2018/12/14/如何解决Pyppeteer的Target closed错误/) 参考文档 ChromeDevTools Protocol chrome-remote-interface puppeteer Google Puppeteer加入到headless Chrome的工具行列 Google’s Puppeteer Joins Crowd of Headless Chrome Tools","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"自动化","slug":"Web开发/前端开发/JavaScript/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Selenium","slug":"Selenium","permalink":"http://rawbin-.github.io/tags/Selenium/"},{"name":"Xvfb","slug":"Xvfb","permalink":"http://rawbin-.github.io/tags/Xvfb/"},{"name":"PhantomJS","slug":"PhantomJS","permalink":"http://rawbin-.github.io/tags/PhantomJS/"},{"name":"Headless Chrome","slug":"Headless-Chrome","permalink":"http://rawbin-.github.io/tags/Headless-Chrome/"}]},{"title":"如何自己写一个公用的NPM包","slug":"dev-env/2017-06-20-how-to-create-npm-package","date":"2021-12-31T02:37:59.932Z","updated":"2021-12-31T02:37:59.932Z","comments":true,"path":"dev-env/2017-06-20-how-to-create-npm-package/","link":"","permalink":"http://rawbin-.github.io/dev-env/2017-06-20-how-to-create-npm-package/","excerpt":"","text":"[TOC] 以markdown-clear,创建过程为例，讲解整个NPM包创建和发布流程 1 如何创建一个包1.1 创建并使用一个工程 在GitHub上新建一个仓库,其名markdown-clear clone 这个工程到本地 1.2 添加LICENCE或LICENSE文件， 说明对应的开源协议 到SPDX License List 或者Open Source Initiative，下载相应协议的模板，我们这里选用MIT 修改必要的协议时间和作者 12345678MIT LicenseCopyright (c) &lt;year&gt; &lt;copyright holders&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 1.3 添加README或者ReadMe.md或者README.md文件 说明项目的一些信息 给出详细参考资料的链接 给读者一个整体的导航内容 1.4 添加.gitignore 文件，忽略不需要提交的文件变更 可以去github gitignore 下载一个最相近的模板然后改改 可以去gitignore.io生成一个,然后把内容拿下了 可以参考gitignore.io 文档，自己配命令行工具，以便随时可以玩 我们这里生成了一个Node + IntellJ-all 的结果 内容语法参考gitignore doc 1.5 初始化NPM包 使用npm init 初始化工程 按照提示填入相应的内容 1.6 到这里的目录结构 工程三大件以及npm包配置文件都有了 12345markdown-clear------------- .gitignore------------- LICENCE------------- README.md------------- package.json 1.7 EditorConfig跨编辑器的编辑器设置，网站挂了，EditorConfig 1.8 ESLint新一代JavaScript代码质量检测工具ESLint 2 代码结构组织2.1 加入代码相关的目录12345markdown-clear-------------- src // 源代码目录 比如coffee,typescript,es6+等代码的目录-------------- lib // 转义生成的代码目录，比如babel转义后的es5代码的目录-------------- docs // 代码相关的设计和使用文档-------------- tests // 相关的测试目录 2.2 代码实现 写代码 src 目录 转换后的代码 lib 目录 2.2.1 使用babel 转换代码 babel官网 babel 配置文件 .babelrc 123&#123; &quot;presets&quot;:[&quot;es2015&quot;,&quot;stage-0&quot;]&#125; 添加 npm 命令 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;babel src -d lib&quot;, &#125; 2.2.2 实现一个可以全局安装的npm包 添加package.json的配置 123&quot;bin&quot;: &#123; &quot;markdown-clear&quot;: &quot;./lib/cli.js&quot;&#125; cli.js文件第一行添加 1#!/usr/bin/env node 2.3 测试 写测试用例 tests 目录 调用最终生成的 lib 下面的目录 可以考虑使用测试框架 mocha, jasmine, karma… 2.3.1 安装测试 使用npm 安装本地文件 作为本地包 1npm install path/to/markdown-clear 使用npm 安装本地文件 作为全局包 1npm install path/to/markdown-clear -g 2.4 文档输出 写文档 docs 目录 写代码相关的设计和使用文档，没有自然可以不用写 这里的文档应该在README.md 中会有入口。 3 发布NPM包 npm文档 如果没有注册npm账户 1npm adduser USERNAME 如果没有登录 1npm login 登录后发布包，在工程目录下执行 1npm publish","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"npm","slug":"npm","permalink":"http://rawbin-.github.io/tags/npm/"}]},{"title":"深入理解JavaScript 系列资料","slug":"language/ecma-javascript/2017-06-15-deep-in-js","date":"2021-12-31T02:37:59.932Z","updated":"2021-12-31T02:37:59.932Z","comments":true,"path":"language/ecma-javascript/2017-06-15-deep-in-js/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2017-06-15-deep-in-js/","excerpt":"","text":"1 参考资料 汤姆大叔 深入理解JavaScript系列 波同学 前端基础进阶系列 深入理解Node.js：核心思想与源码分析 Node源码详解系列 NodeJS挖掘系列","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"}]},{"title":"FEKit Mock 简明参考手册","slug":"dev-tools/fekit/2017-07-01-fekit-mock-ref","date":"2021-12-31T02:37:59.932Z","updated":"2021-12-31T02:37:59.933Z","comments":true,"path":"dev-tools/fekit/2017-07-01-fekit-mock-ref/","link":"","permalink":"http://rawbin-.github.io/dev-tools/fekit/2017-07-01-fekit-mock-ref/","excerpt":"","text":"[TOC] 1 FEKit Mock 配置1.1 FEKit Mock 启动方式 FEkit Mock是fekit server的一个额外功能 在工程目录的上一级目录启动 fekit server -m ./projectA/path/to/mockconf.js 启动mock server。 可以通过fekit server -h 查看相应的帮助，-m参数跟--mock一致 1.2 FEKit Mock配置文件 配置文件后缀可以自己定义，比如常见的.conf 或者.js，推荐使用.js这样在各大编辑器里面能得到更好的高亮支持。 配置规则支持两种方式 key=&gt;value形式, 其中key为路径的匹配规则，value为对应的mock数据指向； pattern=&gt;respondwith形式，其中pattern为路径匹配规则,respondwith为对应的mock数据指向； 配置的规则（key或pattern）支持全匹配和正则匹配，mock数据指向支持.json,.mockjson,.js以及带http开头的全URL接口数据代理，规则文件的相对路径是相对于mock配置的路径。 规则从前至后匹配，但key=&gt; value形式的规则顺序无法保证（但优先级始终低于rules规则），如果有交叉规则需要通过顺序来控制，建议用rules形式的配置。 配置文件会被解析为CommonJS模块，同时支持更详尽的rules规则配置，所以一个配置文件内容大致如下: 12345678module.exports = &#123; &#x27;/uri/to/api&#x27;:&#x27;relative/path/to/mock/data/file&#x27;, rules:[&#123; pattern: &quot;/uri/pattern/to/match&quot;, respondwith:&#x27;relative/path/to/mock/data/file&#x27;, jsonp:&#x27;jsCallback&#x27; &#125;]&#125; 1.3 FEKit Mock支持的Mock数据类型及配置方式这里我们通过不同的支持方式来模拟一个list接口(/api/list.json )的数据(listData.json)，数据如下: 123456789101112&#123; &quot;ret&quot;:true, &quot;data&quot;:[&#123; &quot;name&quot;:&quot;Li Lei&quot;, &quot;email&quot;:&quot;lilei@test.com&quot;, &quot;registerDateTime&quot;: &quot;2020-10-01 22:11:11&quot; &#125;,&#123; &quot;name&quot;:&quot;Han Meimei&quot;, &quot;email&quot;:&quot;hanmeimei@test.com&quot;, &quot;registerDateTime&quot;: &quot;2020-10-01 22:11:11&quot; &#125;]&#125; 1.3.1 对于URL（/api/list.json）的匹配规则的配置以下四种任意一种配置方式都可以匹配到这个规则： 1234567891011module.exports = &#123; &#x27;/api/list.json&#x27;:&#x27;./data/listData.json&#x27;, &#x27;^\\\\/api\\\\/\\\\w+\\\\.json.*^^^&#x27;:&#x27;./data/listData.json&#x27;, rules:[&#123; pattern:&#x27;/api/list.json&#x27;, respondwith:&#x27;./data/listData.json&#x27; &#125;,&#123; pattern:/^\\/api\\/\\w+\\.json.*$/, respondwith:&#x27;./data/listData.json&#x27; &#125;]&#125; 1.3.2 jsonp规则的配置 在mock的规则中需要处理jsonp的配置默认为callback，可以自定义 在请求的url中需要增加相关的参数callback,这两者需要一致 1234567891011121314151617181920212223242526272829303132333435module.exports = &#123; rules:[&#123; pattern:&#x27;/api/list.json&#x27;, respondwith:&#x27;./data/listData.json&#x27;, jsonp:&#x27;thecallback&#x27; &#125;,&#123; pattern:/^\\/api\\/\\w+\\.json.*$/, respondwith:&#x27;./data/listData.json&#x27;, jsonp:&#x27;thecallback&#x27;, &#125;,&#123; pattern:/^\\/api\\/\\w+\\.json.*$/, respondwith:function(req,res,context)&#123; //这里可以有更多其他的处理过程 var callbackKey = &#x27;thecallback&#x27; var dataStr = JSON.stringify(&#123; &quot;ret&quot;: true, &quot;data&quot;: [&#123; &quot;name&quot;: &quot;Li Lei&quot;, &quot;email&quot;: &quot;lilei@test.com&quot;, &quot;registerDateTime&quot;: &quot;2020-10-01 22:11:11&quot; &#125;, &#123; &quot;name&quot;: &quot;Han Meimei&quot;, &quot;email&quot;: &quot;hanmeimei@test.com&quot;, &quot;registerDateTime&quot;: &quot;2020-10-01 22:11:11&quot; &#125;] &#125;); var jsonpCallback = req.query[callbackKey]; if(jsonpCallback)&#123; res.end([jsonpCallback,&#x27;(&#x27;,dataStr,&#x27;)&#x27;].join(&#x27;&#x27;)) &#125;else&#123; res.end(dataStr) &#125; &#125; &#125;]&#125; 1.3.3 对于数据匹配规则的配置1.3.3.1 json 规则直接返回原数据文件(listData.json)内容 1.3.3.2 mockjson 规则参考mockJSON github,网站挂掉了，直接clone代码看文档，这个可以更加灵活的配置数据模板，根据模板动态生成随机数据，比如我们这里的规则（listData.mockjson）如下: 123456789101112&#123; &quot;ret|0-1&quot;:true, &quot;data|2-5&quot;:[&#123; &quot;name&quot;:&quot;@LAST_NAME @MALE_FIRST_NAME&quot;, &quot;email&quot;:&quot;@EMAIL&quot;, &quot;registerDateTime&quot;: &quot;@DATE_YYYY-@DATE_MM-@DATE_DD @TIME_HH:@TIME_MM:@TIME_SS&quot; &#125;,&#123; &quot;name&quot;:&quot;@LAST_NAME @FEMALE_FIRST_NAME&quot;, &quot;email&quot;:&quot;@EMAIL&quot;, &quot;registerDateTime&quot;: &quot;@DATE_YYYY-@DATE_MM-@DATE_DD @TIME_HH:@TIME_MM:@TIME_SS&quot; &#125;]&#125; 1.3.3.3 js规则直接控制response对象传入数据，这里可以有更灵活的处理 123456789101112131415module.exports = function (req, res, context) &#123; //这里可以有更多其他的处理过程 res.end(JSON.stringify(&#123; &quot;ret&quot;: true, &quot;data&quot;: [&#123; &quot;name&quot;: &quot;Li Lei&quot;, &quot;email&quot;: &quot;lilei@test.com&quot;, &quot;registerDateTime&quot;: &quot;2020-10-01 22:11:11&quot; &#125;, &#123; &quot;name&quot;: &quot;Han Meimei&quot;, &quot;email&quot;: &quot;hanmeimei@test.com&quot;, &quot;registerDateTime&quot;: &quot;2020-10-01 22:11:11&quot; &#125;] &#125;))&#125; 1.3.3.4 http 数据转发规则通过直接获取远端接口数据并将数据作为mock数据返回，这里只支持http，不支持https，因为没有考虑相关的证书输入。 数据的匹配规则如下: 123456789101112131415161718192021222324252627282930313233343536module.exports = &#123; &#x27;/api/list.json&#x27;:&#x27;./data/listData.json&#x27;, &#x27;/api/list.json&#x27;:&#x27;./data/listData.mockjson&#x27;, &#x27;/api/list.json&#x27;:&#x27;./data/listData.js&#x27;, &#x27;/api/list.json&#x27;:&#x27;http://testdomain.com.cn/resp/listapi.json&#x27;, rules: [&#123; pattern:&#x27;/api/list.json&#x27;, respondwith:&#x27;./data/listData.json&#x27; &#125;, &#123; pattern:&#x27;/api/list.json&#x27;, respondwith:&#x27;./data/listData.mockjson&#x27; &#125;, &#123; pattern:&#x27;/api/list.json&#x27;, respondwith:&#x27;./data/listData.js&#x27; &#125;, &#123; pattern:&#x27;/api/list.json&#x27;, respondwith:&#x27;http://testdomain.com.cn/resp/listapi.json&#x27; &#125;,&#123; pattern: &#x27;/api/list.json&#x27;, respondwith: function (req, res, context) &#123; //这里可以有更多其他的处理过程 res.end(JSON.stringify(&#123; &quot;ret&quot;: true, &quot;data&quot;: [&#123; &quot;name&quot;: &quot;Li Lei&quot;, &quot;email&quot;: &quot;lilei@test.com&quot;, &quot;registerDateTime&quot;: &quot;2020-10-01 22:11:11&quot; &#125;, &#123; &quot;name&quot;: &quot;Han Meimei&quot;, &quot;email&quot;: &quot;hanmeimei@test.com&quot;, &quot;registerDateTime&quot;: &quot;2020-10-01 22:11:11&quot; &#125;] &#125;)) &#125; &#125;]&#125; 2 FEKit Proxy 代理配置 配置文件在~/fekit.hosts，使用fekit server -o 启动代理，会有相应的提示 启动端口在10180，将浏览器的代理设置到这个端口上面就可以玩起来了，用这里面的host和转发规则 配置的内容参考 12345# 简单的host配置127.0.0.1 test.test.com # 请求转发的配置proxy_pass http://q.qunarzz.com/(.*) http://127.0.0.1:7778/$1 ​ 代码地址 相关的代码可以在这里找到 3 参考资料 FEKit Mock 文档 FEKit 使用教程 FEKit Mock源码","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"前端工程化","slug":"Web开发/前端开发/前端工程化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"开发工具","slug":"Web开发/前端开发/前端工程化/开发工具","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Mock","slug":"Mock","permalink":"http://rawbin-.github.io/tags/Mock/"},{"name":"模拟数据","slug":"模拟数据","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE/"},{"name":"测试数据","slug":"测试数据","permalink":"http://rawbin-.github.io/tags/%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/"},{"name":"FEKit","slug":"FEKit","permalink":"http://rawbin-.github.io/tags/FEKit/"}]},{"title":"Web自动化之Headless Chrome开发工具库","slug":"automatic/2017-06-11-headless-chrome-devlib","date":"2021-12-31T02:37:59.931Z","updated":"2021-12-31T02:37:59.931Z","comments":true,"path":"automatic/2017-06-11-headless-chrome-devlib/","link":"","permalink":"http://rawbin-.github.io/automatic/2017-06-11-headless-chrome-devlib/","excerpt":"","text":"1 命令行运行Headless Chrome1.1 Chrome 安装（需要带梯子） 下载地址 几个版本的比较 Chromium 不是Chrome，但Chrome的内容基本来源于Chromium，这个是开源的版本，小时级别的更新 Canary 是试验版，翻译过来就是金丝雀，金丝雀对瓦斯等毒气很敏感，浓度稍高就会停止鸣叫甚至挂掉，金丝雀是瓦斯等毒气检测的土办法，这个场景在《寻龙诀》中黄渤的操作中也能看到。哈哈 扯远了，这个是daily build 版本。 Dev 是开发版，weekly build版本 Beta 是测试版，monthly build版本 Stable 是稳定版，不定期更新，一般也是一个月左右一次 更新频率 Chromium &gt; Chrome Canary &gt; Chrome Dev &gt; Chrome Beta &gt; Chrome Stable Chrome Dev、Chrome Beta 和 Chrome Stable三者只能同时出现一个 Chromium 、Chrome Canary 和 剩下的任意一个可共存 Windows平台下载下来的可能只是一个在线安装的程序，下载离线版在下载页面的URL里面加参数standalone=1 1.2 命令行快捷配置（Mac环境）在~/.bashrc 中加入 12alias chrome=&quot;/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome&quot;alias chrome-canary=&quot;/Applications/Google\\ Chrome\\ Canary.app/Contents/MacOS/Google\\ Chrome\\ Canary&quot; 重新打开终端，我们就可以直接通过 chrome打开稳定版的Chrome，chrome-canary打开试验版的Chrome了。 1.3 命令行启动Chrome 参考官方说明, Headless模式需要Chrome Version &gt;= 59 使用Chrome打开百度首页(带界面)，能看到浏览器的打开 1chrome https://www.baidu.com 使用无界面模式启动Chrome打开百度首页(无界面)，但不到浏览器界面打开，但任务栏会有图标 1chrome --headless https://www.baidu.com 使用无界面模式启动Chrome并将页面转为PDF，可以看到output.pdf的输出 1chrome --headless --print-to-pdf https://www.baidu.com 使用无界面模式启动Chrome并截图，可以看到screenshot.png的输出 1chrome --headless --screenshot --window-size=414,736 https://www.baidu.com/ 使用无界面模式启动Chrome并打开交互环境 1chrome --headless --repl 使用无界面模式启动Chrome，并开启调试Server 1chrome --headless --remote-debugging-port=9222 参考 Chrome命令行参数列表 1.4 命令行操作Headless Chrome 确保已经启动Headless Chrome,并启用了调试Server 1chrome --headless --remote-debugging-port=9222 安装chrome-remote-interface 1npm install chrome-remote-interface -g 查看命令说明，这里可以进行各种相关操作 1234567891011121314151617181920$ chrome-remote-interface Usage: chrome-remote-interface [options] [command] Commands: inspect [options] [&lt;target&gt;] inspect a target (defaults to the first available target) list list all the available targets/tabs new [&lt;url&gt;] create a new target/tab activate &lt;id&gt; activate a target/tab by id close &lt;id&gt; close a target/tab by id version show the browser version protocol [options] show the currently available protocol descriptor Options: -h, --help output usage information -t, --host &lt;host&gt; HTTP frontend host -p, --port &lt;port&gt; HTTP frontend port -s, --secure HTTPS/WSS frontend 打开一个新页面 1chrome-remote-interface new https://www.baidu.com 查看刚打开的页面 1chrome-remote-interface inspect 查看当前页面的URL 1&gt;&gt;&gt; Runtime.evaluate(&#123;expression:&#x27;location.href&#x27;&#125;) ​ 2 可编程方式运行Headless Chrome2.1 直接通过代码调用命令行启动Chrome 调试Server可以通过系统调用的方式直接调用上面的命令行执行方式。这种方式在跨平台的情况下会有一些工作需要做。 Google出品的Lighthouse 这个网页质量检查工具，有一个组件专门做这事，考虑了各种平台的兼容性问题，源码参考lighthouse-chromelauncher，这个组件现在已经单独独立出来，作为一个单独的NPM组件chrome-launcher,可以直接使用这个在Node平台下调用，其他平台的也可以此为参考。 12345678910111213const chromeLauncher = require(&#x27;chrome-launcher&#x27;);//启用无界面模式并开启远程调试,不同引用版本和方式，调用方式可能有些区别//chromeLauncher.run(&#123;chromeLauncher.launch(&#123; // port: 9222, chromeFlags: [ &#x27;--headless&#x27; ]&#125;).then((chrome) =&gt; &#123; // 拿到一个调试客户端实例 console.log(chrome) chrome.kill();&#125;); 2.2 通过客户端的封装组件进行浏览器交互实现了ChromeDevTools协议的工具库有很多，chrome-remote-interface是NodeJS的实现。 Chrome调试Server开启的是WebSocket交互的相关实现，要用编程的方式实现还需要封装一些WebSocket命令发送、结果接收等这一系列操作，这些chrome-remote-interface已经帮我们做了，更多实例可以参考chrome-remote-interface的wiki。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const chromeLauncher = require(&#x27;chrome-launcher&#x27;);const chromeRemoteInterface = require(&#x27;chrome-remote-interface&#x27;)//启用无界面模式并开启远程调试,不同引用版本和方式，调用方式可能有些区别//chromeLauncher.run(&#123;chromeLauncher.launch(&#123; port: 9222, chromeFlags: [ &#x27;--headless&#x27; ]&#125;).then((launcher) =&gt; &#123; chromeRemoteInterface.Version(&#123; host:&#x27;localhost&#x27;, port:9222 &#125;).then(versionInfo =&gt; &#123; console.log(versionInfo) &#125;); chromeRemoteInterface(&#123; host:&#x27;localhost&#x27;, port:9222 &#125;).then((chrome) =&gt; &#123; //这里调用ChromeDevToolsProtocol定义的接口 const &#123;Network,Page&#125; = chrome; Network.requestWillBeSent((params) =&gt; &#123; let &#123;request&#125; = params; let &#123;url&#125; = request; console.log(url) &#125;); Promise.all([ Network.enable(), Page.enable() ]).then(() =&gt; &#123; Page.navigate(&#123; url:&#x27;https://www.baidu.com&#x27; &#125;) &#125;); setTimeout(() =&gt; &#123; launcher.kill() &#125;,5000); &#125;)&#125;);","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"自动化","slug":"Web开发/前端开发/JavaScript/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Headless Chrome","slug":"Headless-Chrome","permalink":"http://rawbin-.github.io/tags/Headless-Chrome/"},{"name":"Lighthouse","slug":"Lighthouse","permalink":"http://rawbin-.github.io/tags/Lighthouse/"},{"name":"chrome-launcher","slug":"chrome-launcher","permalink":"http://rawbin-.github.io/tags/chrome-launcher/"}]},{"title":"Web自动化之Headless Chrome测试框架集成","slug":"automatic/2017-06-13-headless-chrome-test","date":"2021-12-31T02:37:59.931Z","updated":"2021-12-31T02:37:59.932Z","comments":true,"path":"automatic/2017-06-13-headless-chrome-test/","link":"","permalink":"http://rawbin-.github.io/automatic/2017-06-13-headless-chrome-test/","excerpt":"","text":"[TOC] 1 使用Selenium操作headless chrome 推荐1.1 简介WebDriver是一个W3C标准, 定义了一套检查和控制用户代理（比如浏览器）的远程控制接口，各大主流浏览器来实现这些接口以便调用控制接口来操作浏览器。 Selenium是一整套的Web自动化测试解决方案，配合WebDrive规范，实现了对各种用户代理的适配（比如浏览器,PhantomJS等），通过操作浏览器的WebDriver接口来实现带浏览器的Web自动化。 1.2 使用selenium-webdriver selenium相关的API文档 selenium-webdriver的JavaScriptAPI文档 12345678910111213141516171819202122232425const webdriver = require(&#x27;selenium-webdriver&#x27;), By = webdriver.By;const driver = new webdriver.Builder() .forBrowser(&#x27;chrome&#x27;) .build();driver.get(&#x27;https://www.baidu.com&#x27;).then((args) =&gt; &#123; // 获取百度搜索按钮的 文本 driver.findElement(By.id(&#x27;su&#x27;)).then((element) =&gt; &#123; return element.getAttribute(&#x27;value&#x27;) &#125;).then((btnName) =&gt; &#123; console.log(btnName) &#125;); // 获取百度首页 title driver.getTitle().then((title) =&gt; &#123; console.log(title); &#125;);&#125;);driver.quit(); 1.3 使用browserstack-webdriver只是获取driver的方式不一样，其他调用完全一样 1234567891011121314151617181920212223242526272829303132const webdriver = require(&#x27;browserstack-webdriver&#x27;), By = webdriver.By;// Input capabilitiesconst capabilities = &#123; &#x27;browserName&#x27; : &#x27;firefox&#x27;, &#x27;browserstack.user&#x27; : BROWSERSTACK_USERNAME, &#x27;browserstack.key&#x27; : BROWSERSTACK_KEY&#125;const driver = new webdriver.Builder().usingServer(&#x27;http://hub.browserstack.com/wd/hub&#x27;).withCapabilities(capabilities).build();driver.get(&#x27;https://www.baidu.com&#x27;).then((args) =&gt; &#123; // 获取百度搜索按钮的 文本 driver.findElement(By.id(&#x27;su&#x27;)).then((element) =&gt; &#123; return element.getAttribute(&#x27;value&#x27;) &#125;).then((btnName) =&gt; &#123; console.log(btnName) &#125;); // 获取百度首页 title driver.getTitle().then((title) =&gt; &#123; console.log(title); &#125;);&#125;);driver.quit(); 1.4 使用 chromedriverchromedriver是一个编码辅助，自动配置环境变量，不需要手动下载和配置环境变量，通过安装chromedriver同时在代码中引入 1require(&#x27;chromedriver&#x27;) 1.4.1 更换获取源的URL（使用如下任意一种就行） 安装过程添加参数，默认下载地址为http://chromedriver.storage.googleapis.com 1npm install chromedriver --chromedriver_cdnurl=https://npm.taobao.org/mirrors/chromedriver 添加如下内容到.npmrc文件 1chromedriver_cdnurl=https://npm.taobao.org/mirrors/chromedriver 添加环境变量CHROMEDRIVER_CDNURL 1CHROMEDRIVER_CDNURL=https://npm.taobao.org/mirrors/chromedriver npm install chromedriver 1.4.2 更换安装的chromedriver文件路径 安装过程使用配置参数 1npm install chromedriver --chromedriver_filepath=/path/to/chromedriver_mac64.zip 添加如下内容到.npmrc文件 1chromedriver_filepath=/path/to/chromedriver_mac64.zip 添加环境变量 1CHROMEDRIVER_FILEPATH=/path/to/chromedriver_mac64.zip 2 使用mocha + chai2.1 简介mocha是一个可以运行在浏览器端和NodeJS环境的JavaScript测试框架，区别于类库，框架定义好了流程，并调用你的代码。 chai是一个断言库，判断结果是否符合预期。 2.2 实例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546const chai = require(&#x27;chai&#x27;);const chromeDriver = require(&#x27;selenium-webdriver/chrome&#x27;)const webdriver = require(&#x27;selenium-webdriver&#x27;), By = webdriver.By;const driver = new webdriver.Builder() .forBrowser(&#x27;chrome&#x27;) .setChromeOptions(new chromeDriver.Options().addArguments([&#x27;headless&#x27;])) .build();describe(&#x27;首页加载测试&#x27;,function()&#123; // 获取百度搜索按钮的 文本 describe(&#x27;按钮文本&#x27;,function()&#123; it(&#x27;按钮文本必须等于&#x27;,function(done)&#123; driver.get(&#x27;https://www.baidu.com&#x27;).then(function()&#123; driver.findElement(By.id(&#x27;su&#x27;)).then((element) =&gt; &#123; return element.getAttribute(&#x27;value&#x27;) &#125;).then((btnName) =&gt; &#123; console.log(btnName); chai.expect(btnName).to.equal(&#x27;百度一下&#x27;); done(); &#125;); &#125;); &#125;) &#125;); // 获取百度首页 title describe(&#x27;首页标题&#x27;,function()&#123; it(&#x27;首页标题应该为&#x27;,function(done)&#123; driver.get(&#x27;https://www.baidu.com&#x27;).then(function()&#123; driver.getTitle().then((title) =&gt; &#123; console.log(title); chai.expect(title).to.equal(&#x27;百度一下，你就知道&#x27;); done(); &#125;); &#125;); &#125;); &#125;); after(function()&#123; driver.quit(); &#125;)&#125;); 3 使用Karma + mocha + chai3.1 简介Karma是一个用JavaScript实现的测试执行器，实现了如下内容 对各种常见框架、库的适配参考 各种常见代码预处理或转译参考 各种执行的测试报告方案参考 各种浏览器或类浏览器的适配参考 各种编辑器的适配，内容变更，立即重新执行 覆盖率统计 3.2 安装相应的依赖库12npm i --save-dev karma karma-chrome-launcher karma-mocha karma-chainpm i --save-dev mocha chai 3.3 生成配置文件在工程目录下执行如下命令 1./node_modules/.bin/karma init 一路按照提示操作即可，生成的配置文件在工程目录下karma.conf.js，内容大致如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Karma configuration// Generated on Mon Jul 10 2017 19:49:48 GMT+0800 (CST)module.exports = function(config) &#123; config.set(&#123; // base path that will be used to resolve all patterns (eg. files, exclude) basePath: &#x27;&#x27;, // frameworks to use // available frameworks: https://npmjs.org/browse/keyword/karma-adapter frameworks: [&#x27;mocha&#x27;], // list of files / patterns to load in the browser files: [ ], // list of files to exclude exclude: [ ], // preprocess matching files before serving them to the browser // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor preprocessors: &#123; &#125;, // test results reporter to use // possible values: &#x27;dots&#x27;, &#x27;progress&#x27; // available reporters: https://npmjs.org/browse/keyword/karma-reporter reporters: [&#x27;progress&#x27;], // web server port port: 9876, // enable / disable colors in the output (reporters and logs) colors: true, // level of logging // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG logLevel: config.LOG_INFO, // enable / disable watching file and executing tests whenever any file changes autoWatch: true, // start these browsers // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher browsers: [&#x27;Chrome&#x27;], // Continuous Integration mode // if true, Karma captures browsers, runs the tests and exits singleRun: false, // Concurrency level // how many browser should be started simultaneous concurrency: Infinity &#125;)&#125; 3.3.1 调整配置支持headless chrome可以到这里,查看chrome相关的karma-launcher，有ChromeHeadless和ChromeCanaryHeadless这两个headless驱动可以选择。 3.3.2 调整配置支持ES6，添加webpack1npm i webpack karma-webpack babel-core babel-loader babel-preset-es2015 3.3.3 调整配置增加测试覆盖度1npm i babel-plugin-istanbul 3.3.4 最终的到的Karma配置文件karma.conf.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Karma configuration// Generated on Mon Jul 10 2017 19:49:48 GMT+0800 (CST)module.exports = function(config) &#123; config.set(&#123; // base path that will be used to resolve all patterns (eg. files, exclude) basePath: &#x27;&#x27;, // frameworks to use // available frameworks: https://npmjs.org/browse/keyword/karma-adapter frameworks: [&#x27;mocha&#x27;,&#x27;chai&#x27;], // list of files / patterns to load in the browser files: [ &#x27;test/**/*.js&#x27; ], // list of files to exclude exclude: [ ], // preprocess matching files before serving them to the browser // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor preprocessors: &#123; &#x27;test/**/*.js&#x27;: [&#x27;webpack&#x27;] &#125;, // test results reporter to use // possible values: &#x27;dots&#x27;, &#x27;progress&#x27; // available reporters: https://npmjs.org/browse/keyword/karma-reporter reporters: [&#x27;progress&#x27;, &#x27;coverage&#x27;], coverageReporter: &#123; type: &#x27;html&#x27;, dir: &#x27;coverage/&#x27; &#125;, // web server port port: 9876, // enable / disable colors in the output (reporters and logs) colors: true, // level of logging // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG logLevel: config.LOG_INFO, // enable / disable watching file and executing tests whenever any file changes autoWatch: true, // start these browsers // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher browsers: [&#x27;ChromeHeadless&#x27;], // Continuous Integration mode // if true, Karma captures browsers, runs the tests and exits singleRun: true, // Concurrency level // how many browser should be started simultaneous concurrency: Infinity, webpack: &#123; module: &#123; loaders: [&#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, exclude: /node_modules/, query: &#123; presets: [&#x27;es2015&#x27;], plugins: [&#x27;istanbul&#x27;] &#125; &#125;] &#125; &#125; &#125;)&#125; 3.4 编写代码src/index.js 123456789101112131415161718const isType = (data, type) =&gt; &#123; return [&#x27;[object &#x27;, type, &#x27;]&#x27;].join(&#x27;&#x27;) === Object.prototype.toString.call(data)&#125;;const isFunction = (data) =&gt; &#123; return isType(data, &#x27;Function&#x27;)&#125;;const isArray = (data) =&gt; &#123; return isType(data, &#x27;Array&#x27;)&#125;;module.exports = &#123; isType, isFunction, isArray&#125; 3.5 编写测试用例test/index.js 1234567891011121314const typeUtil = require(&#x27;../src/index&#x27;)describe(&#x27;index.js: &#x27;, () =&gt; &#123; it(&#x27;isFunction() should work fine.&#x27;, () =&gt; &#123; expect(typeUtil.isFunction(function()&#123;&#125;)).to.equal(true) expect(typeUtil.isFunction(Object.prototype.toString)).to.equal(true) &#125;); it(&#x27;isArray() should work file.&#x27;, () =&gt; &#123; expect(typeUtil.isArray([])).to.equal(true) expect(typeUtil.isArray(&#123;&#125;)).to.equal(false) &#125;)&#125;); 3.6 运行测试 在当前目录下运行./node_modules/.bin/karma start 或者添加如下代码到package.json 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;karma start&quot;&#125; ​ 然后运行npm run test 3.7 查看结果 命令行能看到运行结果 在工程目录下的coverage目录能看到相应的覆盖率报告 3.8 存在的问题Karma是将测试Case在浏览器中运行并查看结果，当页面的url 改变的时候，会影响到整个Karma的执行，会有类似Some of your tests did a full page reload!这样的提示。上面打开百度首页检查按钮和title的例子在Karma中还没有找到合适的方式写出来。 4 参考资料 Automated testing with Headless Chrome 使用HeadlessChrome做单页应用SEO 基于HeadlessChrome的网页自动化测试系统-FinalTest 使用 headless chrome进行测试 使用 headless chrome进行测试 UI自动化测试之Headless browser容器化 初探 Headless Chrome Karma原理及论文 karma入门 karma 测试框架的前世今生","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"自动化","slug":"Web开发/前端开发/JavaScript/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Selenium","slug":"Selenium","permalink":"http://rawbin-.github.io/tags/Selenium/"},{"name":"Xvfb","slug":"Xvfb","permalink":"http://rawbin-.github.io/tags/Xvfb/"},{"name":"PhantomJS","slug":"PhantomJS","permalink":"http://rawbin-.github.io/tags/PhantomJS/"},{"name":"Headless Chrome","slug":"Headless-Chrome","permalink":"http://rawbin-.github.io/tags/Headless-Chrome/"}]},{"title":"Web自动化之Headless Chrome编码实战","slug":"automatic/2017-06-12-headless-chrome-demo","date":"2021-12-31T02:37:59.931Z","updated":"2021-12-31T02:37:59.931Z","comments":true,"path":"automatic/2017-06-12-headless-chrome-demo/","link":"","permalink":"http://rawbin-.github.io/automatic/2017-06-12-headless-chrome-demo/","excerpt":"","text":"1 API 概览 &amp;&amp; 编码Tips1.1 文档地址 github Chrome DevTools Protocol 协议本身的仓库 有问题可以在这里提issue github debugger-protocol-viewer 协议API文档的仓库 API 文档地址 API展示的地方，这个经常用 1.2 常用API Network 网络请求、Cookie、缓存、证书等相关内容 Page 页面的加载、资源内容、弹层、截图、打印等相关内容 DOM 文档DOM的获取、修改、删除、查询等相关内容 Runtime JavaScript代码的执行，这里面我们可以搞事情~~ 1.3 编码Tips 我们这里不会直接调用Websocket相关的内容来调用chrome的调试命令，而是用chrome-remote-interface 这个封装的库来做，它是基于Promise风格的 每一个功能块成为一个单独的domain,像Network，Page，DOM等都是不同的domain 几乎每一个个头大的domain都有enable方法，需要先调用这个方法启用之后再使用 各个domain的接口方法参数都是第一个对象或者说一个Map，不用考虑参数的位置了 各个domain的接口返回值也是一个对象，取对应的key就行 参数值和返回值经常是meta信息，经常是各种对象的id信息，而不是具体的对象内容（这里可能需要切一下风格） 2 编码实例首先做一个简单的封装，准备API的执行环境，具体可参考前一篇关于工具库的。 12345678910111213141516171819202122232425const chromeLauncher = require(&#x27;chrome-launcher&#x27;);const chromeRemoteInterface = require(&#x27;chrome-remote-interface&#x27;);const prepareAPI = (config = &#123;&#125;) =&gt; &#123; const &#123;host = &#x27;localhost&#x27;, port = 9222, autoSelectChrome = true, headless = true&#125; = config; const wrapperEntry = chromeLauncher.launch(&#123; host, port, autoSelectChrome, additionalFlags: [ &#x27;--disable-gpu&#x27;, headless ? &#x27;--headless&#x27; : &#x27;&#x27; ] &#125;).then(chromeInstance =&gt; &#123; const remoteInterface = chromeRemoteInterface(config).then(chromeAPI =&gt; chromeAPI).catch(err =&gt; &#123; throw err; &#125;); return Promise.all([chromeInstance, remoteInterface]) &#125;).catch(err =&gt; &#123; throw err &#125;); return wrapperEntry&#125;; 2.1 打开百度，获取页面性能数据，参考 Navigation Timing W3C规范12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const wrapper = require(&#x27;the-wrapper-module&#x27;);const performanceParser = (perforceTiming) =&gt; &#123; let timingGather = &#123;&#125;; perforceTiming = perforceTiming || &#123;&#125;; timingGather.redirect = perforceTiming.redirectEnd - perforceTiming.redirectEnd-perforceTiming.redirectStart; timingGather.dns = perforceTiming.domainLookupEnd - perforceTiming.domainLookupStart; timingGather.tcp = perforceTiming.connectEnd - perforceTiming.connectStart; timingGather.request = perforceTiming.responseStart - perforceTiming.requestStart; timingGather.response = perforceTiming.responseEnd - perforceTiming.responseStart; timingGather.domReady = perforceTiming.domContentLoadedEventStart - perforceTiming.navigationStart; timingGather.load = perforceTiming.loadEventStart - perforceTiming.navigationStart; return timingGather;&#125;;const showPerformanceInfo = (performanceInfo) =&gt; &#123; performanceInfo = performanceInfo || &#123;&#125;; console.log(`页面重定向耗时:$&#123;performanceInfo.redirect&#125;`); console.log(`DNS查找耗时:$&#123;performanceInfo.dns&#125;`); console.log(`TCP连接耗时:$&#123;performanceInfo.tcp&#125;`); console.log(`请求发送耗时:$&#123;performanceInfo.request&#125;`); console.log(`响应接收耗时:$&#123;performanceInfo.response&#125;`); console.log(`DOMReady耗时:$&#123;performanceInfo.domReady&#125;`); console.log(`页面加载耗时:$&#123;performanceInfo.load&#125;`);&#125;;wrapper.prepareAPI().then(([chromeInstance, remoteInterface]) =&gt; &#123; const &#123;Runtime,Page&#125; = remoteInterface; Page.loadEventFired(() =&gt; &#123; Runtime.evaluate(&#123; expression:&#x27;window.performance.timing.toJSON()&#x27;, returnByValue:true //不加这个参数，拿到的是一个对象的meta信息,还需要getProperties &#125;).then((resultObj) =&gt; &#123; let &#123;result,exceptionDetails&#125; = resultObj; if(!exceptionDetails)&#123; showPerformanceInfo(performanceParser(result.value)) &#125;else&#123; throw exceptionDetails; &#125; &#125;); &#125;); Page.enable().then(() =&gt; &#123; Page.navigate(&#123; url:&#x27;http://www.baidu.com&#x27; &#125;) &#125;);&#125;); 2.2 打开百度 搜索Web自动化 headless chrome，并爬取首屏结果链接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135const wrapper = require(&#x27;the-wrapper-module&#x27;);//有this的地方写成箭头函数要注意，这里会有问题const buttonClick = function () &#123; this.click();&#125;;const setInputValue = () =&gt; &#123; var input = document.getElementById(&#x27;kw&#x27;); input.value = &#x27;Web自动化 headless chrome&#x27;;&#125;;const parseSearchResult = () =&gt; &#123; let resultList = []; const linkBlocks = document.querySelectorAll(&#x27;div.result.c-container&#x27;); for (let block of Array.from(linkBlocks)) &#123; let targetObj = block.querySelector(&#x27;h3&#x27;); resultList.push(&#123; title: targetObj.textContent, link: targetObj.querySelector(&#x27;a&#x27;).getAttribute(&#x27;href&#x27;) &#125;); &#125; return resultList;&#125;;wrapper.prepareAPI(&#123; // headless: false //加上这行代码可以查看浏览器的变化&#125;).then(([chromeInstance, remoteInterface]) =&gt; &#123; const &#123;Runtime, DOM, Page, Network&#125; = remoteInterface; let framePointer; Promise.all([Page.enable(), Network.enable(), DOM.enable(),Page.setAutoAttachToCreatedPages(&#123;autoAttach:true&#125;)]).then(() =&gt; &#123; Page.domContentEventFired(() =&gt; &#123; console.log(&#x27;Page.domContentEventFired&#x27;) Runtime.evaluate(&#123; expression:`window.location.href`, returnByValue:true &#125;).then(result =&gt; &#123; console.log(result) &#125;) &#125;); Page.frameNavigated(() =&gt; &#123; console.log(&#x27;Page.frameNavigated&#x27;) Runtime.evaluate(&#123; expression:`window.location.href`, returnByValue:true &#125;).then(result =&gt; &#123; console.log(result) &#125;) &#125;) Page.loadEventFired(() =&gt; &#123; console.log(&#x27;Page.loadEventFired&#x27;) Runtime.evaluate(&#123; expression:`window.location.href`, returnByValue:true &#125;).then(result =&gt; &#123; console.log(result) &#125;) DOM.getDocument().then((&#123;root&#125;) =&gt; &#123; //百度首页表单 DOM.querySelector(&#123; nodeId: root.nodeId, selector: &#x27;#form&#x27; &#125;).then((&#123;nodeId&#125;) =&gt; &#123; Promise.all([ //找到 搜索框填入值 DOM.querySelector(&#123; nodeId: nodeId, selector: &#x27;#kw&#x27; &#125;).then((inputNode) =&gt; &#123; Runtime.evaluate(&#123; // 两种写法 // expression:&#x27;document.getElementById(&quot;kw&quot;).value = &quot;Web自动化 headless chrome&quot;&#x27;, expression: `($&#123;setInputValue&#125;)()` &#125;); //这段代码不起作用 日狗 // DOM.setNodeValue(&#123; // nodeId:inputNode.nodeId, // value:&#x27;Web自动化 headless chrome&#x27; // &#125;); //上面的代码需求要这么写 // DOM.setAttributeValue(&#123; // nodeId:inputNode.nodeId, // name:&#x27;value&#x27;, // value:&#x27;headless chrome&#x27; // &#125;); &#125;) //找到 提交按钮setInputValue , DOM.querySelector(&#123; nodeId, selector: &#x27;#su&#x27; &#125;) ]).then(([inputNode, buttonNode]) =&gt; &#123; Runtime.evaluate(&#123; expression: &#x27;document.getElementById(&quot;kw&quot;).value&#x27;, &#125;).then((&#123;result&#125;) =&gt; &#123; console.log(result) &#125;); return DOM.resolveNode(&#123; nodeId: buttonNode.nodeId &#125;).then((&#123;object&#125;) =&gt; &#123; const &#123;objectId&#125; = object; return Runtime.callFunctionOn(&#123; objectId, functionDeclaration: `$&#123;buttonClick&#125;` &#125;) &#125;); &#125;).then(() =&gt; &#123; setTimeout(() =&gt; &#123; Runtime.evaluate(&#123; expression: `($&#123;parseSearchResult&#125;)()`, returnByValue: true &#125;).then((&#123;result&#125;) =&gt; &#123; console.log(result.value) //百度的URL有加密，需要再请求一次拿到真实URL &#125;) &#125;,3e3) &#125;); &#125;) &#125;); &#125;); Page.navigate(&#123; url: &#x27;http://www.baidu.com&#x27; &#125;).then((frameObj) =&gt; &#123; framePointer = frameObj &#125;); &#125;)&#125;);","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"自动化","slug":"Web开发/前端开发/JavaScript/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Selenium","slug":"Selenium","permalink":"http://rawbin-.github.io/tags/Selenium/"},{"name":"Xvfb","slug":"Xvfb","permalink":"http://rawbin-.github.io/tags/Xvfb/"},{"name":"PhantomJS","slug":"PhantomJS","permalink":"http://rawbin-.github.io/tags/PhantomJS/"},{"name":"Headless Chrome","slug":"Headless-Chrome","permalink":"http://rawbin-.github.io/tags/Headless-Chrome/"}]},{"title":"Web自动化之Headless Chrome概览","slug":"automatic/2017-06-10-headless-chrome-intro","date":"2021-12-31T02:37:59.931Z","updated":"2021-12-31T02:37:59.931Z","comments":true,"path":"automatic/2017-06-10-headless-chrome-intro/","link":"","permalink":"http://rawbin-.github.io/automatic/2017-06-10-headless-chrome-intro/","excerpt":"","text":"[TOC] 1 Web自动化这里所说的Web自动化是所有跟页面相关的自动化，比如页面爬取，数据抓取，页面内容检测，页面功能测试，页面加载性能测试，页面回归测试等等，当前主要由如下几种解决方式： 1.1 文本数据获取这就是各种request库或者类似curl这样的工具做的事情，拿到的是页面的文本，然后进行XML文档解析，获得相应的内容。但如果页面有一些动态执行的内容，比如JavaScript生成跳转URL，这样就搞不定了，需要有JS引擎的工具来搞，比如再配合JS引擎自行实现的工具，或者直接使用浏览器内核来搞的工具。 1.2 按照浏览器的方式来执行这就是各种使用浏览器内核来实现的工具，比如基于Webkit的PhantomJS, 基于Gecko的SlimerJS, 经过包装的CasperJS兼容PhantomJS和SlimerJS，以及基于v8JS引擎和.net平台的trifleJS等。这些工具更新迭代跟不上Web标准的发展，新的Web标准无法得到良好的支持。 1.3 通过协议直接操作真实浏览器这就是Selenium的实现方式，通过WebDriver协议进行通信，浏览器和浏览器驱动都实现了C/S结构的WebDriver协议,Selenium通过浏览器的驱动包，来发送操作请求，浏览器根据请求响应相应的操作。这样实现有一个问题是始终有一个真实浏览器的界面在渲染和变化，一方面效率低下，另一方面在服务端环境无法运行。于是就衍生出了使用Xvfb(virtual framebuffer X Server) 来配合实现在服务器环境下的运行，基本解决了问题。但每一种浏览器的特性支持都依赖于相应的驱动的实现和支持情况。 1.4 无界面浏览器前面的实现方式都或多或少有自己的问题或者局限，如果浏览器本身支持在服务端环境运行，这将是一个近乎完美的解决思路。Chrome 59开始支持无界面模式，Firefox 55支持Linux版的无界面模式，Firefox 56支持全平台的无界面模式，这样一来，使用方不用被动等待浏览器的WebDriver的实现。 2 Headless Chrome相关的对比Headless 是一种在无图形界面环境运行的一种能力，比如高性能的服务器端环境，参考Healess Software。 2.1 PhantomJS的问题 使用老版本的Webkit，不支持新的Web标准，跟真实浏览器存在差异 开发者维护难度大，主要维护者不干了，起因是Chrome 将支持 Headless模式 要解决的问题多，1800+ 内存占用高，并发有问题，不稳定，有些奇奇怪怪的bug 2.2 Selenium的问题 使用WebDriver接口和浏览器驱动来操作真实浏览器，带界面渲染，速度慢 需要有图形界面，显示设备的支持 需要使用Xvfb（virtual framebuffer X Server） X是架构无关的远程图形界面和输入设备兼容的系统，C/S架构 在没有物理输入和显示设备的机器上运行 这里可以简单理解为虚拟显示器或者显示器模拟器 也支持Headless实现，实现跟Web标准有差异 通过ChromeDriver(WebDriver的Chrome实现)的来操作Chrome，需要依赖ChromeDriver的更新 可以在ChromeDriver下载查看支持的Chrome版本 2.3 Headless Chrome带来的优势 资源占用少（相对于PhantomJS） 服务端环境(命令行，无图形界面) 支持现代Web标准和技术(ES6,ServiceWorkers,WebGL…) 行为符合Web规范、版本能自动更新 Chronium/Chrome团队维护 3 Headless Chrome 参考资料 Headless Chrome ReadMe Getting Started with Headless Chrome Chrome DevTools Protocol Chrome DevTools Protocol Viewer","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"自动化","slug":"Web开发/前端开发/JavaScript/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Selenium","slug":"Selenium","permalink":"http://rawbin-.github.io/tags/Selenium/"},{"name":"Xvfb","slug":"Xvfb","permalink":"http://rawbin-.github.io/tags/Xvfb/"},{"name":"PhantomJS","slug":"PhantomJS","permalink":"http://rawbin-.github.io/tags/PhantomJS/"},{"name":"Headless Chrome","slug":"Headless-Chrome","permalink":"http://rawbin-.github.io/tags/Headless-Chrome/"}]},{"title":"性能测试 压力测试 工具","slug":"performance/2017-06-01-stress-performance-test-tool","date":"2021-12-31T02:37:59.931Z","updated":"2021-12-31T02:37:59.931Z","comments":true,"path":"performance/2017-06-01-stress-performance-test-tool/","link":"","permalink":"http://rawbin-.github.io/performance/2017-06-01-stress-performance-test-tool/","excerpt":"","text":"[TOC] 1 选用的简单工具1.1 压力测试工具 webbench apache ab 1.2 系统监控工具 dstat glances htop 2 参考资料 10大主流压力/负载/性能测试工具推荐 十个免费的Web压力测试工具 Web服务器性能/压力测试工具http_load、webbench、ab、Siege使用教程 三种web性能压力测试工具 简单的网站压力测试工具webbench Web网站压力及性能测试工具WebBench使用指南 webbench官网 【源码剖析】Webbench —— 简洁而优美的压力测试工具 10个免费的服务器监控工具 你值得拥有：25个Linux性能监控工具 Linux 性能监测：工具 Mac OS X终端安装资源监控工具 Glances Linux 系统实时监控的瑞士军刀 —— Glances 进程管理工具htop/glances/dstat的使用 系统管理中的三大利刃(htop glances dstat) 六大开源监测工具 你用过哪个？ glances htop","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"测试","slug":"Web开发/测试","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"压力测试","slug":"压力测试","permalink":"http://rawbin-.github.io/tags/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"},{"name":"测试工具","slug":"测试工具","permalink":"http://rawbin-.github.io/tags/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"}]},{"title":"Web缓存那些事","slug":"performance/2017-06-02-web-cache-related","date":"2021-12-31T02:37:59.931Z","updated":"2021-12-31T02:37:59.931Z","comments":true,"path":"performance/2017-06-02-web-cache-related/","link":"","permalink":"http://rawbin-.github.io/performance/2017-06-02-web-cache-related/","excerpt":"","text":"1 参考资料 浏览器缓存原理 浏览器 HTTP 协议缓存机制详解 浏览器 HTTP 协议缓存机制详解 浏览器缓存机制详解 浏览器缓存机制详解","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"缓存","slug":"缓存","permalink":"http://rawbin-.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"HTTP","slug":"HTTP","permalink":"http://rawbin-.github.io/tags/HTTP/"}]},{"title":"Web性能优化原理和实例","slug":"performance/2017-06-01-web-performance-practise","date":"2021-12-31T02:37:59.931Z","updated":"2021-12-31T02:37:59.931Z","comments":true,"path":"performance/2017-06-01-web-performance-practise/","link":"","permalink":"http://rawbin-.github.io/performance/2017-06-01-web-performance-practise/","excerpt":"","text":"1 参考资料 Webnovel 不用照顾 Edge 浏览器性能？想多了！ 【性能】关于web性能的思考与分享［12］——ChromeDevTool高级调式 前端极限性能优化合集 大话WEB前端性能优化基本套路 使用HTML5监测网站性能 关于web性能的思考与分享［08］雅虎14条军规—高性能网站建设指南 关于web性能的思考与分享［03］——常用性能分析工具 Effective前端10：用好Chrome devtools 前端工程与性能优化","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"性能调优","slug":"性能调优","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"}]},{"title":"W3C规范概览-怎样阅读W3C规范","slug":"web-standard/2017-06-03-read-w3c-spec","date":"2021-12-31T02:37:59.931Z","updated":"2021-12-31T02:37:59.931Z","comments":true,"path":"web-standard/2017-06-03-read-w3c-spec/","link":"","permalink":"http://rawbin-.github.io/web-standard/2017-06-03-read-w3c-spec/","excerpt":"","text":"1 参考资料 W3C标准 W3c标准流程 How to Read W3C Specs 如何阅读W3C(World Wide Web Consortium)标准 如何阅读W3C规范（王晓轩翻译版） W3C技术资料 W3C的标准规范是怎样制定出来的？ W3C战略重点报告（公开版） - 2017年4月 W3C新会员指南（2016年8月版） W3C快速融入指南 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"W3C","slug":"W3C","permalink":"http://rawbin-.github.io/tags/W3C/"},{"name":"规范","slug":"规范","permalink":"http://rawbin-.github.io/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"浏览器原理 源码分析","slug":"browser/2017-06-01-browser-source","date":"2021-12-31T02:37:59.930Z","updated":"2021-12-31T02:37:59.930Z","comments":true,"path":"browser/2017-06-01-browser-source/","link":"","permalink":"http://rawbin-.github.io/browser/2017-06-01-browser-source/","excerpt":"","text":"1 事件循环 JavaScript单线程和浏览器事件循环简述 什么是浏览器的事件循环（Event Loop）？ Tasks, microtasks, queues and schedules 从setTimeout说事件循环模型 The JavaScript Event Loop: Explained JavaScript单线程异步的背后——事件循环机制 JavaScript：彻底理解同步、异步和事件循环(Event Loop) 从Chrome源码看浏览器的事件机制 chromium源代码结构 理解WebKit和Chromium: 消息循环(Message Loop) Chromium线程模型、消息循环 Chromium：线程模型，消息循环 Chromium：线程模型，消息循环 2 Chrome 源码分析 Google Chrome源码分析 Chrome源码剖析 【序】 &amp;&amp; 【一】 Chrome源码剖析【二】Chrome的进程间通信 Chrome源码剖析【三】Chrome的进程模型 Chrome源码剖析 【四】Chrome的UI绘制 Chrome源码剖析 【五】Chrome的插件模型 3 参考资料 浏览器原理系列10篇正式完结 理解WebKit和Chromium 学习Google Chrome源码 前端必读：浏览器内部工作原理 从Chrome源码看JS Object的实现 从Chrome源码看JS Array的实现 从Chrome源码看浏览器如何构建DOM树 从Chrome源码看浏览器的事件机制 从Chrome源码看浏览器如何构建DOM树 从Chrome源码看浏览器如何计算CSS 从Chrome源码看浏览器如何layout布局 Effective前端6：避免页面卡顿 览器内核分类 [科普文] 关于浏览器内核的一些小知识，明明白白选浏览器！ 浏览器的JavaScript引擎 前端必读：浏览器内部工作原理 浏览器内部工作原理 浏览器渲染原理及可能出现的bug [ 浏览器原理 ] Repaint 、Reflow 的基本认识和优化 浏览器的工作原理：新式网络浏览器幕后揭秘 从输入网址到显示页面：浏览器工作原理拆解分析 浏览器的渲染原理简介 [译]Google Chrome中的高性能网络 How Rendering Work (in WebKit and Blink) 浏览器详谈及其内部工作机制 —— web开发必读 how browser work","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"浏览器原理","slug":"浏览器原理","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"Headless UI 自动化测试实践","slug":"automatic/2017-06-01-headless-ui-test","date":"2021-12-31T02:37:59.930Z","updated":"2021-12-31T02:37:59.930Z","comments":true,"path":"automatic/2017-06-01-headless-ui-test/","link":"","permalink":"http://rawbin-.github.io/automatic/2017-06-01-headless-ui-test/","excerpt":"","text":"[TOC] 1 介绍Headless Chrome是Chrome的无界面模式，提供不带浏览器界面的页面加载，信息抽取，页面内容截图等 操作Chrome使用 Chrome DevTools Protocol，它是Chrome DevTool使用的协议，可以允许通过API来操作Chromium、Chrome和其他基于Blink（基于Webkit）引擎的浏览器，Chrome DevTool团队维护这个API。 1.1 现在使用Chrome DevTools Protocol的项目 https://github.com/ChromeDevTools/awesome-chrome-devtools： ChromeDriver 官方的Selenium/WebDriver的Chrome 实现 编辑器扩展 VS Code Sublime Web Inspector WebStorm &amp;&amp; Jetbrains Chrome Extension 开发工具扩展 Chrome React Perf React Developer Tools VueJS Developer Tools Redux DevTools … ​ 优势 资源占用少（相对于PhantomJS） 服务端环境(命令行) Web自动化 支持现代Web标准和技术(ES6,ServiceWorkers,WebGL…) 行为符合Web规范、版本能自动更新 Chronium/Chrome团队维护 2 Web自动化的需求 自动化页面加载、爬取、执行 数据抓取 页面检测 自动化页面测试 功能测试 回归测试 3 举步维艰的PhantomJS3.1 PhantomJS做什么 配合各种测试框架（Jasmine、QUnit、Mocha、WebDriver等）进行功能测试 可编程页面内容截图和图片获取 访问和操作页面元素，比如获取内容，填写表单等 网络访问数据监控，类似于浏览器调试工具的网络功能 3.2 PhantomJS 问题 使用老版本的Webkit，不支持新的Web标准，跟真实浏览器存在差异 开发者维护难度大，主要维护者不干了，起因是Chrome 将支持 Headless模式 要解决的问题多，1800+ 内存占用高，并发有问题，不稳定，有些奇奇怪怪的bug ​ 4 效率低下的Selenium 使用WebDriver接口和浏览器驱动来操作真实浏览器，速度慢 需要有图形界面，显示设备的支持 需要使用Xvfb（virtual framebuffer X Server） X 是架构无关的远程图形界面和输入设备兼容的系统，C/S架构 在没有物理输入和显示设备的机器上运行 这里可以简单理解为 虚拟显示器或者显示器模拟器 也支持Headless实现，实现跟Web标准有差异 通过ChromeDriver(WebDriver的Chrome实现)的来操作Chrome，需要依赖ChromeDriver的更新 可以在ChromeDriver下载查看支持的Chrome版本 目前支持Chrome v56-58，而Headless Chrome在Chrome 59才支持 5 其他类似的实现 PhantomJS 基于Webkit SlimerJS 基于Gecko CasperJS 驱动PhantomJS 和 SlimerJS trifleJS 使用V8和.Net WebBrowser实现的无界面 IE 其他自行实现类浏览器功能的库 6 相关开发项目 Chrome DevTools Protocol 文档 chrome-remote-interface 是Chrome DevTools Protocol的NodeJS接口实现 目前支持Google Chrome，Microsoft Edge，Node.js 6.3.0+,Safari(iOS) 7 参考资料 Headless Chrome ReadMe Getting Started with Headless Chrome Headless Browsers 相关工具 awesome-chrome-devtools 技能树升级——Chrome Headless模式 Headless Chrome入门 初探Headless Chrome Lighthouse Showcase Chrome Debugging Protocol Clients 依赖chrome-remote-interface的项目 ChromeDevToolsProtocol chrome devtool protocol Chrome DevTools Protocol wiki chrome-remote-interface WebKitProtocol 5 Reasons I Chose Selenium over PhantomJS Running Headless Selenium with Chrome Headless Chrome Architecture vagrant Vagrant 基础全面解析 实战Chrome Headless数据抓取 使用 Headless Chrome 进行页面渲染 Google 工程师带你入门 Headless Chrome FEX Chrome 远程调试协议分析与实战 【翻译】怎么在 macOS 上安装和使用 Headless Chrome How to install and use Headless Chrome on OSX Chromium 命令行参数说明文档 Chromium 命令行参数列表 Chrome 命令行参数开关源码 Headless Browser Testing With Xvfb Headless Browser Testing with Chrome and Firefox X Window System HTMLUnitDriver &amp; PhantomJS for Selenium Headless Testing RUNNING SELENIUM WITH THE NEW HEADLESS CHROME","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"自动化","slug":"Web开发/前端开发/JavaScript/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Selenium","slug":"Selenium","permalink":"http://rawbin-.github.io/tags/Selenium/"},{"name":"Xvfb","slug":"Xvfb","permalink":"http://rawbin-.github.io/tags/Xvfb/"},{"name":"PhantomJS","slug":"PhantomJS","permalink":"http://rawbin-.github.io/tags/PhantomJS/"},{"name":"Headless Chrome","slug":"Headless-Chrome","permalink":"http://rawbin-.github.io/tags/Headless-Chrome/"}]},{"title":"Mac环境软件逆向参考","slug":"encoding-decoding/2017-06-01-mac-app-crack","date":"2021-12-31T02:37:59.930Z","updated":"2021-12-31T02:37:59.930Z","comments":true,"path":"encoding-decoding/2017-06-01-mac-app-crack/","link":"","permalink":"http://rawbin-.github.io/encoding-decoding/2017-06-01-mac-app-crack/","excerpt":"","text":"1 参考资料 一篇文章走进Mac逆向的世界 MAC软件破解初探—Hopper Disassembler使用 修改一个数字破解Mac上的应用 MAC软件破解初探—Hopper Disassembler使用 charles v4.2.1 破解方法","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"http://rawbin-.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"软件破解","slug":"软件破解","permalink":"http://rawbin-.github.io/tags/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"}]},{"title":"Web开发中编码解码那些事","slug":"encoding-decoding/2017-05-26-web-encode-decode","date":"2021-12-31T02:37:59.930Z","updated":"2021-12-31T02:37:59.930Z","comments":true,"path":"encoding-decoding/2017-05-26-web-encode-decode/","link":"","permalink":"http://rawbin-.github.io/encoding-decoding/2017-05-26-web-encode-decode/","excerpt":"","text":"[TOC] 1 源代码编码2 页面内容编码2.1 HTML编码2.1.1 编码设定12345&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=GBK&quot;/&gt; &lt;!--HTML4.x--&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!--HTML5.x--&gt;&lt;script charset=&quot;GBK&quot;&gt;&lt;/script&gt;&lt;form accept-charset=&quot;GBK&quot;&gt;&lt;/form&gt;&lt;link charset=&quot;GBK&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; 2.1.2 浏览器编码解析 字节流里面能确认编码的就使用这个确认了的编码（比如BOM） 没有明确编码的页面，浏览器需要使用下面的编码嗅探算法进行编码确认 用户明确设定了编码的，就用用户设定的编码，比如在Firefox 查看菜单中设定页面解析编码 浏览器预解析500ms之内收到的资源或者1024字节（哪个条件先满足就用谁）来确定页面设定的编码，比如FEFF开头的两字节为UTF-16大端，FFFE开头的两字节为UTF-16小端，EFBBBF开头的三字节为UTF-8 如果传输层指定了编码，就用传输层指定的编码 （可选）预扫描字节流来确定内容编码，取meta标签设定的编码 如果HTML解析器关联了一个Document对象，且这个文档对象的父文档满足同源和非UTF-16编码，就使用这个父文档的编码 上面都没找到编码的话，就猜一个可能的编码，比如上次这个页面用的编码 浏览器可以用资源的信息来自动识别编码，但不能用资源的内容和地址信息，如果识别出来了就用识别了的编码 还是没确定编码，就按情况给个UTF-8或者根据系统语言信息给个默认的值，比如简体中文GB18030 拿到编码，开始解码内容 提交表单编码 按算法算出一个可选编码列表来 如果没有可选编码就用UTF-8，如果有就用第一个能编码所有表单键值对的编码。 2.2 CSS编码2.3 JavaScript 编码3 传输编码解码4 后端编码解码5 存储编码解码6 参考资料 字符，字节和编码 W3C HTML5.1 whatwg HTML 《软件剖析-代码攻防之道》 《Web应用安全威胁与防治 基于OWASP Top 10与ESAPI》 《WEB之困 现代WEB应用安全指南》 《Web应用安全权威指南》 《黑客大曝光Web应用程序安全》第3版 《黑客攻防技术宝典Web实战篇》第2版—《The Web Application Hacker’s Handbook》2nd Edition","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web安全","slug":"Web开发/前端开发/Web安全","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://rawbin-.github.io/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"编码解码","slug":"编码解码","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/"},{"name":"网络攻防","slug":"网络攻防","permalink":"http://rawbin-.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"}]},{"title":"NodeJS性能优化","slug":"performance/2017-06-01-nodejs-performance-opt","date":"2021-12-31T02:37:59.930Z","updated":"2021-12-31T02:37:59.931Z","comments":true,"path":"performance/2017-06-01-nodejs-performance-opt/","link":"","permalink":"http://rawbin-.github.io/performance/2017-06-01-nodejs-performance-opt/","excerpt":"","text":"1 参考资料 NodeJS 性能优化 Easy profiling for Node.js Applications Node.js调试指南 Node.js最佳实践 Web程序性能优化——asm.js和WebAssembly 你不知道的JavaScript——性能测试和调优 NodeJS的代码调试和性能调优 Node.js性能调优 性能优化三部曲之三——Node直出让你的网页秒开 Node 性能优化","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"性能优化","slug":"性能优化","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"性能调优","slug":"性能调优","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"}]},{"title":"Web安全设计编码原则理解","slug":"security/2017-05-26-security-web-design-coding","date":"2021-12-31T02:37:59.930Z","updated":"2021-12-31T02:37:59.930Z","comments":true,"path":"security/2017-05-26-security-web-design-coding/","link":"","permalink":"http://rawbin-.github.io/security/2017-05-26-security-web-design-coding/","excerpt":"","text":"[TOC] 1 引言软件系统的安全特性在系统设计的时候就需要考虑了。 2 安全设计原则2.1 简单易懂系统结构越简单清晰，越容易测试和审查，从一定程度上减少安全隐患，降低安全风险。 比如一个设计人员用易经八卦设计了一套系统，后来的开发者大多是一知半解、似懂非懂，结果可想而知，开发者自己都搞不太清楚，系统的安全风险也是一个未知数。 2.2 最小运行特权只授予程序执行操作所必须的访问权限，并对权限的使用时间范围做限制。 比如无人值守保洁，给保洁人员的钥匙应该是不包含保险柜的，钥匙在保洁完成之后也是要归还的，同时如果觉得钥匙可能被复制，必要的话也要换把锁。 2.3 故障安全化在系统出现异常或者故障的时候，以安全的方式进行处理或者退出。 比如一个科学家背叛了或者精神状态超出了正常范围，比较好的方式是清除相关的知识和回收相应的权限，阻止进一步的机密泄露，降低安全风险。 2.4 保护最薄弱环节及时发现并加强系统的薄弱环节，让最薄弱的环节也满足安全需求。 木桶原理，最薄弱的环节代表了系统整体最高的安全系数，动物迁徙的时候，也是对幼崽进行特别的保护。 2.5 提供深度防御为不同层次的安全需求提供不同的安全限制，并对他们进行权限隔离。 贵重的财物和文件总是放在卧室的保险柜里或者银行的保险柜里，比起直接放在客厅的物品有更深层次的保护。 2.6 分隔安全域适度对不同业务间的数据进行分隔，控制并减少系统安全隐患带来的损失。 除了大门加锁之外，不同的房间也有各自的锁，杜绝突破了大门的锁就能打开保险柜的情况发生。 2.7 不遗漏任何一次授权安全验证要作用到每一次需要授权的访问。 安全无小事，每一个需要权限的访问，都应该要有相应的认证和授权机制。 2.8 默认不信任明确系统功能的访问权限。 不跟陌生人说话，在没有搞清楚情况之前，陌生人都是坏人。 2.9 保护用户隐私对用户数据按照敏感性分类，并针对不同的敏感性提供相应的保护措施。 网络安全法也规定了，这类事情搞不清楚，就是违法。 2.10 使用业界主流的安全保护方式使用经过验证的业界普遍使用的数据安全保护方式，比如OpenSSL库。 被普遍使用的方法也是经过普遍认可和验证的方法，即使方法有问题也能很快得到解决，相比起来更加安全。 3 安全编码原则3.1 保持简单复杂度高的代码难以全面测试和维护，更容易隐藏安全隐患。 工程上处理问题的方式复杂问题简单化，跟咱们学术上搞的某些事情刚好相反，不给后来的维护者增添麻烦。 3.2 验证输入验证所有的不受信任的数据输入。 所有的输入都应该被验证，即使前端做了验证，在后端也应该做验证，因为无法保证后端的输入就是来源于前端；同样的其他子系统的输入也无法保证是受信的。 3.3 注意编译器告警对于编译型代码，用最高的告警级别，并且清除所有的告警。 编译器告警能在一定程度上指出我们对语言的理解和使用的一些疏漏，更容易暴露深层次的问题，比如内存问题。 3.4 框架和设计要复合安全策略在满足安全需求的情况下，使用合适的框架来处理业务逻辑，使代码结构更清晰。 使用通用的框架比如MVC来实现业务逻辑，分层结构能更容易在处理复杂的业务逻辑时保持结构清晰。 3.5 默认拒绝对于未识别或者未预料的输入或者权限，默认采用拒绝策略。 不对未知的操作类型进行猜测和赋予默认值，直接不进行任何进一步的操作。 3.6 坚持最小权限原则给刚好够应用程序运行的权限，一点多余的都不给。 实现要跟设计保持一致，不越权，不赋予无关权限。 3.7 净化发送到其他系统的数据做好本系统相关的数据验证，并进行安全过滤，降低有害数据对后续系统输入的安全威胁。 在系统入口第一次进行数据校验的时候，对有害数据进行无害化处理，再提供给后续系统输入。 3.8 深度防御不同系统的输入都要进行校验，默认不信任任何输入。 每一部分的输入都需要进行验证，尤其是破坏力较高的场景，比如注入。 3.9 使用有效的质量保证技术使用各种自动化扫描和渗透测试工具降低安全隐患，提高代码质量。 每一种锁芯都有一个破解的时间要求，在没有钥匙的情况下，开锁的时间越长，锁芯的安全级别越高，需要禁得住测试。 3.10 采用一个安全编码规范提供一个内部代码的编码规范，将常见的不安全编码方式排除，降低安全风险。 一个团体一份规范约定，并严格按照约定进行编码，不引人更多的未预料的安全隐患。 4 参考资料 《软件剖析-代码攻防之道》 《Web应用安全威胁与防治 基于OWASP Top 10与ESAPI》 《WEB之困 现代WEB应用安全指南》 《Web应用安全权威指南》 《黑客大曝光Web应用程序安全》第3版 《黑客攻防技术宝典Web实战篇》第2版—《The Web Application Hacker’s Handbook》2nd Edition 模糊测试 Fuzz工具 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web安全","slug":"Web开发/前端开发/Web安全","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://rawbin-.github.io/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"安全编码","slug":"安全编码","permalink":"http://rawbin-.github.io/tags/%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81/"},{"name":"安全设计","slug":"安全设计","permalink":"http://rawbin-.github.io/tags/%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1/"}]},{"title":"Web前端攻防实例详解","slug":"security/2017-05-27-frontend-attack","date":"2021-12-31T02:37:59.930Z","updated":"2021-12-31T02:37:59.930Z","comments":true,"path":"security/2017-05-27-frontend-attack/","link":"","permalink":"http://rawbin-.github.io/security/2017-05-27-frontend-attack/","excerpt":"","text":"[TOC] 1 参考资料 《软件剖析-代码攻防之道》 《Web应用安全威胁与防治 基于OWASP Top 10与ESAPI》 《WEB之困 现代WEB应用安全指南》 《Web应用安全权威指南》 《黑客大曝光Web应用程序安全》第3版 《黑客攻防技术宝典Web实战篇》第2版—《The Web Application Hacker’s Handbook》2nd Edition XSS 攻击的处理 [聊一聊系列]聊一聊WEB前端安全那些事儿 [聊一聊系列]聊一聊WEB前端安全那些事儿 ​ ​ ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web安全","slug":"Web开发/前端开发/Web安全","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://rawbin-.github.io/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"前端攻防","slug":"前端攻防","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E6%94%BB%E9%98%B2/"}]},{"title":"Web攻防演练系统","slug":"security/2017-05-27-web-attack-target","date":"2021-12-31T02:37:59.930Z","updated":"2021-12-31T02:37:59.930Z","comments":true,"path":"security/2017-05-27-web-attack-target/","link":"","permalink":"http://rawbin-.github.io/security/2017-05-27-web-attack-target/","excerpt":"","text":"[TOC] 模糊测试 Fuzz工具 渗透测试靶环境 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web安全","slug":"Web开发/前端开发/Web安全","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://rawbin-.github.io/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"网络攻防","slug":"网络攻防","permalink":"http://rawbin-.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"}]},{"title":"Web Assembly","slug":"browser/2017-05-12-web-assembly","date":"2021-12-31T02:37:59.929Z","updated":"2021-12-31T02:37:59.929Z","comments":true,"path":"browser/2017-05-12-web-assembly/","link":"","permalink":"http://rawbin-.github.io/browser/2017-05-12-web-assembly/","excerpt":"","text":"JavaScript优化编译器 Full Combiler Crankshaft Ignition and TurboFan （ES2015+） 1 参考资料 WebAssembly与程序编译 如何评论浏览器最新的 WebAssembly 字节码技术？ WebAssembly 实践：如何写代码 译] 关于 WebAssembly 你应该知道的 7 件事 看漫画，学 WebAssembly WebAssembly GitHub WebAssembly Tools webassembly.org WebAssembly Docs WebAssembly MDN EN WebAssembly MDN CN asm.js","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://rawbin-.github.io/tags/WebAssembly/"}]},{"title":"V8 JavaScript 引擎","slug":"browser/2017-05-09-v8-engine","date":"2021-12-31T02:37:59.929Z","updated":"2021-12-31T02:37:59.929Z","comments":true,"path":"browser/2017-05-09-v8-engine/","link":"","permalink":"http://rawbin-.github.io/browser/2017-05-09-v8-engine/","excerpt":"","text":"JavaScript优化编译器 Full Combiler Crankshaft Ignition and TurboFan （ES2015+） 1 参考资料 JavaScript 如何工作: 深入 V8 引擎 + 编写优质代码的 5 个技巧 v8 official blog V8 Javascript 引擎 认识 V8 引擎 Ignition: An Interpreter for v8 TurboFan High-performance ES2015 and beyond JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS V8世界探险 (1) - v8 API概览 Optimization killers WebKit之V8的详细介绍 WebKit之V8技术优化分析 引擎V8及优化技术 JavaScript工作机制：V8 引擎内部机制及如何编写优化代码的5个诀窍","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"引擎","slug":"引擎","permalink":"http://rawbin-.github.io/tags/%E5%BC%95%E6%93%8E/"},{"name":"v8","slug":"v8","permalink":"http://rawbin-.github.io/tags/v8/"}]},{"title":"前端自动化测试&&持续集成","slug":"automatic/2017-05-21-ui-auto-test","date":"2021-12-31T02:37:59.929Z","updated":"2021-12-31T02:37:59.929Z","comments":true,"path":"automatic/2017-05-21-ui-auto-test/","link":"","permalink":"http://rawbin-.github.io/automatic/2017-05-21-ui-auto-test/","excerpt":"","text":"[TOC] 1 测试工具1.1 操作浏览器 selenium appium dalekjs 1.2 无界面浏览器 参考 phantomjs Webkit (维护难度大) slimerjs Gecko triilejs V8 casperjs Webkit + Gecko JavaScript~ 自带测试框架，这。。。 可以通过NPM 安装，但不是真正意义上的NPM模块，要当成NPM模块来用的话 ，需要用SpookyJS nightwatch nightmare Electron NodeJS开发，首选 zombie Chrome 59+ Webkit HeadLess Mode --headless 未来的发展 ​ 2 自动化工具 grunt gulp 2.1 测试框架 参考 robot framework mocha Jasmine 3 持续集成 strider NodeJS 开发，首选 jenkins travis CI teamcity 4 选型结果 Web测试用CasperJS，移动端用Appium 集成Jenkins 5 参考资料 w3c webdriver webdriver io appium github HeadlessBrowsers selenium github selenium doc dalekjs casperjs github phantomjs github slimerjs github nightwatch github Chrome Headlesss Mode zombie github How to install and use Headless Chrome on OSX SpookyJS github robot framework grunt grunt 中文 gulp gulp 中文 mocha jasmine 测试框架参考 strider jenkins travis CI teamcity HTMLUnitDriver &amp; PhantomJS for Selenium Headless Testing ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"selenium","slug":"selenium","permalink":"http://rawbin-.github.io/tags/selenium/"},{"name":"appium","slug":"appium","permalink":"http://rawbin-.github.io/tags/appium/"},{"name":"phantomjs","slug":"phantomjs","permalink":"http://rawbin-.github.io/tags/phantomjs/"},{"name":"slimerjs","slug":"slimerjs","permalink":"http://rawbin-.github.io/tags/slimerjs/"},{"name":"casperjs","slug":"casperjs","permalink":"http://rawbin-.github.io/tags/casperjs/"}]},{"title":"乱码的原理-字符集和编码详解","slug":"encoding-decoding/2017-05-26-character-set-encode-decode","date":"2021-12-31T02:37:59.929Z","updated":"2021-12-31T02:37:59.929Z","comments":true,"path":"encoding-decoding/2017-05-26-character-set-encode-decode/","link":"","permalink":"http://rawbin-.github.io/encoding-decoding/2017-05-26-character-set-encode-decode/","excerpt":"","text":"[TOC] 1 参考资料 字符，字节和编码 字符编码 wiki Unicode 术语表 字符编码掠影：现代编码模型 刨根究底字符编码–博客园 刨根问底字符编码-简书 刨根究底字符编码之零——前言&amp;&amp;系列目录 《计算机字符编码-Unicode与Windows》 常见字符集和编码 字符编码的前世今生 Unicode 字符集、编码 相关的基本介绍 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web安全","slug":"Web开发/前端开发/Web安全","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"字符集","slug":"字符集","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"name":"Web安全","slug":"Web安全","permalink":"http://rawbin-.github.io/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"编码解码","slug":"编码解码","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/"}]},{"title":"浏览器安全策略","slug":"security/2017-05-26-browser-security-policy","date":"2021-12-31T02:37:59.929Z","updated":"2021-12-31T02:37:59.929Z","comments":true,"path":"security/2017-05-26-browser-security-policy/","link":"","permalink":"http://rawbin-.github.io/security/2017-05-26-browser-security-policy/","excerpt":"","text":"[TOC] 1 同源策略2 同源策略作用范围3 参考资料 扒一扒浏览器的安全机制 《WEB之困 现代WEB应用安全指南》 《Web应用安全权威指南》 《黑客大曝光Web应用程序安全》第3版 《黑客攻防技术宝典Web实战篇》第2版—《The Web Application Hacker’s Handbook》2nd Edition","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web安全","slug":"Web开发/前端开发/Web安全","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"Web安全","slug":"Web安全","permalink":"http://rawbin-.github.io/tags/Web%E5%AE%89%E5%85%A8/"}]},{"title":"JavaScript异步编程理解","slug":"async/2017-05-06-async-javascript","date":"2021-12-31T02:37:59.928Z","updated":"2021-12-31T02:37:59.928Z","comments":true,"path":"async/2017-05-06-async-javascript/","link":"","permalink":"http://rawbin-.github.io/async/2017-05-06-async-javascript/","excerpt":"","text":"1 引言JavaScript除了最常用的回调方式之外，还有好几个语言特性为异步编程提供方便的支持。 2 Callbacks 回调方式 时间相关 setTimeout/ setInterval nextTick setImmediate 事件监听 addEventListener/attachEvent EventEmitter 异步I/O XMLHTTPRequest 新版NodeJS中的 I/O 调用风格 回调的方式需要异步控制方知道操作内容（各种回调）,而操作控制方操作确实被动的。 从软件设计的角度来说，异步控制方只需要控制什么时候改变状态，给出一个状态表达即可。而对于操作控制方来说，只需要获取异步控制方的状态，来决定执行什么操作。（迪米特原则或者最少知识原则的要求）这样交互双方才能有效解耦。 Promise就是这样一种状态表达的实现。 同时回调函数在处理多步依赖异步流程的场景时，回调金字塔也是一个问题。 Promise能使依赖回调扁平化。 3 Promise 对将来状态的许诺 链式调用方式，避免回调金字塔 状态可预期(pending,resolved,rejected) 调用方式一致，始终是异步调用 满足条件，”立即”执行 不关心接下来的操作，只改变对接对象的状态 操作控制方有绝对的操作控制权来决定接下来的操作 4 Generators 生成器 (协程的实现) 使用*和yield实现代码受控执行 应用程序控制代码执行的调度和切换 控制支点较原始，对控制的要求较高（有控制才执行） 需要有包装才能实现业务流程 thunk函数，co模块能实现这样的包装 使用底层的生成器完成业务代码，需要生成器流程管理的包装；作为语言特性来说算是一个缺憾。 5 async 函数（ES7） 使用async和await实现流程管理 包装好了的生成器函数，不需要额外的包装代码 使用同步的形式编写异步代码 返回Promise只关心状态控制 6 参考资料 《深入浅出NodeJS》 《JavaScript异步编程-设计快速响应的网络应用》 《You Don’t Know JS-Async &amp; Performance》 You Don’t Know JS: Async &amp; Performance 《ES6标准入门》 ES6入门 【翻译】Promises/A+规范 协程与事件循环 Promise的队列与setTimeout的队列有何关联？ Promise 的队列与 setTimeout 的队列的有何关联？ 理解Promise简单实现的背后原理 理解 Promise 简单实现的背后原理 Promise介绍–异步篇 Timer解读 Yield魔法","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"async","slug":"async","permalink":"http://rawbin-.github.io/tags/async/"}]},{"title":"JavaScript 事件循环详解","slug":"browser/2017-05-08-js-event-loop","date":"2021-12-31T02:37:59.928Z","updated":"2021-12-31T02:37:59.928Z","comments":true,"path":"browser/2017-05-08-js-event-loop/","link":"","permalink":"http://rawbin-.github.io/browser/2017-05-08-js-event-loop/","excerpt":"","text":"1 定时执行 setTimeout(定时器) clearTimeout setInterval(定时器) clearInterval setImmediate clearImmediate 在本轮事件循环的所有I/O操作之后执行 在下一轮事件循环的所有定时器操作之前执行 process.nextTick 在所有Immediate和所有I/O操作之前执行 原子执行，过程不能中断 2 事件循环 每一个事件阶段都有一个 先进先出的回调队列 当事件循环执行到每个阶段，会在允许情况下执行该阶段的所有操作，然后进入下一个阶段 要么执行完所有在队列里面的回调 要么执行完最大的回调个数限制的回调数 事件循环中的每一个回调（操作）完成后，如果有process.nextTick设定的回调，要立即全部执行完（这个看起来是亲生的，相比setImmediate这个后娘养的来说），再进行下一个回调 事件循环的每个阶段及其执行内容 timers 执行setTimeout和setInterval设定的回调； 只能保证不会提前执行，有可能被其他任务拖延（还没轮到这个阶段，设定的时间已经过去） I/O callbacks 执行除timers，check，close callbacks之外的所有回调 idle, prepare 内部使用的阶段 poll timers执行也在这里控制 新的I/O事件的处理，此处可能会阻塞 队列非空，执行当前阶段到最大数量限制或者队列置空 队列为空 如果check不为空，执行check中的全部内容； 如果check为空，等待回调添加，然后立即执行 检查timers中到点的回调，并执行times阶段 check setImmediate设定的回调（相比起来后娘养的） 在poll完成时执行 close callbacks I/O关闭的回调，比如socket.on(‘close’,’…’) 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ 3 闲扯淡NodeJS官方文档比较setImmediate个process.nextTick： process.nextTick在当前阶段立即执行 setImmediate在下一轮事件循环的时候尽早执行 如果把tick理解为一次回调的话，就没有那一段说的那个问题了，immediate再快也要等到高优先级的搞完了才到，而tick可以理解为秒针动一次（一个回调） ，一次循环不能为一个tick 4 参考资料 [whatwg event-loop](https://html.spec.whatwg.org/multipage/webappapis.html#event-loope441 W33) NodeJS 官方Guide MDN JavaScript EventLoop 一次弄懂Event Loop（彻底解决此类面试问题） 从Chrome源码看浏览器的事件机制 事件循环机制 Event-Loop及其延伸 【朴灵评注】JavaScript 运行机制详解：再谈Event Loop JavaScript 运行机制详解：再谈Event Loop JavaScript 事件循环（译文JavaScript Event Loop） Nodejs Event Loop 神之门V8—–Event loop的舞池盛宴(1) 神之门V8—–Event loop的舞池盛宴(2) 神之门V8—–Event loop的舞池盛宴(3) Understanding the Node.js Event Loop v8 posts 【翻译】Promises/A+规范 协程与事件循环 Promise的队列与setTimeout的队列有何关联？ Promise 的队列与 setTimeout 的队列的有何关联？ 理解Promise简单实现的背后原理 理解 Promise 简单实现的背后原理 Promise介绍–异步篇 前端基础进阶（十二）：深入核心，详解事件循环机制 深入理解Node.js：核心思想与源码分析 事件循环 Timer解读 Yield魔法 从setTimeout说事件循环模型 js: 从setTimeout说事件循环模型","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"事件循环","slug":"事件循环","permalink":"http://rawbin-.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"event-loop","slug":"event-loop","permalink":"http://rawbin-.github.io/tags/event-loop/"}]},{"title":"JavaScript 内存模型","slug":"browser/2017-05-08-js-memory-management","date":"2021-12-31T02:37:59.928Z","updated":"2021-12-31T02:37:59.928Z","comments":true,"path":"browser/2017-05-08-js-memory-management/","link":"","permalink":"http://rawbin-.github.io/browser/2017-05-08-js-memory-management/","excerpt":"","text":"1 参考资料 理解JavaScript NodeJS中被忽略的内存 解读 V8 GC Log（二）: 堆内外内存的划分与 GC 算法 前端基础进阶（一）：内存空间详细图解 神之门V8（2）：GC的混乱之治（上） 神之门V8（2）：GC的混乱之治（下） 风骚裙摆–最后的内存池 Design Elements MDN JavaScript Memory Manangement Getting Garbage Collection for Free A tour of V8: Garbage Collection V8 Javascript 引擎","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"内存模型","slug":"内存模型","permalink":"http://rawbin-.github.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"name":"堆栈","slug":"堆栈","permalink":"http://rawbin-.github.io/tags/%E5%A0%86%E6%A0%88/"}]},{"title":"JavaScript 事件循环源码分析","slug":"browser/2017-05-09-js-event-loop-src","date":"2021-12-31T02:37:59.928Z","updated":"2021-12-31T02:37:59.929Z","comments":true,"path":"browser/2017-05-09-js-event-loop-src/","link":"","permalink":"http://rawbin-.github.io/browser/2017-05-09-js-event-loop-src/","excerpt":"","text":"1 NodeJS中的异步实现 libuv 设计文档 libuv API 2 libuv中的事件阶段 执行到点的定时器 执行pending回调 执行idle 操作 执行prepare操作 监听I/O请求 执行check操作 执行close回调 3 源码分析3.1 nodejs 主文件/src/node.cc123456789101112131415do &#123; v8_platform.PumpMessageLoop(isolate); more = uv_run(env.event_loop(), UV_RUN_ONCE); if (more == false) &#123; v8_platform.PumpMessageLoop(isolate); EmitBeforeExit(&amp;env); // Emit `beforeExit` if the loop became alive either after emitting // event, or after running some callbacks. more = uv_loop_alive(env.event_loop()); if (uv_run(env.event_loop(), UV_RUN_NOWAIT) != 0) more = true; &#125; &#125; while (more == true); 3.2 libuv 分平台/deps/uv/src/unix/core.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; r = uv__loop_alive(loop); if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; uv__update_time(loop); uv__run_timers(loop); ran_pending = uv__run_pending(loop); uv__run_idle(loop); uv__run_prepare(loop); timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); uv__io_poll(loop, timeout); uv__run_check(loop); uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it&#x27;s omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; /* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; 4 参考资料 《深入浅出NodeJS》 深入理解Node.js：核心思想与源码分析 深入理解Node.js：核心思想与源码分析 node源码详解（二 ）—— 运行机制 、整体流程 从Chrome源码看浏览器的事件机制 事件循环机制 Event-Loop及其延伸 【朴灵评注】JavaScript 运行机制详解：再谈Event Loop 一次弄懂Event Loop（彻底解决此类面试问题） Event loop in JavaScript libevent github libevent org libuv github libuv org Node.js挖掘系列","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"事件循环","slug":"事件循环","permalink":"http://rawbin-.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"event-loop","slug":"event-loop","permalink":"http://rawbin-.github.io/tags/event-loop/"},{"name":"源码","slug":"源码","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"说好的代码优化变劣化，为什么？","slug":"performance/2017-05-07-code-optmization-ext","date":"2021-12-31T02:37:59.928Z","updated":"2021-12-31T02:37:59.928Z","comments":true,"path":"performance/2017-05-07-code-optmization-ext/","link":"","permalink":"http://rawbin-.github.io/performance/2017-05-07-code-optmization-ext/","excerpt":"","text":"[TOC] 1 引言在前面高性能代码优化规则参考一文中，我们举了一个优化的例子；但是，但是，结果优化变成劣化（恶化了），演砸了。我们继续看看到底是怎么回事？ 2 优化规则评价先复原一下场景。 光说不练假把式，每种语言运行环境都有各自的表达方式，这里用“最简单“的JavaScript做一个演示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var i,len,testData = [],testCount = 9999,repeatCount = 999;function doInit(testData)&#123; for(var i = testCount; i--;)&#123; testData[i] = i; &#125;&#125;function doRepeat(operation,data)&#123; for(var i = 0; i &lt; repeatCount;i++)&#123; operation(data); &#125;&#125;function origin(data)&#123; var ret = []; for(var i = 0; i &lt; data.length; i++)&#123; ret[i] = data[i] * data[i]; &#125;&#125;function optLen(data)&#123; var ret = []; for(var i = 0,len = data.length; i &lt; len; i++)&#123; ret[i] = data[i] * data[i]; &#125;&#125;function optIdx(data)&#123; var ret = [],tmpData; for(var i = 0,len = data.length; i &lt; len; i++)&#123; tmpData = data[i]; ret[i] = tmpData * tmpData; &#125;&#125;function optCmp(data)&#123; var ret = []; for(var i = data.length; i-- &gt; 0;)&#123; ret[i] = data[i] * data[i]; &#125;&#125;doInit(testData);console.time(&quot;origin&quot;)doRepeat(origin,testData);console.timeEnd(&#x27;origin&#x27;)console.time(&#x27;optmize len&#x27;);doRepeat(optLen,testData)console.timeEnd(&#x27;optmize len&#x27;);console.time(&#x27;optmize index&#x27;);doRepeat(optIdx,testData)console.timeEnd(&#x27;optmize index&#x27;);console.time(&#x27;optmize compare&#x27;);doRepeat(optCmp,testData)console.timeEnd(&#x27;optmize compare&#x27;); 多次执行上面的代码查看效果，结果如下： 在Safari 10.1 (12603.1.30.0.34) 下的运行结果（基本稳定）： 1234origin: 163.225msoptmize len: 139.275msoptmize index: 118.999msoptmize compare: 248.611ms 在Chrome 58.0.3029.96 下的运行结果（不太稳定）： 1234origin: 81.718017578125msoptmize len: 77.73486328125msoptmize index: 74.80517578125msoptmize compare: 378.320068359375ms 在NodeJS 7.9.0下的运行结果（不太稳定）: 1234origin: 110.480msoptmize len: 104.123msoptmize index: 98.463msoptmize compare: 383.104ms 上面结果看来，优化循环判断条件和数据缓存都有一定的效果；但最后一种风骚的写法，看起来少了一个局部变量，但执行结果是成倍的劣化（恶化）。 这曾经也是一种代码优化的方式，作者也深中其毒，但这已经不那么重要了。现在问题来了，为什么会这么劣化，是一个值得研究的问题。 3 问题深入研究3.1 找工具 搜索v8 perf tool Google 第一条得到一个工具列表 筛选掉其中内存和CPU相关的，剩下irhydra可以做中间代码分析的 我们就是想看看咱们的源码被转成什么样的代码来执行了 3.2 搞出来看一看 node 本身是基于v8的，所以也不用各种下载v8源码编译什么的了，直接上 使用node 生成irhydra需要的内容 将上面的源代码存为perf-opt.js 执行下面的命令 1node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --print-opt-code perf-opt.js 在IRHydra2的界面导入上面生成的.asm和.cfg文件 可以看到我们四个函数分别对应的中间代码了 3.3 找文档 捋主线 搜索v8 intermediate representations 在得到的结果中可以得到如下的概念 Crankshaft是v8的编译优化器 Hydrogen 是Crankshaft中的HIR(High-Level intermediate representations)中间代码，更接近于源代码，跟机器无关 Lithium是Crankshaft中的LIR(Low-Level intermediate representations)中间代码，更接近于机器码，跟机器相关 SSA(Static Single Assignment)是Hydrogen的描述格式，是一种组织IR(intermediate representations)的方式。 搜索Static Single Assignment可以得到一些关于SSA的参考 参考资料 《Compiled Compiler Templates for V8》 《Static Single Assignment Book》 没有找到更详尽的关于SSA的文档，比如SSA的指令及其含义说明,只有v8源码中的src/crankshaft/hydrogen-instructions，如果你找到了，请不吝赐教（怎么找的？）。 3.4 中间代码分析3.4.1 工具介绍 Load Compilation Atrifacts 加载.asm和.cfg文件 IR 标签页，打开眼睛可以看到源代码和中间代码的映射关系，深红色的竖条表示循环范围 Graph 标签页，打开问号可以查看控制流图的说明，点击图块可以跳转到IR标签页 3.4.2 总体结果 前三段代码(origin,optLen,optIdx)的控制流图完全一致,B3-B8是循环内容 第三段代码(optCmp)与其他三段差别较大， 3.4.3 详细对比3.4.3.1 origin 与 optLen的区别 origin比optLen在B2块少一个LoadNamedField t2.%length@24 Smi 获取数组长度，代号i33，在循环内容之外 origin比optLen在B3块多一个LoadNamedField t2.%length@24 Smi 获取数组长度，代号i42，每次循环都有这个操作 origin比optLen在B5块少一个LoadNamedField t2.%length@24 Smi 获取数组长度，代号i62,每次循环都有，这个地方不科学（mark），需要用i62的地方直接使用i33就ok 其他操作无差异 3.4.3.2 optLen与optIdx的区别 optLen比optIdx在B5块多一个var[4] = t106赋值，但这个赋值后面好像没用上。。。 3.4.3.3 optCmp与optLen比较的异常 获取data[i]的时候多了CheckMaps t2 [0x12044e7ace69](stability-check)操作 存储乘积结果的时候多了CallWithDescriptor t76 t7 t16 t86 t87 s88 t74 #0 changes[*] Tagged 异常的描述（这是代码未被编译器优化识别的警告信息） 123This instruction has side effects **unknown** to the compiler.It can change hidden classes of objects, kind of array backing stores, etc.Such instructions should be avoided inside hot loops because they inhibit optimizations. 3.5 看起来还没有找到想要的 上面的SSA本身存在问题，参考意义不大 没有比较出前面三个代码之间的差异 最后一个优化搞砸了还是没解释清楚 4 重头再来4.1 使用PHP来实现（为什么？） 在这个例子上，PHP跟JavaScript极其相似 PHP是世界上最好的语言（别打脸~~） PHP下用VLD 查看opcode我玩过一次，比SSA看起来更细致 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?phpdefine(&#x27;TESTCOUNT&#x27;,9999);define(&#x27;REPEATCOUNT&#x27;,999);define(&#x27;PRECISION&#x27;,8);function mstime_str()&#123; list($usec, $sec) = explode(&quot; &quot;, microtime()); //不丢失系统原有精度 return (bcadd($usec,$sec,PRECISION));&#125;function get_exec_time($func,$param)&#123; $start = mstime_str(); call_user_func(do_repeat, $func,$param); $end = mstime_str(); return bcsub($end,$start,PRECISION);&#125;function do_init(&amp;$arr)&#123; for($i = TESTCOUNT; $i--;)&#123; $arr[$i] = $i; &#125;&#125;function do_repeat($operation,$data)&#123; for($i = 0; $i &lt; REPEATCOUNT;$i++)&#123; $operation($data); &#125;&#125;function origin($data)&#123; $ret = array(); for($i = 0; $i &lt; count($data); $i++)&#123; $ret[$i] = $data[$i] * $data[$i]; &#125;&#125;function opt_len($data)&#123; $ret = array(); for($i = 0,$len = count($data); $i &lt; $len; $i++)&#123; $ret[$i] = $data[$i] * $data[$i]; &#125;&#125;function opt_idx($data)&#123; $ret = array(); for($i = 0,$len = count($data); $i &lt; $len; $i++)&#123; $tmp = $data[$i]; $ret[$i] = $tmp * $tmp; &#125;&#125;function opt_cmp($data)&#123; $ret = array(); for($i = count($data); $i--;)&#123; $ret[$i] = $data[$i] * $data[$i]; &#125;&#125;$test_data = array();do_init($test_data);echo &#x27;origin:&#x27;.(get_exec_time(origin,$test_data)).PHP_EOL;echo &#x27;opt_len:&#x27;.(get_exec_time(opt_len,$test_data)).PHP_EOL;echo &#x27;opt_idx:&#x27;.(get_exec_time(opt_idx,$test_data)).PHP_EOL;echo &#x27;opt_cmp:&#x27;.(get_exec_time(opt_cmp,$test_data)).PHP_EOL;?&gt; 4.2 执行上面的PHP代码 将上面的内容存为perf-opt.php 运行php -f perf-opt.php 在PHP 5.6.30 上面的执行结果(稳定) 1234origin:4.74019000opt_len:3.53197500opt_idx:3.35585800opt_cmp:2.95980300 4.3 也可以使用node自带的工具来看 执行命令 1node --prof perf-opt.js 转换结果 1node --prof-process isolate-xxx-v8.log &gt; processed.log 查看processed.log 5 结论 某些优化规则在不同的编译环境下，不一定能得到一致的效果 规则是死的，但编译系统不断在改变和发展 有可能我们的优化规则，跟编译器的优化冲突了，成了执行优化的障碍 6 参考资料 《Compiled Compiler Templates for V8》 《Static Single Assignment Book》 V8 perf tool V8源码 IRHydra IRHydra github v8: a tale of two compilers Optimizing for V8 - Hydrogen v8-bailout-reasons Optimization-Killers A tour of V8: Crankshaft, the optimizing compiler V8 之旅：优化编译器 [WebKit] JavaScriptCore解析–高级篇(一) SSA (static single assignment) GNU Compiler Collection (GCC) Internals Analysis and Optimization of GIMPLE tuples static single assignment for functional programmers a closer look at crankshaft, v8’s optimizing compiler ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"代码优化","slug":"代码优化","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"},{"name":"高性能","slug":"高性能","permalink":"http://rawbin-.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"}]},{"title":"高性能代码优化规则参考","slug":"performance/2017-05-07-code-optmization","date":"2021-12-31T02:37:59.928Z","updated":"2021-12-31T02:37:59.928Z","comments":true,"path":"performance/2017-05-07-code-optmization/","link":"","permalink":"http://rawbin-.github.io/performance/2017-05-07-code-optmization/","excerpt":"","text":"[TOC] 1 引言前面谈到了Web性能优化的思路和参考点，没有涉及到具体可实施的代码层面的内容。代码优化也是有追求的工程师津津乐道的话题，但不同的程序设计语言的代码优化姿势可能千差万别，本文试图给出一些切实可行而与语言无关的优化规则参考，并简述其原理。如果涉及到特定语言的XXX，请参考XXX 性能优化 高效XXX类似的书籍。 2 代码优化概述代码优化的说法有不少，现在印象比较深的有两个： 不要优化，还是不要优化 不要过早优化 但个人认为上面的说法都是片面的，参考意义不大。 为什么这么说呢？高质量的代码需要从设计的时候就要考虑了，而且每一步都可以随手优化（比如我们下面会提到的规则）。如果当事人的知识或经验积累还没有达到类似的程度，可能的一个结果是在整体代码完成后发现有类似性能指标达不到的问题，这个时候要做的是分析相关问题的瓶颈，然后给出优化调整。这样一来项目的人力资源投入将会不同程度的增加，而且可能还会影响软件交付。当这个当事人再遇见类似的场景时，估计就不会相信上面两种说法的字面意思了。 如果我们每个阶段都是局部最优的状态产出，绝大部分情况下不会有类似的指标达不到的问题，如果确实还是出现了这样的情况，这才是我们真正的挑战。当然我们的优化必须遵循一定的规则： 等价原则（这不废话吗？看起来像） 别将正确的代码优化成不正确了，别以为测试了某些条件就完全等价了 正是这个规则，让我们对优化有很大的操作空间 有效原则 只要能满足我们的指标要求 可以是任何的时间换空间，空间换时间 不能优化变劣化，比如跟编译器的优化规则冲突，导致优化后的结果更糟糕 合算原则 尽可能降低投入产出比，以较低的代价获取较好的效果 可以适当的选择不优化，比如就某些场景下会不达标，规则可商量 自愿原则 如果这些规则束缚了你，大可以完全忽略 3 代码优化规则参考都是一些常理之中的简单规则，比如让使用最频繁的代码尽可能的高效，让多步操作尽可能一步完成，不做多次完全相同的计算等。 贯穿始终的一个思想是缓存，缓存计算结果，缓存获取的数据等。 3.1 循环优化 将循环变量无关的计算都放到循环外 尽可能减少循环内的操作数 在循环外使用局部变量，缓存多步操作的结果 将一次性的计算逻辑从循环中挪出来作为一次性计算结果 外提循环内的各种条件判断 循环中结构中的循环元素无关的逻辑判断条件的计算，比如 if（a &gt; b &amp;&amp; b &gt; c）改为if(conditionX) 循环判断条件的计算，比如i &lt; xxxList.length 改为 i &lt; xxxListLen 交换内外循环，将次数多的循环放在最内层 减少循环次数，降低循环切换代价 利用前面循环的结果 比如记录一个变量，每次循环增加值，利用这个变量使用加法算本次的结果，而不是使用循环来从头计算 将多次全循环合并（可能降低可读性） 如果可能的话讲多个可相关循环的操作放到一个循环中 ​ 3.2 逻辑判断优化 switch 语句按照出现频率排序，让最常用的放在最前面，减少无效判断 if 语句将弱计算的条件放在前面，避免过多的计算（短路规则） 逻辑判断条件转换为与0值比较 使用结果缓存，而不是每次都计算结果 使用查表的方法代替复杂的条件计算 3.3 表达式优化 公共的表达式用局部变量替代 布尔逻辑优化，比如!a &amp;&amp; !b 转换为!(a || b) 会减少计算 使用自增、自减表达式 降低计算强度 用加法代替乘法 用乘法代替幂乘 使用移位代替整数2的倍数的乘除 使用位运算代替取余运算 3.4 类型、结构和算法的选择 使用尽量简单的数据类型 使用int 或long 代替 long long 使用定点或整数代替浮点数 使员工单精度单体双精度 尽可能降低数组维度 尽可能减少数组的引用 使用更高效的算法 比如二分查找代替顺序查找 快速排序代替插入排序和冒泡排序 4 优化规则评价光说不练假把式，每种语言运行环境都有各自的表达方式，这里用“最简单“的JavaScript做一个演示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var i,len,testData = [],testCount = 9999,repeatCount = 999;function doInit(testData)&#123; for(var i = testCount; i--;)&#123; testData[i] = i; &#125;&#125;function doRepeat(operation,data)&#123; for(var i = 0; i &lt; repeatCount;i++)&#123; operation(data); &#125;&#125;function origin(data)&#123; var ret = []; for(var i = 0; i &lt; data.length; i++)&#123; ret[i] = data[i] * data[i]; &#125;&#125;function optLen(data)&#123; var ret = []; for(var i = 0,len = data.length; i &lt; len; i++)&#123; ret[i] = data[i] * data[i]; &#125;&#125;function optIdx(data)&#123; var ret = [],tmpData; for(var i = 0,len = data.length; i &lt; len; i++)&#123; tmpData = data[i]; ret[i] = tmpData * tmpData; &#125;&#125;function optCmp(data)&#123; var ret = []; for(var i = data.length; i-- &gt; 0;)&#123; ret[i] = data[i] * data[i]; &#125;&#125;doInit(testData);console.time(&quot;origin&quot;)doRepeat(origin,testData);console.timeEnd(&#x27;origin&#x27;)console.time(&#x27;optmize len&#x27;);doRepeat(optLen,testData)console.timeEnd(&#x27;optmize len&#x27;);console.time(&#x27;optmize index&#x27;);doRepeat(optIdx,testData)console.timeEnd(&#x27;optmize index&#x27;);console.time(&#x27;optmize compare&#x27;);doRepeat(optCmp,testData)console.timeEnd(&#x27;optmize compare&#x27;); 多次执行上面的代码查看效果，结果如下： 在Safari 10.1 (12603.1.30.0.34) 下的运行结果（基本稳定）： 1234origin: 163.225msoptmize len: 139.275msoptmize index: 118.999msoptmize compare: 248.611ms 在Chrome 58.0.3029.96 下的运行结果（不太稳定）： 1234origin: 81.718017578125msoptmize len: 77.73486328125msoptmize index: 74.80517578125msoptmize compare: 378.320068359375ms 在NodeJS 7.9.0下的运行结果（不太稳定）: 1234origin: 110.480msoptmize len: 104.123msoptmize index: 98.463msoptmize compare: 383.104ms 上面结果看来，优化循环判断条件和数据缓存都有一定的效果；但最后一种风骚的写法，看起来少了一个局部变量，但执行结果是成倍的劣化（恶化）。 这曾经也是一种代码优化的方式，作者也深中其毒，但这已经不那么重要了。现在问题来了，为什么会这么劣化，是一个值得研究的问题。 5 参考资料 《代码大全》第二版 《编程匠艺-编写卓越代码》 《程序设计语言编译原理》 《深入理解计算机系统》 第二版 《程序设计方法与优化》 《编程珠玑》 《高效程序的奥秘》 《算法心得-高效算法的奥秘》 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"代码优化","slug":"代码优化","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"},{"name":"高性能","slug":"高性能","permalink":"http://rawbin-.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"}]},{"title":"I/O模型 阻塞 非阻塞 同步 异步概念对比区分","slug":"async/2017-05-04-io-model","date":"2021-12-31T02:37:59.927Z","updated":"2021-12-31T02:37:59.927Z","comments":true,"path":"async/2017-05-04-io-model/","link":"","permalink":"http://rawbin-.github.io/async/2017-05-04-io-model/","excerpt":"","text":"1 引言前面写了HTTPS的介绍，步子跨的有点大，有点扯着了的不爽感。这里介绍相应的概念，为后面介绍JavaScript事件循环打个基础。 2 相关名词介绍操作系统将设备抽象为文件，对设备的操作转换为对文件的读写，文件的读写操作结构称为文件描述符（Linux）或者文件句柄（Windows）。 操作系统内核对于I/O操作只有阻塞和非阻塞两种方式。 阻塞I/O特点是调用I/O操作之后一定要等到系统内核层面完成所有操作之后，调用才返回。比如读取磁盘文件操作，系统内核在完成磁盘寻到、读取数据、复制数据到内存操作之后，这个调用才结束。阻塞I/O造成CPU等待I/O，浪费等待时间，CPU闲置不能得到充分利用。 非阻塞I/O调用后会立即返回一个文件描述符，调用方的数据再通过文件描述符获取。非阻塞I/O返回后，CPU可以用来处理其他事物，CPU利用率明显提高。非阻塞I/O返回的是当前的调用状态，为了获取完整的数据，程序需要重复调用I/O操作来确认数据是否操作完成。这种重复判断操作是否完成的技术叫轮询。 同步和异步从应用程序的视角来看的状态。 同步操作是应用程序调用操作之后，在操作返回前一直处于等待状态，异步操作不必等待操作完成就可立即返回，应用程序在操作返回前可以继续执行其他操作，在异步操作完成后再处理异步操作的后续操作。 非阻塞调用与异步调用的差别是非阻塞调用会马上返回任何可用的数据，其所读的数据可以等于或少于所要求的，或为零，异步调用所要求的传输应完整地执行，但其具体执行可以是将来某个特定时间。 3 I/O模型3.1 阻塞I/O模型 最常用的I/O模型，默认情况下，所有文件操作都是阻塞的 从I/O请求发起，到所有请求数据准备好或者出错前，请求发起者（应用程序）一直处于等待状态。 3.2 非阻塞I/O模型 发起I/O请求，能立即收到一个I/O状态 从I/O请求发起，到所有请求数据准备好或者出错之前，请求发起者（应用程序）一直处于不断查询的状态（轮询）。 3.3 I/O复用模型 如果一个或多个I/O条件满足（输入准备好，数据准备好等），我们就能被通知到的这种能力成为I/O复用。 应用程序将提供文件描述符，I/O状态的检测交给I/O复用模型，在I/O可用时接收相应的回调。 应用程序在数据准备好之前，处于等待I/O复用模型触发回调。 3.4 信号驱动I/O模型 需要开启Socket信号驱动I/O功能 通过系统调用执行一个信号处理函数（此系统调用立即返回，进程继续执行，非阻塞） 当数据准备就绪时，为该进程生成一个I/O信号，通过信号回调通知应用程序读取数据 3.5 异步I/O 应用程序请求操作系统内核启动某个操作，并在整个操作完成后通知应用程序 与信号驱动I/O的区别 信号驱动I/O由内核通知应用程序何时开始一个I/O（被通知去哪儿读数据） 异步I/O由内核通知应用程序I/O操作何时完成（被通知数据读取完成了） 4 I/O模型的实现4.1 理想的非阻塞异步I/O 应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，直接处理下一个任务 在I/O完成后通过信号或者回调将数据传输给应用程序。 Linux 原生提供的（AIO）就是这种方式 AIO仅支持内核I/O中的O_DIRECT方式读取，无法利用系统缓存 4.2 普遍的异步I/O实现满足了非阻塞I/O确保获取完整数据的需求，从应用程序的角度看，还是同步的效果，应用程序还是需要等待I/O完全返回，在返回之前需要一直等待。等待过程中要么遍历文件描述符，要么休眠等待事件发生。下面看看I/O复用模型的发展状态，怎样使用阻塞的方式实现异步的效果。 4.2.1 I/O复用模型 read 最原始、性能最低的方式 通过重复调用来检查I/O状态来完成完整的数据读取。 在得到最终数据前，CPU有效利用率不高（状态检查绝大部分是无效CPU）。 select 标准的I/O复用模型，几乎所有的类Unix系统上都有实现 在read的基础上的一种改进方案 通过文件描述符上的事件状态来进行判断 采用一个1024长度的数组来存储状态，最低可同时维护1024个文件描述符(I/O操作状态) pull 比起select来说更加优化 采用链表的方式突破数组长度的限制 避免不需要的检查 在文件描述符较多的情况下性能较低（链表的查询效率低） epoll 是Linux 2.6+上提供的性能更好的I/O复用模型（事件通知机制） 利用了事件通知，执行回调的方式而不是遍历查询，所以CPU有效利用率高 在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒 休眠过程中CPU还是闲置的，利用率还是不够高 kqueue 在FreeBSD 4.1+，OpenBSD 2.9+，NetBSD 2.0 和MacOS X上特有的性能更好的I/O复用模型 类似于epoll 仅在FreeBSD系统下实现 eventport 在Solaris 10单可用的高性能I/O复用模型 4.2.2 NodeJS的异步I/O方式单线程同步I/O会因为阻塞I/O导致硬件资源得不到更优的使用；多线程编程模型也因为编程中的死锁、状态同步问题经常出问题。单线程异步是一个值得期待的方式。 使用多线程的方式，通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来熟悉数据获取 让一个线程进行计算处理，通过线程间的通信将I/O的到的数据进行传递 通过线程池和轮询的方式实现异步I/O的效果 NodeJS在Windows下的异步I/O使用Windows自带的IOCP异步I/O方案 Windows IOCP 调用异步方法，等待I/O完成的通知，执行回调，无需轮询。 5 参考资料 《深入浅出Node.js》 《Netty 权威指南》第二版 《深入剖析Nginx》 《Unix环境高级编程》第三版 《Unix网络编程》 卷一 《Windows核心编程》第五版 《操作系统概念》第七版 聊聊Linux 五种IO模型 高性能IO模型浅析 也谈IO模型 Event loop in JavaScript","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"http://rawbin-.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}]},{"title":"进程 线程 协程 管程 纤程 概念对比理解","slug":"dev-general/2017-05-05-process-related","date":"2021-12-31T02:37:59.927Z","updated":"2021-12-31T02:37:59.927Z","comments":true,"path":"dev-general/2017-05-05-process-related/","link":"","permalink":"http://rawbin-.github.io/dev-general/2017-05-05-process-related/","excerpt":"","text":"1 引言不知道是不是我自己本身就有那么一丝丝的密集恐惧，把这么一大堆看起来很相似很相关的概念放在一起，看起来是有点麻，捋一捋感觉舒服多了。 2 相关概念2.1 任务、作业（Job，Task，Schedule）在进程的概念出现之前，进程有着这样的称谓。 2.2 进程为了使多个程序能够并发（同一时刻只有一个在运行，但感觉起来像多个同时运行；并行（同一时刻真的多个在运行，不是感觉像多个））的执行，操作系统需要一个结构来抽象和表示这个程序的运行。 进程是操作系统对一个正在运行的程序的一种抽象结构。 进程是指在操作系统中能独立运行并作为资源分配的基本单位，由一组机器指令、数据和堆栈等组成的能独立运行的活动实体。 操作系统可以同时运行多个进程，多个进程直接可以并发执行和交换信息。 进程在运行是需要一定的资源，如CPU、存储空间和I/O设备等。 2.3 线程进程是资源分配的基本单位，进程的调度涉及到的内容比较多（存储空间，CPU，I/O资源等，进程现场保护），调度开销较大，在并发的切换过程效率较低。为了更高效的进行调度，提出了比进程更轻量的独立运行和调度的基本单位。 线程比进程更轻量 线程能独立运行，独立调度，拥有资源（一般是CPU资源，程序计数器等） 线程调度能大幅度减小调度的成本（相对于进程来说），线程的切换不会引起进程的切换 线程的引入进一步提高了操作系统的并发性，线程能并发执行 同一个进程的多个线程共享进程的资源（省去了资源调度现场保护的很多工作） 2.4 协程、共行程序、Coroutine 协程是用户模式下的轻量级线程，操作系统内核对协程一无所知 协程的调度完全有应用程序来控制，操作系统不管这部分的调度 一个线程可以包含一个或多个协程 协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上细纹和栈保存起来，在切换回来时恢复先前保运的寄存上下文和栈 协程能保留上一次调用时的状态，看到这里各种生成器（生成器是被阉割的协程）的概念浮现出来了。。 Windows下的实现叫纤程 2.5 纤程代码易移植性一直是平台间交互考虑的重点，在将引用程序从Unix移植到Windows的过程中，会存在一些类似于线程栈管理的不一致、结构和异常处理等问题，增加移植难度和成本。 为了帮助各公司更快、更正确地将他们的代码移植到Windows，Microsoft 在操作系统中增加了纤程（Fiber）。线程与纤程对比，有如下的特性： 线程是在Windows内核中实现的，操作系统会根据系统的调度算法对线程进行调度。 纤程是在用户模式下实现的，内核对纤程一无所知。 纤程是更轻量级的线程，一个线程可以包含一个或多个纤程 内核会对线程进行抢占式调度，线程一次只能执行一个纤程的代码（具体执行哪一个纤程由用户调度算法决定） 纤程的调度与线程的调度没有直接关系，操作系统随时可能会夺取纤程所在线程的运行权 除非正在运行的纤程显式的切换到另一个纤程，否则其他纤程将无法运行 Windows有一套API来讲线程转换为纤程或者在同一个线程里面创建多个纤程 2.6 管程把管程放最后还加了一道分割线原因是管程跟上面的几个概念不是同一类东东，虽然长得很像，就像Car和Bar一样。 临界资源的概念： 一次只允许一个进程访问的资源 多个进程只能互斥访问的资源 临界资源的访问需要同步操作，比如信号量就是一种方便有效的进程同步机制。但信号量的方式要求每个访问临界资源的进程都具有wait和signal操作。这样使大量的同步操作分散在各个进程中，不仅给系统管理带来了麻烦，而且会因同步操作的使用不当导致死锁。管程就是为了解决这样的问题而产生的。 操作系统中管理的各种软件和硬件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对该资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。利用共享数据结构抽象地表示系统中的共享资源。而把对该共享数据结构实施的操作定义为一组过程，如资源的请求和释放过程request和release。进程对共享资源的申请、释放和其他操作，都是通过这组过程对共享数据结构的操作来实现的，这组过程还可以根据资源的情况接受或阻塞进程的访问，确保每次仅有一个进程使用该共享资源，这样就可以统一管理对共享资源的所有访问，实现临界资源互斥访问。 管程就是代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成的一个操作系统的资源管理模块。管程被请求和释放临界资源的进程所调用。 管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。 2.7 超线程这个也是一个跟上面的概念不是一类事的概念，超线程是Intel CPU设计上的一种技术。 一个CPU物理核在同一时间只能执行一个线程，而线程的切换会消耗掉上万的始终周期，效率还不够高。超线程就是在实现同一个CPU物理核在同一时间能几乎执行两个线程的技术。这就是我们在Intel CPU的机子上的任务管理器中经常看到double的CPU物理核心的缘由。 3 参考资料 《深入理解计算机系统》 第二版 《Windows 核心编程》 第五版 《计算机操作系统》 第三版 《操作系统概念》 第七版 《计算机程序设计艺术》 卷一 Coroutine 维基百科","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"进程","slug":"进程","permalink":"http://rawbin-.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"http://rawbin-.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"协程","slug":"协程","permalink":"http://rawbin-.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"管程","slug":"管程","permalink":"http://rawbin-.github.io/tags/%E7%AE%A1%E7%A8%8B/"},{"name":"纤程","slug":"纤程","permalink":"http://rawbin-.github.io/tags/%E7%BA%A4%E7%A8%8B/"}]},{"title":"深入理解HTTPS原理、过程与实践","slug":"protocol/2017-05-01-in-https","date":"2021-12-31T02:37:59.927Z","updated":"2021-12-31T02:37:59.927Z","comments":true,"path":"protocol/2017-05-01-in-https/","link":"","permalink":"http://rawbin-.github.io/protocol/2017-05-01-in-https/","excerpt":"","text":"[TOC] 1 引言HTTP是不安全的，我们的页面也被运营商插入过小黄图广告（数据被篡改），对于HTTP来说，再简单不过，只需要设定相应的DNS，做一个中间人攻击，再将修改后的数据返回，这一方面可能泄露用户隐私数据，同时也对我们的品牌形象产生恶劣影响。 然而，当我们切换HTTPS时候，运营商的这些小九九就施展不开了，服务端认证不通过，浏览器不会展示相应的页面数据；运营商实施搞的这一套东东也就不能在用户不知情的情况下搞起来了，解决办法是去除相应的受污染的DNS。 全球最大的成人网站PornHub，YouPorn都要全面切HTTPS了,我们还在犹豫什么了？ 2 安全的HTTP的需求对HTTP的安全需求： 加密（客户端和服务器的对话是私密的，无须担心被窃听） 服务端认证（客户端知道它们是在与真正的而不是伪造的服务器通信） 客户端认证（服务器知道它们是在与真正的而不是伪造的客户端通信） 完整性（客户端和服务器的数据不会被修改） 效率（一个运行足够快的算法，一遍低端的客户端和服务器使用） 普适性（基本上所有的客户端和服务器都支持这些协议） 管理的可扩展性（在任何地方的任何人都可以立即进行安全通信） 适应性（能够支持当前最知名的安全方法） 在社会上的可行性（满足社会的政治文化需要），要有公众受信能力 在这里面最重要的是前面几条 数据加密 传输内容进行混淆 身份验证 通信双方验证对方的身份真实性 数据完整性保护 检测传输的内容是否被篡改或伪造 3 安全HTTP的实现3.1 加密方式的选择3.1.1 共享密钥加密 对称密钥加密共享密钥加密方式使用相同的密钥进行加密解密，通信双方都需要接收对方的加密密钥进行数据解密，这种方式在通信过程中必须交互共享的密钥，同样无法避免被网络监听泄漏密钥的问题；同时对于众多客户端的服务器来说还需要分配和管理密钥，对于客户端来说也需要管理密钥，增加设计和实现的复杂度，同时也降低了通信的效率；不用看都不靠谱。 3.1.2 公开密钥加密公开密钥加密方式使用一对非对称的密钥对（私钥和公钥），不公开的作为私钥，随意分发的作为公钥；公钥和私钥都能进行数据加密和解密，公钥能解密私钥加密的数据，私钥也能解密公钥加密的数据；这样只需要一套密钥就能处理服务端和众多客户端直接的通信被网络监听泄漏密钥的问题，同时没有额外的管理成本；看起来挺合适。 3.1.3 没那么简单公开密钥加密安全性高，伴随着加密方式复杂，处理速度慢的问题。如果我们的通信都是用公开密钥的方式加密，那么通信效率会很低。 HTTPS采用共享密钥加密和公开密钥加密混合的加密方式，在交换密钥对环节使用公开密钥加密方式（防止被监听泄漏密钥）加密共享的密钥，在随后的通信过程中使用共享密钥的方式使用共享的密钥进行加解密。 3.2 认证方式实现3.2.1 数字证书数字签名是附加在报文上的特殊加密校验码，可以证明是作者编写了这条报文，前提是作者才会有私钥，才能算出这些校验码。如果传输的报文被篡改，则校验码不会匹配，因为校验码只有作者保存的私钥才能产生，所以前面可以保证报文的完整性。 数字证书认证机构（Certificate Authority CA）是客户端和服务器双方都可信赖的第三方机构。 服务器的运营人员向数字证书认证机构提出证书认证申请，数字证书认证机构在判明申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书（也叫数字证书或证书）后绑定在一起。服务器将这份有数字认证机构颁发的公钥证书发总给客户端，以进行公开密钥加密方式通信。 EV SSL（Extended Validation SSL Certificate）证书是基于国际标准的认证指导方针办法的证书，通过认证的Web网站能获得更高的认可度。持有EV SSL证书的Web网站的浏览器地址栏的背景色是绿色的，同时在地址栏的左侧显示了SSL证书中记录的组织名称及办法证书的认证机构的名称。 使用OpenSSL，每个人都可以构建一套认证机构文件，同时可以用来给自己的证书请求进行签名，这种方式产生的证书称为自签名证书，这种证书通常是CA自己的证书，用户开发测试的正式，也可以像12306这样的，信不信由你。 3.2.1.1 证书信任的方式 操作系统和浏览器内置 每个操作系统和大多数浏览器都会内置一个知名证书颁发机构的名单。因此，你也会信任操作系统及浏览器提供商提供和维护的可信任机构。 受信认证机构（也有不受信的，比如赛门铁克，沃通，或者像2011年被入侵的DigiNotar等）的证书一般会被操作系统或者浏览器在发行或者发布时内置。 证书颁发机构 CA（ Certificate Authority，证书颁发机构）是被证书接受者（拥有者）和依赖证书的一方共同信任的第三方。 手动指定证书 所有浏览器和操作系统都提供了一种手工导入信任证书的机制。至于如何获得证书和验证完整性则完全由你自己来定。 PKI（Public Key Infrastructure），即公开密钥基础设施，是国际上解决开放式互联网络信息安全需求的一套体系。PKI支持身份认证，信息传输，存储的完整性，消息传输，存储的机密性以及操作的不可否认性。 3.3 数据完整性数字签名是只有信息发送者才能产生的别人无法伪造的一段文本，这段文本是对信息发送者发送信息真实性的一个有效证明，具有不可抵赖性。 报文的发送方从报文文本生成一个128位的散列值（或称为报文摘要活哈希值），发送方使用自己的私钥对这个摘要值进行加密来形成发送方的数字签名。然后这个数字签名将作为报文的附件一起发送给报文的接收方。报文的接收方首先从接收到的原始报文中计算出128位的散列值，再用发送方的公钥来对报文附加的数字签名进行解密。如果两次得到的结果是一致的那么接收方可以确认该数字签名是发送方的，同时确认信息是真实的 。 4 HTTPS数据交互过程HTTP中没有加密机制，可以通过SSL（Secure Socket Layer 安全套接层）或TLS（Transport Layer Security 安全层传输协议）的组合使用，加密HTTP的通信内容。 HTTPS是 HTTP Secure 或 HTTP over SSL。 SSL（Security Socket Layer）是最初由网景公司（NetScape）为了保障网上交易安全而开发的协议，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。网景公司开发过SSL3.0之前的版本；目前主导权已转移给IETF（Internet Engineering Task Force），IETF以SSL3.0为原型，标准化并制定了TSL1.0，TLS1.1，TLS1.2。但目前主流的还是SSL3.0和TSL1.0。 SSL工作在OSI七层模型中的表示层，TCP/IP 四层模型的应用层。 SSL 和 TLS 可以作为基础协议的一部分（对应用透明），也可以嵌入在特定的软件包中（比如Web服务器中的实现）。 SSL 基于TCP，SSL不是简单地单个协议，而是两层协议；SSL记录协议（SSL Record Protocol）为多种高层协议（SSL握手协议，SSL修改密码参数协议，SSL报警协议）提供基本的安全服务。HTTP是为Web客户端/服务器交互提供传输服务的，它可以在SSL的顶层运行；SSL记录协议为SSL链接提供两种服务，机密性：握手协议定义了一个共享密钥，用于SSL载荷的对称加密。 消息完整性：握手协议还定义了一个共享密钥，它用来产生一个消息认证码（Message Authentication Code，MAC）。 4.1 SSL记录协议操作 分段 将每个上层消息分解成不大于2^14（16384）位，然后有选择的进行压缩 添加MAC 在压缩数据的基础上计算MAC 加密 消息加上MAC用对称加密方法加密 添加SSL记录头 内容类型（8位），主版本（8位），副版本（8位），压缩长度（16位） 4.2 SSL握手过程 第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数 第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号 第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息 第四阶段 变更密码构件和结束握手协议 SSL协议两个重要概念，SSL会话，SSL连接；SSL连接是点到点的连接，而且每个连接都是瞬态的，每一个链接都与一个会话关联。SSL会话是一个客户端和一个服务器之间的一种关联，会话由握手协议（Handshake Protocol）创建，所有会话都定义了一组密码安全参数，这些安全参数可以在多个连接之间共享，会话可以用来避免每一个链接需要进行的代价高昂的新的安全参数协商过程。 12345678910111213141516Client ServerClientHello:HandShake --------&gt; ServerHello:Handshake Certificate*:Handshake ServerKeyExchange*:Handshake CertificateRequest*:Handshake &lt;-------- ServerHelloDone:HandshakeCertificate*:HandshakeClientKeyExchange:HandshakeCertificateVerify*:Handshake[ChangeCipherSpec]Finished:Handshake --------&gt; [ChangeCipherSpec] &lt;-------- Finished:HandshakeApplication Data &lt;-------&gt; Application Data 5 客户端服务器数据交互实战5.1 使用openssl命令1openssl s_client -state -connect q.qunarzz.com:443 该命令可以显示SSL握手过程，SSL证书链，公钥证书以及其他相关的状态和属性信息。 5.2 使用Wireshark抓取数据包5.2.1 相关配置 配置环境变量，同时保证文件路径存在 1SSLKEYLOG=/path/to/sslkeylog.log 配置Wireshark 1Wireshark-&gt;Preference-&gt;Protocols-&gt;SSL-&gt;(Pre)-Master-Secret log filename=&gt;选择上面的路径 5.2.2 抓包操作 在命令行中打开Chrome或者Firefox，确保环境变量被读取;如果不行就用Chrome或者Firefox的开发版。 12open /Applications/Firefox.appopen /Applications/Google\\ Chrome.app 确保$SSLKEYLOGFILE里面有内容了，再往下进行。 选择对应网卡，抓包配置为host q.qunarzz.com，开始抓包 使用刚刚打开的浏览器访问一个对应host q.qunarzz.com下的某个资源，在抓包界面使用ssl过滤数据 在抓包界面可以看到对应的SSL握手信息，同时还能看到解密后的应用数据。 5.3 内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）5.3.1 客户端==&gt;服务器 Client Hello 最高支持的协议版本 如TLS 1.0 支持的加密算法列表(Cipher Suites) 支持的压缩算法列表(Compression Methods) 客户端生成的随机数，稍后用于生成会话密钥 5.3.2 服务器==&gt;客户端 Server Hello 选定的协议版本 选定的加密算法 选定的压缩方法 服务端生成的随机数，稍后用于生成会话密钥 Certificate 证书内容 Server Key Exchange, Server Hello Done 公钥 数字签名 Server Hello Done 5.3.3 客户端==&gt;服务器 Client Key Exchange, Change Cipher Spec, Finished 公钥 Change Cipher Spec Finished 5.3.4 客户端==&gt;服务器 HTTP GET 5.3.5 服务端==&gt;客户端 内容的数据片段信息 HTTP HTTP/1.1 200 OK 5.3.6 服务端==&gt;客户端 Encrypted Alert Alert (Level Warning, Description: Close Notify) 6 参考资料 《Web性能权威指南》 《RFC 2246》 《图解HTTP》 《HTTP权威指南》 《HTTPS权威指南 在服务器和Web应用上部署SSL/TLS和PKI》 《计算机网络系统方法》 《计算机网络自上而下方法》 《计算机安全原理与实践》 《网络安全基础-应用与标准》 《PKI/CA与数字证书技术大全》 《SSL与TLS》 《OpenSSL官方命令文档》 《OpenSSL与网络信息安全-基础、结构和指令》 《OpenSSL攻略》 完全图解 HTTPS Wireshark Doc SSL WebSocket与TCP/IP https连接的前几毫秒发生了什么","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"http://rawbin-.github.io/tags/HTTPS/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"http://rawbin-.github.io/tags/OpenSSL/"}]},{"title":"NodeJS发展历史梳理","slug":"dev-general/history/2017-04-24-node-history","date":"2021-12-31T02:37:59.927Z","updated":"2021-12-31T02:37:59.927Z","comments":true,"path":"dev-general/history/2017-04-24-node-history/","link":"","permalink":"http://rawbin-.github.io/dev-general/history/2017-04-24-node-history/","excerpt":"","text":"1 参考资料 一篇文章构建你的 NodeJS 知识体系","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"NodeJS历史","slug":"NodeJS历史","permalink":"http://rawbin-.github.io/tags/NodeJS%E5%8E%86%E5%8F%B2/"}]},{"title":"JavaScript发展历史梳理","slug":"dev-general/history/2017-04-24-javascript-history","date":"2021-12-31T02:37:59.927Z","updated":"2021-12-31T02:37:59.927Z","comments":true,"path":"dev-general/history/2017-04-24-javascript-history/","link":"","permalink":"http://rawbin-.github.io/dev-general/history/2017-04-24-javascript-history/","excerpt":"","text":"1 语言背景很早之前，网景公司（Netscape Communication Corporation）意识到网络需要一种集成的、统一的、客户端到服务端的解决方案。为此提出了LiveWire的概念，并设计了当时名为LiveScript的语言来在服务器上创建类似于CGI的应用程序。同时在Netscape Navigator上也需要一个脚本语言的支持，解决类似于“在向服务器提交数据之前进行校验”的问题。 1996年3月，LiveScript最早做为一种“浏览器上的脚本语言”出现。 当时Java（1995年发布，火得发烫），Netscape在服务端与Sun合作，并扩展到浏览器，推出了Java Applet。同时Netscape将LiveScript改名为JavaScript,并在1996年8月发布的NN3中提供支持。 微软1996年8月发布IE3是，提供了相当于NN3的JavaScript支持，名为JScript，同时提供VBScript的支持。在IE4.x时，微软的浏览器市场已经超过了80%。 ”我们最初利用JavaScript的目的是让客户端的应用不必从服务器重新加载页面即可回应用户的输入信息，并且提供一种功能强大的图形工具包给脚本编写者“。–JavaScript之父 BrendanEich JavaScript 语言是在参考Java，Perl，Scheme，Self等先前语言语法的基础上产生。 2 版本历史事件 1997年，ECMAScript 1.0 发布 1998年，ECMAScript 2.0 发布 1999年，ECMAScript 3.0 发布 2000年，着手ECMAScript 4.0 但最终未发布 2007年，ECMAScript 4.0 草案发布，由于各方分歧严重 2008年7月，ECMAScript 3.1 发布 2009年12月，ECMAScript 5.0 发布 2011年6月，ECMAScript 5.1 发布 2013年3月，ECMAScript草案封版，不再添加新功能 2013年12月，ECMAScript 6 草案发布 2015年6月，ECMAScript 2015（ES6）发布 2016年6月，ECMAScript 2016 发布 3 参考资料 JavaScript语言的历史 JavaScript版本迷局 《全端Web开发：使用JavaScript和Java》 《JavaScript高级程序设计》 《JavaScript权威指南》 《JavaScript语言精髓与编程实践》 《JavaScript编程全解》 《NodeJS开发指南》 《JavaScript面向对象编程指南》 《JavaScript应用开发实践指南》 《JavaScript核心概念及实践》 《ES6 标准入门（第二版）》 Javascript诞生记 还原JavaScript的真实历史 迟来的真相：关于JavaScript的历史 详图实证：再谈JavaScript的语源问题","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"JavaScript历史","slug":"JavaScript历史","permalink":"http://rawbin-.github.io/tags/JavaScript%E5%8E%86%E5%8F%B2/"}]},{"title":"使用OpenSSL生成多域名自签名证书进行HTTPS开发调试","slug":"dev-env/2016-10-10-self-asigned-cert","date":"2021-12-31T02:37:59.926Z","updated":"2021-12-31T02:37:59.926Z","comments":true,"path":"dev-env/2016-10-10-self-asigned-cert/","link":"","permalink":"http://rawbin-.github.io/dev-env/2016-10-10-self-asigned-cert/","excerpt":"","text":"[TOC] 1 证书生成过程介绍证书的目的是建立特定密钥对与特定实体之间的联系。 自签名根证书是指一堆密钥对的私钥对自己相应的公钥生成的证书请求进行签名而颁发的证书，证书的申请人和签发人都是同一个。 需要一对密钥对； 常用的是RSA，DSA密钥，ECDSA密钥，用于密钥交换的证书不能用DSA，只能用RSA，因为DSA不能加解密也不能做密钥交换，只能做签名；ECDSA还没有被大部分的CA支持； 生成密钥可以使用OpenSSL的genrsa 和 gendsa指令，也可以使用req指令； 证书认证请求文件(csr文件) 这是按照一定格式生成的文件，里面包含实体信息 将实体信息和公钥一起用相应的私钥签名，是CA（证书认证）能确认这些信息是用户发送的（证书请求中的公钥拿出来验证这个证书请求的签名） 通过OpenSSL的req指令填写和生成这个csr文件 不同的CA要求，可能需要更改默认的配置文件openssl.cnf 将证书请求文件(csr文件)给CA签发 验证证书请求上的签名是否正确，确保公钥对应的私钥就在申请者手中并且申请信息是正确没被更改的 CA对某些字段信息可能有特殊的要求，比如要求国家，身份等信息要求跟CA本身设定的一样 如果CA是在OpenSSL指令的基础上，那么它使用的签发指令可能是ca，也可能是x509 2 常用指令2.1 req 指令req指令既可以直接生成一个新的自签名证书，也可以根据现有的证书请求和其相应私钥生成自签名根证书。如果是根据现有证书请求生成自签名根证书，那么一定要-key选项指定相应的私钥指令才能执行成功。 req 指令也可以生成密钥对，但在使用req 同时生成密钥对是对密钥对保存和格式有限制（只能是PEM编码，DES3-CBC模式加密）。如果需要更灵活的处理，可以使用genrsa或者gendsa先生成密钥然后使用-key选项指定。 2.1.1 参数选项 -new 指定执行生成新的证书请求，此时会忽略-in 指定的内容 -x509 根据现有的证书请求生成自签名根证书（要求使用-key指定证书请求里面的公钥相应的私钥，以便对自签名根证书进行签名） -key 指定输入的密钥，如果不指定此选项会根据-newkey选项的参数生成密钥对 -newkey 指定生成一个新的密钥对，只有在没有-key 选项的时候才生效，参数形式为rsa:numbits 或者 dsa:file -subj直接从指令行指定证书请求的主体名称，格式为/分割的键值对字符串，如果没有此选项，那么会弹出交互提示； -days 设定了生成的自签名根证书的有效期，单位为天；该选项只有在使用了-x509选项生成自签名证书的时候才生效，默认为30天。 -config 指定req指令在生成证书请求的时候使用的OpenSSL配置文件，一般默认为openssl.cnf -extensions 选项指定了生成自签名根证书的时候使用的扩展字段，其参数为OpenSSL配置文件中的某个字段名 -reqexts 选项指定了生成证书请求是使用的扩展字段，该字段参数也是配置文件中的某个字段名 -text 让指令输出证书请求或者自签名根证书内容的明文解析，默认情况下，它将输出所有可能输出的内容，如果使用了reqopt选项，则输出内容取决于reqopt选项 -reqopt 指定text 选项输出的内容,可以为多个，每个之间使用,分隔 set_serial指定生成的自签名根证书的序列号，默认情况下生成的自签名根证书序列号是0；该选项也只有在生成自签名根证书的时候有效。 -keyout 置顶新生成的私钥的输出（仅在使用了-newKey 或 -new 选项导致生成新密钥对的时候才有效，如果使用了-key则此选项被忽略） -keyform 指定输入密钥的编码格式（比如PEM，DER，PKCS#12，Netscape，IIS SGC，Engine等） -in 指定输入证书请求文件，如果使用了-new 或者 -newkey选项，此选项被忽略 -inform 指定输入证书请求文件的编码格式（比如PEM，DER） -out 指定输出证书请求文件或自签名证书文件 -noout 使用此选项后，指令将不会输出编码的证书请求或者自签名根证书到-out选项指定的文件中，一般用来测试指令或者查看证书请求的信息 -outform 指定输出证书请求文件或自签名证书的编码格式（比如PEM,DER） -pubkey 使用此选项活 指令将输出PEM编码的公钥到-out选择指定的文件中，默认情况下只输出私钥到-keyout指定的文件，并不输出公钥。 -passin 指定读取-key 选项指定的私钥所需要的解密口令，如果没有指定，私钥又有密钥的话，会弹出交互提示 -passout 指定-keyout 选项输出私钥时使用的加密口令 -nodes 表示不对私钥进行加密，如果指定此选项，则忽略-passout指定的口令；如果没有此选项，却指定了-passout则会有交互提示。 -digest 指定生成证书请求或者自签名根证书是使用的信息摘要算法，一般在生成数字签名的时候使用。 -verify 使用此选项对证书请求中的数字签名进行验证操作，并给出失败或者成功的提示信息，其验证的过程是从证书请求里面提取公钥，然后使用该公钥对证书请求的数字签名进行验证。 如果没有-key选项也没有-newkey选项，则会根据openssl.cnf中req字段的default_bits选项的参数，生成一个RSA密钥 如果没有使用-nodes选项，并且生成了新的私钥，私钥会被输出到-keyout指定的文件中时将被以DES3的CBC模式加密。 2.1.2 使用实例 生成一个新的证书请求，使用新的rsa2048位密钥，输出证书请求到request.pem，密钥到private.pem,私钥口令为12345678 1openssl req -new -newkey rsa:2048 -keyout private.pem -passout pass:12345678 -out request.pem 对证书请求签名进行验证 1openssl req -in request.pe -verify -noout 生成一个自签名的根证书 1openssl req -x509 -newkey rsa:2048 -keyout private.pem -passout pass:12345678 -out selfsign.crt 显示证书请求内容 1openssl req -text -in fd.csr -noout 2.2 ca 指令ca指令模拟一个完整的CA服务器，它包括签发用户证书，吊销证书，产生CRL及更新证书库等管理操作 2.2.1 参数选项 -config 指定要使用的配置文件，如果没有此选项，则会先查找OPENSSL_CONF或者SSLEAY_CONF定义的文件名，如果这两个环境变量都没有定义，就使用OpenSSL安装的默认路径，一般是/usr/local/openssl/openssl.cnf，具体看安装配置 -startdate 设置证书的生效时间 格式为YYMMDDHHMMSSZ指定年月日时分秒，如果没有则使用主配置文件中的default_startdate -enddate 格式跟-startdate一样 -days 设置证书的有效天数，生效时间到到期时间之间的天数，如果使用了-enddate，此选项被忽略 -name 指定配置文件中CA选项的名称 -notext 不输出明文信息到证书文件 -subj直接从指令行指定证书请求的主体名称，格式为/分割的键值对字符串，如果没有此选项，那么会弹出交互提示； -cert 参数是一个可以包含路径的文件名，该文件是一个PEM编码的X.509证书文件 -keyfile 参数是一个包含路径的文件名，文件格式可以为PEM，DER，PKCS#12，Netscape，IIS SGC，Engine，但需要通过-keyform指定到底是哪种格式 -policy 指定CA的匹配策略 -extensions 指定x509 v3扩展字段的字段名，如果没有这个选项就由-extfile中内容 -extfile 指定x509 v3扩展的配置文件，如果没有-extensions字段，则由CA主配置文件中的x509_extensions选项指定 -in 指定一个可以包含路径的证书请求文件名，应该是PEM变得PKCS#10格式的证书请求 -infiles指定一系列包含PEM编码证书请求的文件，包含多个，只能作为指令的最后一个选项，其后的参数都被认为是证书请求文件 -out 选项指定了输出签发好的证书或者新生成的CRL的文件，如果没有使用-notext选项，那么证书的明文信息也会输出到-out选项指定的文件中 -outdir选项指定了新生成的证书的输出目录，默认输出到newecerts目录，并使用.pem作为后缀，都是PEM编码。 2.3 x509x509指令能已各种方式显示一个证书的内容，也可以对一个证书的格式进行转换，还可以签发证书 2.3.1 参数选项 -in -inform -out -outform -keyform -CA 指定签发证书或者转换证书格式的时候需要的CA证书文件 -CAkey 指定签发证书或者转换证书格式时需要的CA证书对应的私钥文件路径 -CAform 指定CA证书文件的格式 -CAkeyform 私钥文件格式 -startdate -enddate -pubkey -noout 2.3.2 使用实例 使用现有证书生成证书请求文件 1openssl x509 -x509toreq -in fd.crt -out fd.csr -signkey fd.key 使用证书请求文件生成自签名证书 1openssl x509 -req -days 365 -in fd.csr -signkey fd.key -out fd.crt 显示证书内容 1openssl x509 -text -in fd.crt -noout 2.4 crl指令crl指令用于显示、处理和验证CRL文件信息 2.4.1 参数选项 -in -inform -out -outform -noout 3 开发测试使用自签名证书实例3.1 生成认证私钥 私钥 私钥要输入密码 1openssl genrsa -des3 -out qunarzz-dev-enc.key 2048 可以通过如下方式解密(输入上面的密码) 1openssl rsa -in qunarzz-dev-enc.key -out qunarzz-dev.key 3.2 生成带有SAN(Subject Alt Name)的自签名证书3.3 生成对多个主机有效的自签名证书3.4 missing_subjectAltName 问题解决原有的简单自签名证书在chrome里面不好使了，提示 missing_subjectAltName 需要全局找一份openssl.cnf ，或者下载一份openssl 那里有 123456789openssl req -new -sha256 \\ -x509 \\ -days 10000 \\ -key qunarzz-dev.key \\ -subj &quot;/C=CN/ST=BeiJing/L=Beijing/O=QUNAR/OU=FE/CN=qunarzz.com&quot; \\ -extensions SAN \\ -config &lt;(cat ./openssl.cnf \\ &lt;(printf &quot;[SAN]\\nsubjectAltName=DNS.1:qunarzz.com,DNS.2:q.qunarzz.com,DNS.3:*.qunarzz.com&quot;)) \\ -out qunarzz-dev.crt 相关字段的信息 1234567C =&gt; 国家 Country ST =&gt; 省 StateL =&gt; 市 CityO =&gt; 机构 OrganizationOU =&gt; 部门 Organization UnitCN =&gt; 域名 Common Name (证书所请求的域名)emailAddress =&gt; main administrative point of contact for the certificate 4 参考资料 《OpenSSL与网络信息安全-基础、结构和指令》 《OpenSSL攻略》 《OpenSSL编程》 OpenSSL文档 OpenSSL命令 OpenSSL 给自己颁发根证书，由根证书签发下级证书的步骤。 Nginx 使用 openssl 的自签名证书 使用 OpenSSL 制作一个包含 SAN（Subject Alternative Name）的证书 使用openssl为ssl证书增加“使用者备用名称（DNS）” openssl证书添加多个IP 使用openssl为ssl证书增加“使用者备用名称（DNS）” Multiple SSL Sites Using SubjectAltName Multiple Names on One Certificate 多个SSL站点使用SubjectAltName教程 openssl生成证书链多级证书 Subject Alt Name 完全图解 HTTPS","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"证书","slug":"证书","permalink":"http://rawbin-.github.io/tags/%E8%AF%81%E4%B9%A6/"},{"name":"自签名证书","slug":"自签名证书","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/"},{"name":"openssl","slug":"openssl","permalink":"http://rawbin-.github.io/tags/openssl/"}]},{"title":"行文风格思路描述","slug":"knowledge-management/2017-04-20-writing-style","date":"2021-12-31T02:37:59.926Z","updated":"2021-12-31T02:37:59.926Z","comments":true,"path":"knowledge-management/2017-04-20-writing-style/","link":"","permalink":"http://rawbin-.github.io/knowledge-management/2017-04-20-writing-style/","excerpt":"","text":"1 行文风格规则 一次讲一个东西，明确概念 以时间轴，将知识点串起来，形成知识链 举一反三，注重实战，灵活运用 是什么，怎么来的，怎么用，什么原理","categories":[{"name":"风格","slug":"风格","permalink":"http://rawbin-.github.io/categories/%E9%A3%8E%E6%A0%BC/"},{"name":"思路","slug":"风格/思路","permalink":"http://rawbin-.github.io/categories/%E9%A3%8E%E6%A0%BC/%E6%80%9D%E8%B7%AF/"}],"tags":[{"name":"风格","slug":"风格","permalink":"http://rawbin-.github.io/tags/%E9%A3%8E%E6%A0%BC/"},{"name":"思路","slug":"思路","permalink":"http://rawbin-.github.io/tags/%E6%80%9D%E8%B7%AF/"}]},{"title":"Web前端性能优化之协议优化","slug":"protocol/2016-10-10-http-upgrade","date":"2021-12-31T02:37:59.926Z","updated":"2021-12-31T02:37:59.926Z","comments":true,"path":"protocol/2016-10-10-http-upgrade/","link":"","permalink":"http://rawbin-.github.io/protocol/2016-10-10-http-upgrade/","excerpt":"","text":"1 参考资料 HTTP Performance Overview 完全图解 HTTPS HTTP/2 与 WEB 性能优化（一） HTTP/2 与 WEB 性能优化（二） HTTP/2 与 WEB 性能优化（三） HTTPS, SPDY和 HTTP/2性能的简单对比 HTTPS、SPDY和HTTP/2的性能比较","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"HTTP","slug":"前端开发/Web开发/HTTP","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/HTTP/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"HTTP","slug":"HTTP","permalink":"http://rawbin-.github.io/tags/HTTP/"},{"name":"HTTP2","slug":"HTTP2","permalink":"http://rawbin-.github.io/tags/HTTP2/"}]},{"title":"代码设计基本原则","slug":"dev-general/history/2017-04-21-code-design-rules","date":"2021-12-31T02:37:59.926Z","updated":"2021-12-31T02:37:59.926Z","comments":true,"path":"dev-general/history/2017-04-21-code-design-rules/","link":"","permalink":"http://rawbin-.github.io/dev-general/history/2017-04-21-code-design-rules/","excerpt":"","text":"1 DRY (Don’t Repeat Yourself) 不出现多次同样的字符串拼接 不出现多次同样的对象访问 不出现相似的函数 不出现相似的模块代码 不出现相似。。。 一切相似的东西，都应该在一个地方表达，然后复用 2 KISS (Keep It Simple,Stupid) 不过早优化 不过度设计 不复杂化代码 不断重构 3 XP (eXtreme Programming) 快速迭代 持续集成，不断重构 单元测试 4 面向对象设计原则4.1 单一职责原则 (The Single Responsibility Principle) 一个东西做一件事情，并把它做好 应该有且仅有一个原因引起类的变更 类的复杂度降低 可读性提高 可维护性提高 变更引起的风险降低 4.2 开放-封闭原则 (The Open-Close Principle) 让不能变的变不了，让可变的容易变 软件实体(类，模块，函数等)应该是可以扩展的，但是不可修改的 4.3 里氏替换原则 (The Liskov Substitution Principle) 抽象的东东能用具体的东东替代 所有引用基类的地方必须能透明地使用其子类 子类必须完全的实现父类的抽象方法 子类可以有自己的个性 覆盖或实现父类的方法时输入参数可以被放大 覆盖或实现父类的方法时输出结果可以被缩小 4.4 接口隔离原则 (The Interface Segregation Principle) 不相关的就不能强制被关注 不应该强迫使用者依赖于他们不用的方法 类间的依赖关系应该建立在最小的接口上 接口尽量要小 接口要高内聚 可提供定制 接口设计粒度要适度 4.5 依赖导致原则 (The Dependency Inversion Principle) 容易变的不能被公用 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 抽象不应该依赖于细节，细节应该依赖于抽象 4.6 最少知识原则 (Least Knowledge Principe)，迪米特法则(Low of Demeter) 不涉及到的就不应该关注 出现在成员变量，方法的输入输出参数中的类被称为朋友类 只和朋友交流 尽量内敛，少对外开放接口 5 参考资料 《程序员修炼之道-从小共到专家》,The Pragmatic Programmer, From Journeyman to Master 《敏捷软件开发：原则、模式和实践》 《您的设计模式》 《设计模式之禅》","categories":[{"name":"代码设计","slug":"代码设计","permalink":"http://rawbin-.github.io/categories/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"},{"name":"程序设计","slug":"代码设计/程序设计","permalink":"http://rawbin-.github.io/categories/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://rawbin-.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"name":"代码设计","slug":"代码设计","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"},{"name":"可维护代码","slug":"可维护代码","permalink":"http://rawbin-.github.io/tags/%E5%8F%AF%E7%BB%B4%E6%8A%A4%E4%BB%A3%E7%A0%81/"}]},{"title":"浏览器发展历史简介","slug":"dev-general/history/2017-04-23-browser-history","date":"2021-12-31T02:37:59.926Z","updated":"2021-12-31T02:37:59.927Z","comments":true,"path":"dev-general/history/2017-04-23-browser-history/","link":"","permalink":"http://rawbin-.github.io/dev-general/history/2017-04-23-browser-history/","excerpt":"","text":"1 参考资料 《Web之困-现代Web应用安全指南》 网络的演变 内涵美图 Browser Timelines Web Browser History History of the web browser Browser Evolution – The History of Web Browsers [Infographic] List of web browsers Comparison of web browsers Web browsers: a brief history The History of Web Browsers 浏览器演变史 详评1991年以来的浏览器 浏览器历史和发展趋势浅析 浏览器 发展历史 网页浏览器发展详史 浏览器发展史 浏览器发展历史 浏览器发展简史[图表] 网络导航者：主要互联网浏览器发展历程回顾 回顾IE浏览器20年成长史 浏览器野史 UserAgent列传（上）","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"Browser","slug":"Browser","permalink":"http://rawbin-.github.io/tags/Browser/"}]},{"title":"Web发展历史简介","slug":"dev-general/history/2017-04-22-web-history","date":"2021-12-31T02:37:59.926Z","updated":"2021-12-31T02:37:59.926Z","comments":true,"path":"dev-general/history/2017-04-22-web-history/","link":"","permalink":"http://rawbin-.github.io/dev-general/history/2017-04-22-web-history/","excerpt":"","text":"1 参考资料 W3C Blog: 25年前开始改变世界 - Web的早期历史 Long Description of W3C10 Timeline Graphi A Little History of the World Wide Web 《沸腾十五年》 《计算机网络 自顶向下方法》 《深入理解计算机网络》 互联网和Web的历史 以及Web标准的演化 网络的演变 内涵美图可操作 The Internet The World Wide Web (WWW) Browser Timelines 第一个网站相关 Web的50年——从Tim Berners-Lee的图灵奖说起 运营简史：一文读懂互联网运营的20年发展与演变 中国互联网20年发展简史 互联网完整发展历史一览——信息图 [中国互联网发展史]国际互联网发展历史 回眸历史：图说中国互联网20年发展历程 互联网的历史（1969-2009） 互联网时代，我眼中的架构变迁 《Web之困-现代Web应用安全指南》 新闻背景：中国接入互联网20年大事记 回顾1994-2015：中国接入国际互联网21年 中国是咋接入世界互联网的？ 中国互联网事件 中国互联网接入史 中国互联网发展的历史阶段划分 Web开发技术发展史 Web开发技术发展史 Web研发模式演变 Web研发模式演变 Web开发发展史 前端发展史 前端发展史 前端发展历程","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Web发展","slug":"Web发展","permalink":"http://rawbin-.github.io/tags/Web%E5%8F%91%E5%B1%95/"},{"name":"Web历史","slug":"Web历史","permalink":"http://rawbin-.github.io/tags/Web%E5%8E%86%E5%8F%B2/"}]},{"title":"异步JavaScript实践 NodejS事件循环","slug":"async/2016-10-03-async-javascript","date":"2021-12-31T02:37:59.925Z","updated":"2021-12-31T02:37:59.925Z","comments":true,"path":"async/2016-10-03-async-javascript/","link":"","permalink":"http://rawbin-.github.io/async/2016-10-03-async-javascript/","excerpt":"","text":"1 参考资料 不要混淆nodejs和浏览器中的event loop 一次弄懂Event Loop（彻底解决此类面试问题） Node.js的事件驱动模型 Nodejs的事件驱动模型 被误解的 Node.js JavaScript 事件模型 事件处理机制 Node.js机制及原理理解初步 Node.js应用实战和工作原理解析 深入浅出Node.js（四）：Node.js的事件机制 Nodejs源码的阅读-事件循环的建立 Nodejs源码的阅读-事件循环的过程 Promise的前世今生和妙用技巧","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"http://rawbin-.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"}]},{"title":"Seajs 参考文档","slug":"modules/2016-10-06-javascript-modular-seajs","date":"2021-12-31T02:37:59.925Z","updated":"2021-12-31T02:37:59.925Z","comments":true,"path":"modules/2016-10-06-javascript-modular-seajs/","link":"","permalink":"http://rawbin-.github.io/modules/2016-10-06-javascript-modular-seajs/","excerpt":"","text":"1 参考资料 Seajs 手册与文档 Seajs介绍文档 Seajs简易文档 Seajs从入门到原理 用Webpack打包你的一切 CommonJS规范 CommonJS Spec 概览 CommonJS规范介绍 Modules规范 Modules 1.1.1规范 Package 1.0规范 CommonJS-AMD AMD 规范 AMD github CMD 规范 CMD github UMD github 关于AMD,CMD,CommonJS及UMD规范 coolie模块化规范介绍","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"CMD","slug":"CMD","permalink":"http://rawbin-.github.io/tags/CMD/"},{"name":"SeaJS","slug":"SeaJS","permalink":"http://rawbin-.github.io/tags/SeaJS/"}]},{"title":"JavaScript模块化规范CommonJS,AMD,CMD,ES6 Module","slug":"modules/2016-10-06-javascript-modular","date":"2021-12-31T02:37:59.925Z","updated":"2021-12-31T02:37:59.925Z","comments":true,"path":"modules/2016-10-06-javascript-modular/","link":"","permalink":"http://rawbin-.github.io/modules/2016-10-06-javascript-modular/","excerpt":"","text":"1 参考资料 回顾：前端模块化和AMD、CMD规范（全） CommonJS规范 CommonJS Spec 概览 Modules规范 Modules 1.1.1规范 Package 1.0规范 CommonJS-AMD AMD 规范 AMD github CMD 规范 Seajs从入门到原理 CMD github UMD github 关于AMD,CMD,CommonJS及UMD规范 coolie模块化规范介绍","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"模块化规范","slug":"模块化规范","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/"}]},{"title":"前端工程化打包工具","slug":"dev-tools/2016-10-06-fe-toolkits","date":"2021-12-31T02:37:59.925Z","updated":"2021-12-31T02:37:59.925Z","comments":true,"path":"dev-tools/2016-10-06-fe-toolkits/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-10-06-fe-toolkits/","excerpt":"","text":"1 工具列表1.1 rollup github rollup doc 1.2 ykit github qunar ued ykit doc 1.3 webpack github webpack doc 1.4 fekit github qunar ued fekit doc 前端工程化工具Fekit分析 1.5 fis github fis doc 1.6 coolie github coolie doc fed coolie doc 1.7 fastpack github fastpack doc 1.8 parcel github 2 老牌通用自动化工具 grunt gulp 3 参考资料 前端构建工具漫谈，fis3、webpack、rollup.js","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"工程化","slug":"工程化","permalink":"http://rawbin-.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"NodeJS 图片识别 图片转文字","slug":"cross-platform/nodejs/2016-10-03-nodejs-ocr","date":"2021-12-31T02:37:59.925Z","updated":"2021-12-31T02:37:59.925Z","comments":true,"path":"cross-platform/nodejs/2016-10-03-nodejs-ocr/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2016-10-03-nodejs-ocr/","excerpt":"","text":"1 参考资料 用node.js实现验证码简单识别 腾讯优图github 腾讯图片识别API","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"图片识别","slug":"图片识别","permalink":"http://rawbin-.github.io/tags/%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/"}]},{"title":"NodeJS 并发 并行处理，高性能计算","slug":"cross-platform/nodejs/2016-10-05-nodejs-multi-process","date":"2021-12-31T02:37:59.925Z","updated":"2021-12-31T02:37:59.925Z","comments":true,"path":"cross-platform/nodejs/2016-10-05-nodejs-multi-process/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2016-10-05-nodejs-multi-process/","excerpt":"","text":"1 参考资料 Nodejs·进程 Node.js的线程和进程 Node.js调试指南","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"http://rawbin-.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"}]},{"title":"目录结构-前端工程化模块化之目录结构","slug":"dev-env/2016-09-26-fe-project-structure","date":"2021-12-31T02:37:59.924Z","updated":"2021-12-31T02:37:59.924Z","comments":true,"path":"dev-env/2016-09-26-fe-project-structure/","link":"","permalink":"http://rawbin-.github.io/dev-env/2016-09-26-fe-project-structure/","excerpt":"","text":"1 项目中经常出现的结构和文件1.1 src 源代码所在目录 1.2 doc/docs 设计文档/API等所在目录 1.3 dist 生成的发布文件所在目录 1.4 test/tests 测试用例,单元测试所在目录 1.5 demo/example/expmples 可运行的功能使用样例代码所在目录 1.6 package.json npm项目的主配置文件 1.7 bower.json 使用bower管理的node项目的包依赖配置文件 1.8 ChangeLog/ChangeLog.md/CHANGELOG 项目的版本发布流水账 1.9 ReadMe/ReadMe.md/README 项目的整体概要说明文件，比如说明项目的特性，如何部署，如何使用等 1.10 .babelrc babel转换工具的配置文件，参考 参考样例文件 12345678&#123; &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: [&quot;transform-es2015-modules-umd&quot;]， &quot;ignore&quot;: [ &quot;foo.js&quot;, &quot;bar/**/*.js&quot; ]&#125; 1.11 .npmignore 在发布到npm源上需要忽略的文件 npm默认的配置文件，如果需要添加此外的文件(node_modules除外)，需要自己再添加 123456789101112.*.swp._*.DS_Store.git.hg.npmrc.lock-wscript.svn.wafpickle-*config.gypiCVSnpm-debug.log ​ 1.12 LICENCE/LICENSE 项目支持的开源协议许可 可以到这里,或者这里查看一个完整的列表 样例文件参考 MIT 1234567Copyright &lt;YEAR&gt; &lt;COPYRIGHT HOLDER&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ​ 1.13 .gitignore 是git用来区分哪些文件需要不加入版本库（被忽略）的配置文件，只影响未加入版本库的文件，所以这个最好在项目开始就搞好。 如果你不了解，可以到这里去下载一个相似的模板，也可以到这里 去自动生成一个更详尽的，需要本地配置参考这里。 解析匹配规则参考git doc,Linux glob 常用规则 #开头的行和空行不对规则产生影响，常用来做注释和格式化 单纯的字符串表示同名的目录或文件 ?匹配单个字符,*匹配多个字符,!表示对规则例外 [a-z]表示匹配范围中的任何一个字符，[!a-z]表示匹配不在此范围内的任何一个字符 通配字符不匹配路径中的/字符，也不匹配.字符 以/开头的只匹配当前目录下的文件 以/结尾的规则表示匹配一个目录 路径中的**匹配多层级的目录结构 样例配置参考(在这里自动生成的macOS下用WebStorm做Node开发的配置) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131# Created by https://www.gitignore.io/api/node,macos,webstorm### Node #### Logslogs*.lognpm-debug.log*# Runtime datapids*.pid*.seed*.pid.lock# Directory for instrumented libs generated by jscoverage/JSCoverlib-cov# Coverage directory used by tools like istanbulcoverage# nyc test coverage.nyc_output# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files).grunt# node-waf configuration.lock-wscript# Compiled binary addons (http://nodejs.org/api/addons.html)build/Release# Dependency directoriesnode_modulesjspm_packages# Optional npm cache directory.npm# Optional eslint cache.eslintcache# Optional REPL history.node_repl_history# Output of &#x27;npm pack&#x27;*.tgz# Yarn Integrity file.yarn-integrity### macOS ###*.DS_Store.AppleDouble.LSOverride# Icon must end with two \\rIcon# Thumbnails._*# Files that might appear in the root of a volume.DocumentRevisions-V100.fseventsd.Spotlight-V100.TemporaryItems.Trashes.VolumeIcon.icns.com.apple.timemachine.donotpresent# Directories potentially created on remote AFP share.AppleDB.AppleDesktopNetwork Trash FolderTemporary Items.apdisk### WebStorm #### Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and Webstorm# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839# User-specific stuff:.idea/workspace.xml.idea/tasks.xml# Sensitive or high-churn files:.idea/dataSources/.idea/dataSources.ids.idea/dataSources.xml.idea/dataSources.local.xml.idea/sqlDataSources.xml.idea/dynamic.xml.idea/uiDesigner.xml# Gradle:.idea/gradle.xml.idea/libraries# Mongo Explorer plugin:.idea/mongoSettings.xml## File-based project format:*.iws## Plugin-specific files:# IntelliJ/out/# mpeltonen/sbt-idea plugin.idea_modules/# JIRA pluginatlassian-ide-plugin.xml# Crashlytics plugin (for Android Studio and IntelliJ)com_crashlytics_export_strings.xmlcrashlytics.propertiescrashlytics-build.propertiesfabric.properties### WebStorm Patch #### Comment Reason: https://github.com/joeblau/gitignore.io/issues/186#issuecomment-215987721# *.iml# modules.xml# .idea/misc.xml# *.ipr# End of https://www.gitignore.io/api/node,macos,webstorm ​ 1.14 .editorconfig 是用来维护同一套代码在不同的编辑环境中的代码风格一致性的配置文件。 这个工具目前有多种语言的开发库，并对目前常见的编辑器和IDE都有相应的插件适配，是一个靠谱的方案。 使用EditorConfig的项目列表, Node.js的配置文件, webpack的配置文件 通配符参考 * 匹配除/之外的任意单个字符 **匹配字符串 ?匹配任意单个字符 [xyz]匹配中括号内的任一字符 [!xyz]匹配不在中括号内的任一字符 [a-z]匹配范围内的任一字符 &#123;abc,opq,xyz&#125;匹配这三个字符串中的任何一个 {123..456}匹配两个数字之间的任何一个 常用属性参考, 全部属性 root=true表示到此终止对.editorconfig配置的查找，这里就是最顶层的配置 indent_style 可选值为tab,space,unset 设置缩进的风格 indent_size 当indent_style=space时的缩进字符数 tab_width当indent_style=tab时的缩进字符数 end_of_line可选值为lf，cr,crlf，设置换行的风格 charset 设置编码比如utf-8 trim_trailing_whitespace可选值为true,false设置是否删除行尾空白符 intsert_final_newline可选值true，false设置是否添加文件结尾的空行 样例配置参考 1234567891011121314151617181920212223root = true[*]indent_style = tabindent_size = 4charset = utf-8trim_trailing_whitespace = trueinsert_final_newline = truemax_line_length = 233[*.json]indent_style = spaceindent_size = 2[*.yml]indent_style = spaceindent_size = 2[test/cases/parsing/bom/bomfile.&#123;css,js&#125;]charset = utf-8-bom[*.md]trim_trailing_whitespace = false 2 参考资料 git ignore files gitignore gitignore.io glob wiki Linux glob editorconfig github editorconfig.org 开源协议说明 OpenSource 开源协议说明 SPDX babelrc配置","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"工程化","slug":"工程化","permalink":"http://rawbin-.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"http://rawbin-.github.io/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"http://rawbin-.github.io/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"}]},{"title":"组件化-前端工程化模块化之组件化","slug":"modules/2016-09-26-fe-project-modules","date":"2021-12-31T02:37:59.924Z","updated":"2021-12-31T02:37:59.924Z","comments":true,"path":"modules/2016-09-26-fe-project-modules/","link":"","permalink":"http://rawbin-.github.io/modules/2016-09-26-fe-project-modules/","excerpt":"","text":"1 组件化 一个组件的构成部分大致可以分为三部分 组件交互逻辑 组件呈现模板 组件渲染样式 2 CSS 模块化 参考这篇简单易懂的CSS Modules 参考工具postcss 3 参考资料 AlloyTeam：致我们终将组件化的 Web (多图) W3C Web Components Web应用的组件化 Web应用的组件化进阶篇 Web应用组件化的权衡 组件化的css-module MUI高性能前端框架(组件库) BEM Block Element Modifier CSS Modules CSS Modules文档 CSS Modules用法教程 如何评价CSS Modules 谈谈 CSS Modules The End of Global CSS 理解CSS模块化 CSS模块化开发 简单易懂的CSS Modules CSS Module是实现方案 CSS Modules 详解及 React 中实践 CSS Modules 详解及 React 中实践 CSS Modules Injector CSS Module在webpack中的使用 CSS Module总结 从模块化CSS到面向对象CSS OOCSS 面向对象的CSS W3C CSS CSS Related Standards postcss","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"工程化","slug":"工程化","permalink":"http://rawbin-.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"http://rawbin-.github.io/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"http://rawbin-.github.io/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"}]},{"title":"mocha-前端工程化模块化工具之mocha","slug":"dev-tools/2016-09-25-fe-project-tools-mocha","date":"2021-12-31T02:37:59.924Z","updated":"2021-12-31T02:37:59.924Z","comments":true,"path":"dev-tools/2016-09-25-fe-project-tools-mocha/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-09-25-fe-project-tools-mocha/","excerpt":"","text":"看这里体会一下效果，结构一目了然，点击测试行，还能看到具体的测试代码。 1 NodeJS环境测试基本看一遍Mocha官网的说明，就可以玩起来了。 先安装npm install mocha -g,这样就可以在命令行使用mocha命令了。 再找一个断言库，chai的功能比较丰富，npm install chai --save-dev 然后建立一个tests目录,在里面创建js文件写测试代码 describe 代表描述信息目录，it代表具体的用例 注意引入断言库，要用it包含断言语句才会被当做case 使用mocha命令执行刚刚的测试文件就ok。 也可以在IDE中搞Mocha相关的插件 2 浏览器环境测试 使用mocha init PATH，初始化一个用于浏览器中展示Test Case的资源目录。 这里面有一个tests.js，在这里面引入上文说到的各个测试文件 然后执行browserify tests.js&gt;tests-browser.js 转换浏览器中能执行的文件 将html中的tests.js改为转换后的 打开页面就可 3 针对ES6+的测试代码的测试 安装babel 依赖 使用mocha --compilers js:babel/register 执行测试 4 其他说明 mocha 默认查找 ./test/*.js,./test/*.coffee,如果代码在这里就可以不用指定路径 5 参考资料 mocha 官网 测试框架 Mocha 实例教程 javascript单元测试框架mochajs详解 JavaScript单元测试框架JsUnit基本介绍和使用 JavaScript 单元测试框架：Jasmine 初探 JavaScript单元测试框架-Jasmine 边译边学-QUnit下的JavaScript自动化单元测试 Javascript单元测试框架比较Qunit VS Jasmine","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"工程化","slug":"工程化","permalink":"http://rawbin-.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"mocha","slug":"mocha","permalink":"http://rawbin-.github.io/tags/mocha/"},{"name":"单元测试","slug":"单元测试","permalink":"http://rawbin-.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"grunt-前端工程化模块化工具之grunt","slug":"dev-tools/2016-09-25-fe-project-tools-grunt","date":"2021-12-31T02:37:59.924Z","updated":"2021-12-31T02:37:59.924Z","comments":true,"path":"dev-tools/2016-09-25-fe-project-tools-grunt/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-09-25-fe-project-tools-grunt/","excerpt":"","text":"1 简介 ​ 2 参考资料 grunt 中文文档 grunt 英文文档","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"工程化","slug":"工程化","permalink":"http://rawbin-.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"http://rawbin-.github.io/tags/webpack/"},{"name":"工作流","slug":"工作流","permalink":"http://rawbin-.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"}]},{"title":"npm-前端工程化模块化工具之npm","slug":"dev-tools/2016-09-25-fe-project-tools-npm","date":"2021-12-31T02:37:59.924Z","updated":"2021-12-31T02:37:59.924Z","comments":true,"path":"dev-tools/2016-09-25-fe-project-tools-npm/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-09-25-fe-project-tools-npm/","excerpt":"","text":"1 npmnpm 是Node平台的包管理器，跟各大操作系统类似Mac的appStore，brew，安卓的市场，window的商店，Ubuntu的apt-get，RedHat的yum；各大语言也有类似的实现Java的ant，maven，Python的pip，Ruby的gem,PHP 的Composer等。 各种安装不上的问题解决 将如下内容让入.bashrc 1234export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node/export NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node/export CHROMEDRIVER_CDNURL=https://npm.taobao.org/mirrors/chromedriverexport SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass 2 package.jsonnpm 在项目中的直接体现就是package.json 样例文件参考 文档说明 通过npm init生成相应的配置文件 一个基本的样例，最重要和必不可少的是name 和version 字段 1234567891011121314151617181920212223242526272829303132333435&#123; &quot;name&quot;: &quot;algorithms-combined-js&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;description&quot;: &quot;algorithms for combined&quot;, &quot;main&quot;: &quot;libs/index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;:&quot;babel src -d libs&quot;, &quot;prepublish&quot;:&quot;npm run build&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/rawbin-/algorithms-combined-js.git&quot; &#125;, &quot;keywords&quot;: [ &quot;algorithms&quot;, &quot;javascript&quot;, &quot;combination&quot;, &quot;arrangement&quot; ], &quot;author&quot;: &quot;rawbin-&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;bugs&quot;: &#123; &quot;url&quot;: &quot;https://github.com/rawbin-/algorithms-combined-js/issues&quot; &#125;, &quot;homepage&quot;: &quot;https://github.com/rawbin-/algorithms-combined-js#readme&quot;, &quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.18.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.18.0&quot;, &quot;babel-preset-stage-0&quot;: &quot;^6.16.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;underscore&quot;: &quot;^1.8.3&quot; &#125;&#125; 依赖的版本配置 版本的配置有讲究，经常的兼容性问题都出在这，比如node-sass，多版本react等 使用&gt; &gt;= &lt; &lt;= = 和 ||来组合具体范围 使用-来指定范围 使用x X * 或者 留空 来指定版本通配 使用~来指定最邻近右边的大版本范围，放开小版本的变更 使用^来限定最左边的大版本 files 字段明确指定包含的文件 比如 package.json ReadMe.md ChangeLog LICENCE main 字段指定当前包的默认加载文件 index.js bin 字段指定当前项目的可执行文件名称和路径配置，一般包含一些自定义的项目命令 scripts 配置使用npm能运行的脚本的命令，这个字段的内容比较丰富，也经常用到 命令列表 prepublish publish postpublish preinstall install postinstall preuninstall uninstall postuninstall preversion version postversion pretest test posttest prestop stop poststop prestart start poststart prerestart restart postrestart 任意命令的运行方式为npm run scriptname,特殊的start stop restart test 可以直接用npm scriptname来运行 scripts参考文档 3 常用命令 npm i xxx -g === npm install xxx --global npm i xxx -S === npm install xxx --save npm i xxx -D === npm install xxx --save-dev npm un xxx === npm uninstall xxx npm publish xxx npm unpublish xxx 3.1 npm与yarn命令映射 npm向yarn迁移 4 编码相关 编码规范 相关文件和配置 5 参考资料 npm 文档 npm scripts使用指南 package.json说明 sermver 版本说明 开源协议说明 OpenSource 开源协议说明 SPDX yarn与npm对比","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"工程化","slug":"工程化","permalink":"http://rawbin-.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"npm","slug":"npm","permalink":"http://rawbin-.github.io/tags/npm/"},{"name":"包管理","slug":"包管理","permalink":"http://rawbin-.github.io/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"}]},{"title":"webpack-前端工程化模块化工具之webpack","slug":"dev-tools/2016-09-25-fe-project-tools-webpack","date":"2021-12-31T02:37:59.924Z","updated":"2021-12-31T02:37:59.924Z","comments":true,"path":"dev-tools/2016-09-25-fe-project-tools-webpack/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-09-25-fe-project-tools-webpack/","excerpt":"","text":"1 简介1.1 基本思想 webpack 的核心是js，它将所有能引用的资源都转换成js来处理，通过loader来适配所有的资源加载，通过plugin来处理其他相应的代码转换之外的事情。 1.2 学习曲线 1.x 说明了webpack的总体思想和功能块，更加完善和全面；但2.x的文档分类更加明晰，更容易学习 这里是一个完整的实例。 如果没有接触过webpack ，可以直接从2.x上手 如果有过1.x的实践，可以通过2.x的文档重新学习和巩固，并注意 1.x到2.x之间的区别 涉及到的概念 一些应用实例 1.3 关键配置 参考文档 1.4 重要概念1.4.1 loader 代码和数据的预处理器或转换器，是一个输入为转换前资源内容输出为转换后资源内容的功能块（函数），webpack1.x的用法实例 可以链式调用，最后一个loader需要输出JavaScript，用在其他位置的可以输出任意格式 loaders介绍 loaders使用 如何写一个loader 1.4.2 plugin 打包过程数据额外的处理器或功能增强，不一定有输出，也可以有额外的输出。 订阅打包过程中的各阶段的事件的回调处理 插件介绍 插件使用 如何写一个plugin 2 参考资料 Webpack 中文指南 webpack文档索引 webpack 1.x 文档 webpack 2.x 文档 webpack入门看这篇就够了 webpack参考资料","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"工程化","slug":"工程化","permalink":"http://rawbin-.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"http://rawbin-.github.io/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"http://rawbin-.github.io/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"}]},{"title":"前端性能监控分析","slug":"performance/2016-09-20-performance-monitor","date":"2021-12-31T02:37:59.923Z","updated":"2021-12-31T02:37:59.923Z","comments":true,"path":"performance/2016-09-20-performance-monitor/","link":"","permalink":"http://rawbin-.github.io/performance/2016-09-20-performance-monitor/","excerpt":"","text":"1 参考资料 使用性能API快速分析web前端性能 使用简洁的 Navigation Timing API 测试网页加载速度（不完全译文） Performance API","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"调试","slug":"调试","permalink":"http://rawbin-.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"Inspect","slug":"Inspect","permalink":"http://rawbin-.github.io/tags/Inspect/"},{"name":"性能分析","slug":"性能分析","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"}]},{"title":"高性能NodeJS JavaScript","slug":"performance/2016-09-22-high-performance-node","date":"2021-12-31T02:37:59.923Z","updated":"2021-12-31T02:37:59.923Z","comments":true,"path":"performance/2016-09-22-high-performance-node/","link":"","permalink":"http://rawbin-.github.io/performance/2016-09-22-high-performance-node/","excerpt":"","text":"1 参考资料 NodeJS的线程和进程 Node.js调试指南 node.js cluster多进程、负载均衡和平滑重启 解读Nodejs多核处理模块cluster async Node.js的cluster模块——Web后端多进程服务 Node Core Cluster NodeJS 爬虫","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"高性能","slug":"高性能","permalink":"http://rawbin-.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"}]},{"title":"ESLint 配置及应用","slug":"dev-tools/2016-09-01-eslint-application","date":"2021-12-31T02:37:59.923Z","updated":"2021-12-31T02:37:59.923Z","comments":true,"path":"dev-tools/2016-09-01-eslint-application/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-09-01-eslint-application/","excerpt":"","text":"1 安装方式 全局安装 npm install eslint -g eslint --init生成配置文件 局部安装 npm install eslint --save-dev 2 配置方式 注释配置，在代码文件中设置相应的规则 12/* eslint-disable *//* eslint-enable */ ​ 配置文件，单独的配置文件.eslintrc.*文件，作用范围是其所在的的目录及其子目录；配置的范围包括环境，全局变量和规则。 JavaScript格式 .eslintrc.js 12345678910111213module.exports = &#123; &quot;parser&quot;:&quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: 6, &quot;sourceType&quot;: &quot;module&quot;, &quot;ecmaFeatures&quot;: &#123; &quot;jsx&quot;: true &#125; &#125;, &quot;rules&quot;: &#123; &quot;semi&quot;: 2 &#125;&#125; ​ JSON格式 .eslintrc.json 12345678910111213&#123; &quot;parser&quot;:&quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: 6, &quot;sourceType&quot;: &quot;module&quot;, &quot;ecmaFeatures&quot;: &#123; &quot;jsx&quot;: true &#125; &#125;, &quot;rules&quot;: &#123; &quot;semi&quot;: 2 &#125;&#125; ​ YAML格式 .eslintrc.yml或者.eslintrc.yaml 12345---parser: babel-eslintrules: package.json 配置 package.json 中 eslintConfig 配置 12345678910&#123; &quot;name&quot;: &quot;mypackage&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;eslintConfig&quot;: &#123; &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;node&quot;: true &#125; &#125;&#125; ​ 3 禁用配置方式 注释方式 禁用单行上的多个规则 1234alert(&#x27;foo&#x27;); // eslint-disable-line no-alert, quotes, semi// eslint-disable-next-line no-alert, quotes, semialert(&#x27;foo&#x27;); 禁用单行上的单个规则 1234alert(&#x27;foo&#x27;); // eslint-disable-line no-alert// eslint-disable-next-line no-alertalert(&#x27;foo&#x27;); 禁用单行上的所有规则 1234alert(&#x27;foo&#x27;); // eslint-disable-line// eslint-disable-next-linealert(&#x27;foo&#x27;); 禁用整个文件中的某个规则 123/* eslint-disable no-alert */alert(&#x27;foo&#x27;); 禁用整个文件的多个规则 1234/* eslint-disable no-alert, no-console */alert(&#x27;foo&#x27;);console.log(&#x27;bar&#x27;); 禁用整个文件的所有规则 123/* eslint-disable */alert(&#x27;foo&#x27;); ​ 配置文件方式 .eslintignore 文件，语法同.gitignore 12path/to/filepath/to/directory/* 4 配置内容 配置文件中包含几部分内容 parserOptions 解析器版本校验 parser解析器 env运行环境，node，browser等 globals额外的全局变量 plugins相关的插件 具体的配置规则，规则列表参考 5 配置注意事项 同一个目录下出现了不同的配置，优先级别 .eslintrc.js .eslintrc.yaml .eslintrc.yml .eslintrc.json .eslintrc package.json 在配置中使用root:true 来设置项目工根配置 eslint会直接找上级目录直到找到根目录，如果还是没找到，还是会用~/.eslintrc这个文件。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/categories/JavaScript/"},{"name":"Web前端","slug":"JavaScript/Web前端","permalink":"http://rawbin-.github.io/categories/JavaScript/Web%E5%89%8D%E7%AB%AF/"},{"name":"Web开发","slug":"JavaScript/Web前端/Web开发","permalink":"http://rawbin-.github.io/categories/JavaScript/Web%E5%89%8D%E7%AB%AF/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"eslint","slug":"eslint","permalink":"http://rawbin-.github.io/tags/eslint/"},{"name":"规范检查","slug":"规范检查","permalink":"http://rawbin-.github.io/tags/%E8%A7%84%E8%8C%83%E6%A3%80%E6%9F%A5/"}]},{"title":"Chrome 开发者工具 Inspect 使用","slug":"dev-tools/2016-09-20-chrome-developer-tools","date":"2021-12-31T02:37:59.923Z","updated":"2021-12-31T02:37:59.923Z","comments":true,"path":"dev-tools/2016-09-20-chrome-developer-tools/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-09-20-chrome-developer-tools/","excerpt":"","text":"1 参考资料 Chrome DevTools Chrome 开发工具指南 网络标签 时间轴标签 Profile 标签1 Profile标签2 ​","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"调试","slug":"调试","permalink":"http://rawbin-.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"Inspect","slug":"Inspect","permalink":"http://rawbin-.github.io/tags/Inspect/"},{"name":"性能分析","slug":"性能分析","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"}]},{"title":"babel-前端工程化模块化工具之babel","slug":"dev-tools/2016-09-25-fe-project-tools-babel","date":"2021-12-31T02:37:59.923Z","updated":"2021-12-31T02:37:59.924Z","comments":true,"path":"dev-tools/2016-09-25-fe-project-tools-babel/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-09-25-fe-project-tools-babel/","excerpt":"","text":"[TOC]{:toc} 1 Babel1.1 为什么要用这个？ 目前各大浏览器对ES2015+ 的支持参差不齐，需要一个统一的转换工具来将ES6+的代码转成浏览器都支持的ES5的代码，以便适配是有运行环境。这就需要一个代码转换工具，刚开始的时候出现和好些个类似的代码转换工具，到最后慢慢的就剩下Babel的声音了。 1.2 能做哪些事？ 代码转换，通过不同插件来对不同新功能的代码转换做相应的支持，比如ES6，React等 代码填充，上面的只是对代码做翻译，这里是对ES5没有的代码，而ES6+有的对象和API做补充实现。 代码映射，转换后的代码跟转换前的代码的映射，方便调试。 1.3 如何安装 这里 有对各种环境下使用babel的配置说明。 1.4 相关介绍 babel-cli 主要包含babel 的可执行文件，包含babel命令和babel-node这个交互环境 babel-register 是一个对require的装饰版本，可以直接引用相应的模块，并自动转码 babel-core 整个转码的主体工具，包含解析，转义和代码生成。 babel-polyfill 整个新特性的对象和API的补充实 相关插件的介绍 详情参考 babel-preset-latest 包含所有年度更新的转码，目前是es2015,es2016,es2017。。。 babel-preset-env 默认跟babel-preset-latest功能一致，对环境的配置更加灵活，可定制程度更高 babel-preset-react 包含React相关的的转码 babel-preset-stage-x 包含所有非标准的提议的转码 前面的都包含后面的(包含stage-1,stage-2,stage-3),参考 1.5 注意事项 babel 推荐项目本地安装而不是全局安装，这样项目之间的babel版本可以独立不一致 1npm install babel-cli --save-dev 1234#package.json&quot;scripts&quot;:&#123; &quot;build&quot;:&quot;babel src -d lib&quot;&#125; 1npm run build babel 相关的配置选项可以砸命令行中指定，更推荐的是配置的形式，放入项目根目录下的.babelrc,详细配置 123&#123; &quot;presets&quot;:[&quot;env&quot;,&quot;react&quot;]&#125; 并确保在项目的依赖中安装了相应的依赖包 一个比较懒的方法是包含babel-preset-env插件来包含所有相关的插件的最新版本，同时配置更加灵活 babel多用来多ES6+的代码进行转码，但模块化的代码是需要支持ES5 和ES6+的语法，也就是CMD的模块和ES6的模块引入的方式都是需要支持的,输出的代码需要支持require 和 import 1234567891011const PI = 3.14let square = edge =&gt; edge * edgeexport default &#123; PI, square&#125;export &#123; PI, square&#125; ​ 2 参考资料 babel github babel英文手册 babel中文手册 babel入门教程","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://rawbin-.github.io/tags/ES6/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"工程化","slug":"工程化","permalink":"http://rawbin-.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"Babel","slug":"Babel","permalink":"http://rawbin-.github.io/tags/Babel/"},{"name":"代码转换","slug":"代码转换","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2/"}]},{"title":"Node 命令行工具开发","slug":"cross-platform/nodejs/2016-09-22-node-command-line","date":"2021-12-31T02:37:59.923Z","updated":"2021-12-31T02:37:59.923Z","comments":true,"path":"cross-platform/nodejs/2016-09-22-node-command-line/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2016-09-22-node-command-line/","excerpt":"","text":"1 NodeJS 基本命令行工具 新建并初始化工程 123mkdir node-cmdcd node-cmdnpm init 在工程目录下增加 bin目录 mkdir bin 在工程目录下的package.json中增加bin的配置 12345&#123; &quot;bin&quot;:&#123; &quot;testcmd&quot;:&quot;./bin/testcmd.js&quot; &#125;&#125; 在bin 目录下新建文件testcmd.js 123#!/usr/bin/env nodeconsole.log(&#x27;hello node cmd&#x27;) 注册命令行到全局npm npm link 执行测试命令 testcmd 2 参考资料 Node.js 命令行程序开发教程","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"命令行","slug":"命令行","permalink":"http://rawbin-.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}]},{"title":"Node 数据库 ORM","slug":"cross-platform/nodejs/2016-09-23-node-orm","date":"2021-12-31T02:37:59.923Z","updated":"2021-12-31T02:37:59.923Z","comments":true,"path":"cross-platform/nodejs/2016-09-23-node-orm/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2016-09-23-node-orm/","excerpt":"","text":"1 参考资料 Node.js ORM 框架 sequelize 实践 Sequelize 中文API文档－1. 快速入门、Sequelize类 Sequelize 中文API文档－2. Model 的定义、使用与Model类的API Sequelize 中文API文档－3. 模型（表）之间的关系/关联 Sequelize 中文API文档－4. 查询与原始查询 Sequelize中文API文档 Sequelize Sequelize read the doc hapi-sequelize async.js async中文文档 ​","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"数据库","slug":"数据库","permalink":"http://rawbin-.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"ORM","slug":"ORM","permalink":"http://rawbin-.github.io/tags/ORM/"}]},{"title":"Hybrid 实现原理","slug":"architecture/2016-08-11-hybrid-internal","date":"2021-12-31T02:37:59.922Z","updated":"2021-12-31T02:37:59.922Z","comments":true,"path":"architecture/2016-08-11-hybrid-internal/","link":"","permalink":"http://rawbin-.github.io/architecture/2016-08-11-hybrid-internal/","excerpt":"","text":"1 参考资料 Hybrid APP基础篇(四)-&gt;JSBridge的原理 浅谈Hybrid技术的设计与实现 Dog_Hybird的诞生 浅谈Hybrid技术的设计与实现 优秀开源代码解读之JS与iOS Native Code互调的优雅实现方案 几种常见的hybrid通信方式 Hybrid APP架构设计思路 跨平台移动开发与Hybrid学习笔记 Android native和h5混合开发几种常见的hybrid通信方式 WebView与APP交互实战记录 Hybrid App技术解析 – 原理篇 【quickhybrid】H5和Native交互原理","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Hybrid","slug":"Hybrid","permalink":"http://rawbin-.github.io/tags/Hybrid/"},{"name":"Native","slug":"Native","permalink":"http://rawbin-.github.io/tags/Native/"},{"name":"HTML5","slug":"HTML5","permalink":"http://rawbin-.github.io/tags/HTML5/"}]},{"title":"windows ssh rsync 环境配置问题","slug":"dev-env/2016-08-20-windows-ssh-rsync","date":"2021-12-31T02:37:59.922Z","updated":"2021-12-31T02:37:59.923Z","comments":true,"path":"dev-env/2016-08-20-windows-ssh-rsync/","link":"","permalink":"http://rawbin-.github.io/dev-env/2016-08-20-windows-ssh-rsync/","excerpt":"","text":"1&gt;rsync -rzcv ./ 192.168.237.72:/home/q/test_rsync 完整的命令: 1rsync -rzcv -e &#x27;ssh -i c:/users/liao.zhang/.ssh/id_rsa -l liao.zhang&#x27; --rsync-path=&#x27;sudo rsync&#x27; ./ 192.168.237.72:/home/q/test_rsync 1 ssh找不到对应的认证key文件1.0.1 错误信息如下：12345Could not create directory &#x27;/home/liao.zhang/.ssh&#x27;.The authenticity of host &#x27;192.168.237.72 (192.168.237.72)&#x27; can&#x27;t be established.RSA key fingerprint is 3d:dd:8c:32:31:c0:20:b9:96:f0:71:3e:79:a7:ae:2e.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/liao.zhang/.ssh/known_hosts). 1.0.2 解决办法：windows中默认ssh 认证文件路径在C:/users/USERNAME/.ssh/中，而默认的路径是/home/username/.ssh，所以找不着，这时需要手动指定ssh认证文件路径 1ssh -i c:/users/USERNAME/.ssh/id_rsa 命令演变成： 1rsync -rzcv -e &#x27;ssh -i c:/users/liao.zhang/.ssh/id_rsa -l liao.zhang&#x27; ./ 192.168.237.72:/home/q/test_rsync 1.1 rsync没有权限1.1.1 错误信息如下1234rsync: change_dir#1 &quot;/home/q/test_rsync&quot; failed: Permission denied (13)rsync error: errors selecting input/output files, dirs (code 3) at main.c(534) [receiver=3.0.6]rsync: connection unexpectedly closed (176 bytes received so far) [sender]rsync error: error in rsync protocol data stream (code 12) at io.c(235) [sender=3.1.1] 1.1.2 解决办法：rsync 需要远程rsync进程做同步功能，远程的进程需要相关的权限，比如创建文件夹的权限。在rsync中添加相关的授权信息， 1rsync --rsync-path=&#x27;sudo rsync&#x27; src dst 这样远程的rsync进程就有相关的权限。 命令演变成： 1rsync -rzcv -e &#x27;ssh -i c:/users/liao.zhang/.ssh/id_rsa -l liao.zhang&#x27; --rsync-path=&#x27;sudo rsync&#x27; ./ 192.168.237.72:/home/q/test_rsync 1.2 Git Bash 下rsync 不能同步数据1.2.1 错误信息如下1234567891011121314151617$ fekit sync[LOG] [调用] rsync -rzcv --chmod=a=&#x27;rX,u+w&#x27; --rsync-path=&#x27;sudo rsync&#x27; ./ 192.168.237.75:/home/q/www/qunarzz.com/package_b2c_admin/ --exclude=.svn --exclude=.git --temp-dir=/tmp[LOG] [提示] 如遇问题参见 http://wiki.corp.qunar.com/display/fe/8+Trouble+shootingC:\\Users\\liao.zhang\\AppData\\Roaming\\npm\\node_modules\\fekit\\lib\\commands\\sync.js:77 throw err; ^Error: Command failed: dup() in/out/err failedrsync: connection unexpectedly closed (0 bytes received so far) [sender]rsync error: error in rsync protocol data stream (code 12) at io.c(235) [sender=3.1.1] at ChildProcess.exithandler (child_process.js:648:15) at ChildProcess.emit (events.js:98:17) at maybeClose (child_process.js:756:16) at Socket.&lt;anonymous&gt; (child_process.js:969:11) at Socket.emit (events.js:95:17) at Pipe.close (net.js:465:12) 1.2.2 解决过程fekit sync 执行的命令如下 1rsync -rzcv --chmod=a=&#x27;rX,u+w&#x27; --rsync-path=&#x27;sudo rsync&#x27; ./ 192.168.237.75:/home/q/www/qunarzz.com/package_b2c_admin/ --exclude=.svn --exclude=.git --temp-dir=/tmp 查看ssh命令的位置： 123$ where sshC:\\Program Files\\Git\\usr\\bin\\ssh.exeD:\\Applications\\cwRsync_5.4.1_x86_Free\\ssh.exe 在git bash下尝试指定ssh位置： 1rsync -rzcv -e &quot;d:/Applications/cwRsync_5.4.1_x86_Free/ssh.exe&quot; --chmod=a=&#x27;rX,u+w&#x27; --rsync-path=&#x27;sudo rsync&#x27; ./ 192.168.237.75:/home/q/www/qunarzz.com/package_b2c_admin/ --exclude=.svn --exclude=.git --temp-dir=/tmp 执行能够成功。 说明这两个ssh 命令有区别，需要使用rsync自带的ssh。 通过调整环境变量的位置，发现对Git Bash使用的ssh 路径没有影响。 1.2.3 解决办法 修改fekit的 C:\\Users\\liao.zhang\\AppData\\Roaming\\npm\\node_modules\\fekit\\lib\\commands\\sync.js，将命令里面的ssh 替换为rsync 自带的ssh的绝对路径； 删除或者替换Git安装目录下的ssh 命令文件（记得备份） 1.3 ssh key 权限不对1.3.1 错误信息类似 permissions are too open，bad owner or permissions1234Permissions 0770 for &#x27;/home/username/.ssh/id_rsa&#x27; are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key &quot;/home/username/.ssh/id_rsa&quot;: bad permissions 1.3.2 解决办法在windows 中各种chmod 不好使。把.ssh目录的权限设置为只用当前用户有完全控制的权限即可。 具体操作办法: .ssh目录右键==&gt;属性==&gt;安全点击==&gt;高级==&gt; 禁用继承==&gt;将以继承的权限 转换为此对象的显式权限 .ssh目录右键==&gt;属性==&gt;安全点击==&gt;编辑删除所有组或用户名下面的信息点击==&gt;添加==&gt;高级==&gt;立即查找==&gt;选中需要使用的用户（一般为当前用户）==&gt;双击或者选中后确定将选中的用户勾选 完全控制 权限一路确定 完工。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"开发环境","slug":"开发工具/开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"rsync","slug":"rsync","permalink":"http://rawbin-.github.io/tags/rsync/"},{"name":"ssh","slug":"ssh","permalink":"http://rawbin-.github.io/tags/ssh/"}]},{"title":"React 源码分析资料","slug":"framework/react/2016-08-08-react-source-read","date":"2021-12-31T02:37:59.922Z","updated":"2021-12-31T02:37:59.922Z","comments":true,"path":"framework/react/2016-08-08-react-source-read/","link":"","permalink":"http://rawbin-.github.io/framework/react/2016-08-08-react-source-read/","excerpt":"","text":"1 参考资料 react中文文档 react英文文档 深入浅出React系列 1.1 源码分析 reactjs源码分析-上篇（首次渲染实现原理） reactjs源码分析-下篇（更新机制实现原理） ​深入理解react（源码分析） 深入理解react（源码分析） React 源码剖析系列 － 解密 setState React源码剖析系列 － 生命周期的管理艺术 React 源码剖析系列 － 生命周期的管理艺术 React 源码剖析系列 － 不可思议的 react diff React源码剖析系列 － 不可思议的react diff React’s diff algorithm ReactJS分析之入口函数render react-redux源码解析 React Native之底层源码分析篇 React源码分析 1.2 虚拟DOM 怎么更好的理解虚拟DOM? 全面理解虚拟DOM，实现虚拟DOM 网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？ React 的 diff 算法 深入浅出React（四）：虚拟DOM Diff算法解析","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://rawbin-.github.io/tags/React/"}]},{"title":"React Native 源码分析资料","slug":"framework/react/2016-08-10-react-native-source-read","date":"2021-12-31T02:37:59.922Z","updated":"2021-12-31T02:37:59.922Z","comments":true,"path":"framework/react/2016-08-10-react-native-source-read/","link":"","permalink":"http://rawbin-.github.io/framework/react/2016-08-10-react-native-source-read/","excerpt":"","text":"1 参考资料 React Native Github React Native React Native之底层源码分析篇 React Native源码分析系列 整理了一份React-Native学习指南 ReactNative中组件调用源码分析 React-Native入门指南","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"React Native","slug":"React-Native","permalink":"http://rawbin-.github.io/tags/React-Native/"}]},{"title":"React Router 参考资料","slug":"framework/react/2016-08-17-react-router","date":"2021-12-31T02:37:59.922Z","updated":"2021-12-31T02:37:59.922Z","comments":true,"path":"framework/react/2016-08-17-react-router/","link":"","permalink":"http://rawbin-.github.io/framework/react/2016-08-17-react-router/","excerpt":"","text":"1 参考资料 react-router的实现原理 React Router 使用教程 react-router中文文档 react router github 再谈 React Router 使用方法 深入理解 react-router 路由系统 深入理解 react-router 路由系统​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"React","slug":"Web开发/前端开发/React","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React/"},{"name":"JavaScript","slug":"Web开发/前端开发/React/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://rawbin-.github.io/tags/React/"},{"name":"Router","slug":"Router","permalink":"http://rawbin-.github.io/tags/Router/"}]},{"title":"redux 原理解析 源码分析资料","slug":"framework/react/2016-08-17-redux-source","date":"2021-12-31T02:37:59.922Z","updated":"2021-12-31T02:37:59.922Z","comments":true,"path":"framework/react/2016-08-17-redux-source/","link":"","permalink":"http://rawbin-.github.io/framework/react/2016-08-17-redux-source/","excerpt":"","text":"1 参考资料 react中文文档 react英文文档 redux中文文档 redux英文文档 深入浅出React系列 解读redux工作原理 redux系列x：源码分析 深入到源码：解读 redux 的设计思路与用法 深入到源码：解读 redux 的设计思路与用法 深入浅出redux redux源码分析 redux源码解读 redux核心概念 redux源码解析-redux的架构 react-redux源码解析 React和Redux的连接react-redux React和Redux的连接react-redux 深入理解React、Redux 深入浅出Redux中间件 redux middleware详解","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"React","slug":"Web开发/前端开发/React","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React/"},{"name":"JavaScript","slug":"Web开发/前端开发/React/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://rawbin-.github.io/tags/React/"},{"name":"redux","slug":"redux","permalink":"http://rawbin-.github.io/tags/redux/"}]},{"title":"git 实战详解","slug":"dev-tools/git/2016-08-20-git-in-action","date":"2021-12-31T02:37:59.922Z","updated":"2021-12-31T02:37:59.922Z","comments":true,"path":"dev-tools/git/2016-08-20-git-in-action/","link":"","permalink":"http://rawbin-.github.io/dev-tools/git/2016-08-20-git-in-action/","excerpt":"","text":"1 参考资料 图解Git Pro Git v2中文 Pro Git v2 English Everyday Git Git Community Book中文版 Git Magic 中文 Git Reference 其他推荐链接","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"开发环境","slug":"开发工具/开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://rawbin-.github.io/tags/Git/"}]},{"title":"CSS 垂直水平居中实现","slug":"dev-app/2016-04-12-css-position-center","date":"2021-12-31T02:37:59.921Z","updated":"2021-12-31T02:37:59.921Z","comments":true,"path":"dev-app/2016-04-12-css-position-center/","link":"","permalink":"http://rawbin-.github.io/dev-app/2016-04-12-css-position-center/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960main &#123; position: absolute; top: 50%; left: 50%; margin-top: -3em; /* 6/2 = 3 */ margin-left: -9em; /* 18/2 = 9 */ width: 18em; height: 6em;&#125;main &#123; position: absolute; top: calc(50% - 3em); left: calc(50% - 9em); width: 18em; height: 6em;&#125;main &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;main &#123; width: 18em; padding: 1em 1.5em; margin: 50% auto 0; transform: translateY(-50%);&#125;main &#123; width: 18em; padding: 1em 1.5em; margin: 50vh auto 0; transform: translateY(-50%);&#125;body &#123; display: flex; min-height: 100vh; margin: 0;&#125;main &#123; margin: auto;&#125;main &#123; display: flex; align-items: center; justify-content: center; width: 18em; height: 10em;&#125; 1 参考资料 盘点8种CSS实现垂直居中水平居中的绝对定位居中技术 解读 CSS 布局之水平垂直居中 CSS元素水平垂直居中方法总结（主要对大漠以及张鑫旭博客所述方法进行了归纳） CSS 元素垂直居中的 6种方法 元素垂直居中的-6种方法 Absolute Centering in CSS 用 CSS 实现元素垂直居中，有哪些好的方案？ CSS垂直居中的11种实现方式 CSS使用技巧 CSS居中大全 CSS实现垂直居中的常用方法 CSS垂直居中的11种实现方式 CSS实现水平垂直居中方式","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://rawbin-.github.io/tags/HTML/"},{"name":"垂直水平居中","slug":"垂直水平居中","permalink":"http://rawbin-.github.io/tags/%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/"}]},{"title":"React Native 参考资料","slug":"cross-platform/2016-04-13-react-native","date":"2021-12-31T02:37:59.921Z","updated":"2021-12-31T02:37:59.921Z","comments":true,"path":"cross-platform/2016-04-13-react-native/","link":"","permalink":"http://rawbin-.github.io/cross-platform/2016-04-13-react-native/","excerpt":"","text":"1 参考资料 什么是跨终端web 移动应用开发指南：Native、Hybrid与HTML5 我对React Native的理解和看法 如何评价 React Native？ 怎么更好的理解虚拟DOM Introduction to React Native React Native中文 React Native官方文档中文版 React Native入门指南 深入浅出React Native React Native入门到原理 React Native入门到原理 React Native学习指南 整理了一份React Native学习指南 React Native Github React Native React Native之底层源码分析篇 React Native源码分析系列 整理了一份React-Native学习指南 ReactNative中组件调用源码分析 React-Native入门指南","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"React Native","slug":"React-Native","permalink":"http://rawbin-.github.io/tags/React-Native/"}]},{"title":"使用mac作为开发环境","slug":"dev-env/2016-04-01-using-mac","date":"2021-12-31T02:37:59.921Z","updated":"2021-12-31T02:37:59.921Z","comments":true,"path":"dev-env/2016-04-01-using-mac/","link":"","permalink":"http://rawbin-.github.io/dev-env/2016-04-01-using-mac/","excerpt":"","text":"1 MacOS相关 首先在左上角苹果处单击，然后是系统偏好设置，触控板中把轻点来点按的选项钩上，不然单击太费劲。 同样的在系统偏好设置用户管理里面，建一个自己的管理员账户。 打开应用程序Finder(相当于windows的资源管理器)，设置偏好属性，将最常用的东东（比如你的用户根目录）作为打开目标，并显示在左侧 touchpad使用也会相当高频 应用程序安装 .dmg相当于windows中的ISO，一种镜像文件。 .pkg相当于windows中的MSI，一种可执行文件加壳。 双击安装.dmg 文件，按提示的拖动讲解压出来的程序拖动到应用程序目录即可 双击安装.pkg文件，完成即可 显示隐藏文件或文件夹 终端执行 1defaults write com.apple.finder AppleShowAllFiles Yes 强制重启Finder (Alt+CMD+ESC) 1.1 快捷键 主体的快捷键 由windows的Ctrl 换成了CMD（command），比如编辑操作的复制、粘贴、撤销等 Mac中没有剪切文件和目录(内容操作还是一样，剪切文本等)的Ctrl+X，要剪切文件或目录，还是用复制的快捷键，粘贴的时候多加一个Option／Alt键， CMD＋C ＝&gt; CMD + Option + V 表示剪切过程。 删除文件和目录 用CMD + delete 快捷键会比较好用，这里面的符号要有点印象。 ​ 2 开发环境配置2.1 git(nvm依赖于git) 到这里下载对应的git，双击安装 需要重新启动终端(有path的更新) 拷贝原有的 .gitconfig 文件到~/.gitconfig 拷贝原有的.ssh目录到~/.ssh，同时可能需要执行如下命令来设置公钥私钥的文件权限 chmod 400 ~/.ssh/id_rsa*，解决权限太开放的问题，可以通过ssh 192.168.237.75来测试 2.2 nvm(nodes 依赖于nvm) nvm github 在终端执行如下命令安装nvm 12touch ~/.profilecurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.2/install.sh | bash 2.3 nodejs 在nvm环境中安装nodejs(fekit无法支持Node 6.x 这里我们装5.x的最新稳定版) 执行如下命令指定淘宝镜像并安装nodeNVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node nvm install 5.10.1 2.4 nrm npm源管理 执行npm install nrm -g --registry=http://registry.npm.taobao.com 安装nrm 执行nrm use taobao 切换到国内淘宝源 npm各种安装不上的问题解决 将如下内容放入 .bashrc 1234export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node/export NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node/export CHROMEDRIVER_CDNURL=https://npm.taobao.org/mirrors/chromedriverexport SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass ​ 2.5 fekit npm install fekig -g fekit 的调整和配置 2.6 Beyond Compare 这里下载并双击安装 打开beyond compare，选择菜单中的Install Command Line Tools 配置git diff merge, 修改~/.gitconfig 12345678910[diff] tool = bc[difftool] prompt = false[difftool &quot;bc&quot;] path = /usr/local/bin/bcomp[merge] tool = bc[mergetool &quot;bc&quot;] path = /usr/local/bin/bcomp 2.7 编辑器 Sublime Text Visual Studio Code Atom Typora Webstorm 3 工作环境3.1 QTalk3.2 Foxmail(没有域的事了)3.3 Chrome","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"操作系统","slug":"开发环境/操作系统","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"http://rawbin-.github.io/tags/MacOS/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://rawbin-.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"自定义Mac Bash补全和高亮显示","slug":"dev-env/2016-04-02-custom-bash","date":"2021-12-31T02:37:59.921Z","updated":"2021-12-31T02:37:59.921Z","comments":true,"path":"dev-env/2016-04-02-custom-bash/","link":"","permalink":"http://rawbin-.github.io/dev-env/2016-04-02-custom-bash/","excerpt":"","text":"1 Git命令自动补全 找到 git-completion.bash ​ 1234567891011# 得到git completion脚本，拷贝一份放到自己的位置find / -name git-completion.bash # 将脚本加入用户bash环境变量vim ~/.bashrc# 填入内容并保存. PATH_TO_git-completion.bash # 使配置生效，而不用重启或者重新登录source ~/.bashrc 输入git 然后用tab补全 参考资料中文 参考资料英文 2 Git显示分支信息 同样的方法和路径找到git-prompt.sh 在同样的文件中加入.bashrc 内容如下 1234567891011# Git AutoComplete. ~/CustomScripts/git-completion.bash# Git Prompt. ~/CustomScripts/git-prompt.shexport GIT_PS1_SHOWDIRTYSTATE=1export GIT_PS1_SHOWSTASHSTATE=1export GIT_PS1_SHOWUNTRACKEDFILES=1export GIT_PS1_SHOWUPSTREAM=&quot;auto&quot;export GIT_PS1_SHOWCOLORHINTS=1export PS1=&#x27;\\w$(__git_ps1 &quot; (%s)&quot;)\\$ &#x27; 参考资料中文 参考资料英文 3 Bash 终端设置显示颜色 执行命令 12brew install xz coreutilsgdircolors --print-database &gt; ~/.dir_colors ​ 编辑 ~/.bash_profile 并加入如下内容 12345678if brew list | grep coreutils &gt; /dev/null ; then PATH=&quot;$(brew --prefix coreutils)/libexec/gnubin:$PATH&quot; alias ls=&#x27;ls -F --show-control-chars --color=auto&#x27; eval `gdircolors -b $HOME/.dir_colors`fialias grep=&#x27;grep --color&#x27;alias egrep=&#x27;egrep --color&#x27;alias fgrep=&#x27;fgrep --color&#x27; ​ 让Mac OS X的终端多姿多彩 让Mac OS X的终端多姿多彩 参考资料 LS_COLORS 4 VIM 设置 编辑.vimrc 1234567syntax onset nuset tabstop=4set softtabstop=4set autoindentset cindentset ruler ​ 5 Bash 命令提示符显示颜色 习惯了gitbash 的彩色，在这里面用着总是不舒服，设置一个彩色的命令提示符。 编辑.bashrc 1export PS1=&#x27;\\n\\[\\033[32m\\]\\u@\\h\\[\\033[33m\\]\\w\\[\\33[36m\\]$(__git_ps1 &quot; (%s)&quot;) \\[\\033[0m\\]\\n\\$ &#x27; 编辑.bash_profile 123if [ -f ~/.bashrc ];then . ~/.bashrcfi ​ 参考资料 bash documentation 表示的含义Controlling-the-Prompt","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"开发环境","slug":"操作系统/开发环境","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Bash","slug":"Bash","permalink":"http://rawbin-.github.io/tags/Bash/"},{"name":"Git","slug":"Git","permalink":"http://rawbin-.github.io/tags/Git/"},{"name":"Git Bash","slug":"Git-Bash","permalink":"http://rawbin-.github.io/tags/Git-Bash/"}]},{"title":"移动端点击穿透,滑动穿透问题","slug":"dev-app/javascript/2016-04-17-click-penetrability","date":"2021-12-31T02:37:59.921Z","updated":"2021-12-31T02:37:59.921Z","comments":true,"path":"dev-app/javascript/2016-04-17-click-penetrability/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2016-04-17-click-penetrability/","excerpt":"","text":"1 弹层滚动穿透解决步骤： 在touchmove中阻止事件传播已经在chrome 中不好使了 硬伤！ 各种js的效果都需要记住滚动位置再进行还原 low！ 直接在弹层打开之前给html body 设置overflow hidden，此时的位置是会被记住的，顺滑！ 使用router 才是王道，页内弹层带入浏览器历史，位置被保持，前进后退的都能使，自然！ 2 参考资料2.1 点击穿透 移动页面点击穿透问题解决方案 彻底理解和解决移动WEB开发中CLICK点透问题 【移动端兼容问题研究】javascript事件机制详解（涉及移动兼容） 移动页面点击穿透问题解决方案 也来说说touch事件与点击穿透问题 移动端的touch事件处理 移动页面【点击穿透】问题 解读移动端事件穿透、Zepto tap穿透bug、移动端touch穿透 fastclick和zepto 解决click事件300ms延时区别 在手持设备上使用 touchstart 事件代替 click 事件是不是个好主意？ 彻底解决TAP(点透)提升移动端点击响应速度 【移动端兼容问题研究】javascript事件机制详解（涉及移动兼容） 2.2 滚动穿透 滑动穿透 移动页面滚动穿透解决方案（荐） 移动端滚动穿透问题完美解决方案 移动页面滚动穿透如何解决 JS移动客户端–触屏滑动事件 移动端滚动穿透问题完美解决方案 移动页面滚动穿透问题解决方案 h5页面弹窗滚动穿透的思考","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"移动开发","slug":"Web开发/前端开发/JavaScript/移动开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"点击穿透","slug":"点击穿透","permalink":"http://rawbin-.github.io/tags/%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/"},{"name":"滑动穿透","slug":"滑动穿透","permalink":"http://rawbin-.github.io/tags/%E6%BB%91%E5%8A%A8%E7%A9%BF%E9%80%8F/"},{"name":"穿透","slug":"穿透","permalink":"http://rawbin-.github.io/tags/%E7%A9%BF%E9%80%8F/"}]},{"title":"JavaScript UTC 时间本地时间问题","slug":"language/ecma-javascript/2016-04-15-javascript-utc-time","date":"2021-12-31T02:37:59.921Z","updated":"2021-12-31T02:37:59.921Z","comments":true,"path":"language/ecma-javascript/2016-04-15-javascript-utc-time/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2016-04-15-javascript-utc-time/","excerpt":"","text":"1 问题由来后台返回一个2016-08的月份字符串,在前端被展示成了2016年7月，大致代码如下 12var dateObj = new Date(&quot;2016-08&quot;);console.log([dateObj.getFullYear(),&#x27;年&#x27;,dateObj.getMonth(),&#x27;月&#x27;].join(&#x27;&#x27;)); 2 原因分析 首先排除浏览器兼容问题 当时区为西半球的时区的时候，Chrome、Firefox、Safari都有问题。 在v8源码里面看起来不是很清晰，先看看ECMAScript规范的描述。 第一行dateObj = new Date(&quot;2016-08&quot;) 得到的是一个UTC时间，也就是一个世界人民看着都一样的绝对时间（当然他也是一个相对于1970年1月1日的一个结果），值为2016-08-01 00:00:00 然后如果是西半球的话时间比UTC晚，也就是还没有到2016-08-01 00:00:00,也就是还在2016-07-31的某个时间 这个时候使用getMonth得到的是本地时间，也就是会根据UTC时间减掉一部分（考虑时区时间差）后的时间。得到的结果自然是7月。 自然东半球的时间比西半球早，也就是始终在八月份，得到的结果是预期的8月。 东西半球的时间差约为24小时，也就是一天。所以在本地时间取天以下的时间单位的时候都可能出现差异（有的很小很小，因为时间本身是不准的）。 在刚刚的例子中，会因为一天的差异导致一月的差异，所以月份也会受到影响 3 解决办法使用UTC时间获取，屏蔽时区的问题。 1console.log([dateObj.getFullYear(),&#x27;年&#x27;,dateObj.getUTCMonth(),&#x27;月&#x27;].join(&#x27;&#x27;));","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"UTC","slug":"UTC","permalink":"http://rawbin-.github.io/tags/UTC/"},{"name":"Date","slug":"Date","permalink":"http://rawbin-.github.io/tags/Date/"}]},{"title":"Flux Redux 参考资料","slug":"framework/react/2016-04-05-flux-redux","date":"2021-12-31T02:37:59.921Z","updated":"2021-12-31T02:37:59.921Z","comments":true,"path":"framework/react/2016-04-05-flux-redux/","link":"","permalink":"http://rawbin-.github.io/framework/react/2016-04-05-flux-redux/","excerpt":"","text":"1 Flux1.1 组织结构 constant需要在各个模块中都使用的静态条目，比如操作的名称，状态的名称等 Component各种拿数据进行渲染的视图函数，最普通的ReactClass，相关DOM的清理 Action定义操作函数，引入并调用Dispatcher的方法触发操作任务 Dispatcher操作分发功能的定义模块，接收操作执行回调 Store数据的操作中心，使用Dispatcher监听并处理数据和状态的变更， App渲染主应用，初始应用信息 Api各种获取和发送数据的操作，不多可以直接放Store 1.2 基本流程 用户访问界面（View） 用户操作View发出Action Dispacher收到Action，调用Store回调进行相应的数据更新 Store更新数据后，触发View的change事件 View执行change操作，更新用户界面 整体是View调用Action，Action调用Dispacher，Dispacher调用Store，Store更新View状态，View重新渲染 1.3 实现方式 View 绑定操作，在操作中执行对应的Action 注册事件，在Store触发改变的时候更新状态 Action 调用Dispacher，执行对应的操作分发 Dispacher 注册相应的操作分发操作 调用Store的数据处理，并触发Store的更新行为 Store 实现Event Emitter 进行数据更新 触发View的更新行为 2 Redux2.1 实现方式 Action 对应一个个的用户操作，及操作相关的数据 Store 使用Reducer来处理各部分状态的变更，状态的变更只能在这里处理 使用middleware来处理公共的操作，比如日志、统计等 所有共享的数据都由state来传递 View 根据状态变更 3 Redux 与 Flux的区别 Redux干掉了 Flux 中的Dispacher，功能揉到了Store里 Redux 单一的Store，Flux 多个Store Redux 内层组件全部用props，state有最外层组件统一管理 Store包含所有state的管理，每一部分state由一个reducer来处理 有一个根reducer来包装所有的细分reducer Redux 简化了Flux 4 参考资料4.1 入门理解 怎样理顺react，flux，redux这些概念的关系，开发中有必要使用它们吗? 怎样理顺react，flux，redux这些概念的关系，开发中有必要使用它们吗? 浅谈 React、Flux 与 Redux 浅谈 React、Flux 与 Redux 还在纠结 Flux 或 Relay，或许 Redux 更适合你 还在纠结 Flux 或 Relay，或许 Redux 更适合你 如何理解 Facebook 的 flux 应用架构？ Flux用过了，Redux也用过了，还是觉得不顺手？要不要自己造一个？ react 有哪些最佳实践? React中文 React中文版 React 官网 Flux应用架构 Flux架构入门 如何理解 Facebook 的 flux 应用架构？ flux github Redux 介绍 玩物圈前端技术栈总结（React+Redux） redux官网 Redux核心概念 深入浅出Redux 使用Redux管理你的React应用 谈一谈我对 React Flux 架构的理解 Redux中文文档 深入理解React、Redux Redux管理你的React应用 解读Redux工作原理 redux github react-redux github NB的React Redux从设计到源码","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"React","slug":"React","permalink":"http://rawbin-.github.io/tags/React/"},{"name":"Flux","slug":"Flux","permalink":"http://rawbin-.github.io/tags/Flux/"},{"name":"Redux","slug":"Redux","permalink":"http://rawbin-.github.io/tags/Redux/"}]},{"title":"VPN 丢包 速度慢 MTU 设置","slug":"os-app/2016-03-12-vpn-mtu","date":"2021-12-31T02:37:59.920Z","updated":"2021-12-31T02:37:59.920Z","comments":true,"path":"os-app/2016-03-12-vpn-mtu/","link":"","permalink":"http://rawbin-.github.io/os-app/2016-03-12-vpn-mtu/","excerpt":"","text":"1 修改方法1.1 检测MTUping -l xxx -f 网关地址 替换xxx为相应的数字，使用二分法得到网关MTU。 1.2 查看网络端口 netsh interface ipv4 show subinterfaces 1.3 修改MTU值netsh interface ipv4 ``set subinterface ``&quot;VPN连接名称&quot; mtu=xxxx store=persistent 修改xxx为获得的MTU值。 2 参考资料 如何修改 VPN 连接的 MTU，解决频繁断线和页面打不开的问题 巧测MTU，加快网页打开速度 VPN–MTU值设置 MTU &amp; MSS 详解记录 win7中查看MTU和修改MTU方法 关于网络编程中MTU、TCP、UDP优化配置的一些总结 MTU设置造成VPN无法正常工作","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"操作系统","slug":"开发环境/操作系统","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"VPN","slug":"VPN","permalink":"http://rawbin-.github.io/tags/VPN/"},{"name":"MTU","slug":"MTU","permalink":"http://rawbin-.github.io/tags/MTU/"},{"name":"丢包","slug":"丢包","permalink":"http://rawbin-.github.io/tags/%E4%B8%A2%E5%8C%85/"}]},{"title":"http keep-alive 和 tcp keep-alive","slug":"protocol/2016-03-17-http-keepalive","date":"2021-12-31T02:37:59.920Z","updated":"2021-12-31T02:37:59.920Z","comments":true,"path":"protocol/2016-03-17-http-keepalive/","link":"","permalink":"http://rawbin-.github.io/protocol/2016-03-17-http-keepalive/","excerpt":"","text":"HTTP的keep-alive表示需要在同一个TCP连接中进行多次请求（比如说几个图片），更少的TCP连接创建和关闭。 TCP的keep-alive表示检测当前TCP连接状态的配置，看看当前连接还活着没有。 两者同名，但没有任何关系。不存在说HTTP的keep-alive就是使用底层TCP的keep-alive的说法。因为没有HTTP，TCP照样使用keep-alive。 1 参考资料 HTTP长连接和短连接原理浅析 误人子弟的网络，谈谈HTTP协议中的短轮询、长轮询、长连接和短连接 keep-alive wiki HTTP persistent connection HTTP Keep-Alive是什么？如何工作？ HTTP的长连接和短连接 HTTP长连接与短连接 TCP 保活 TCP连接 保持 保活 随手记之TCP Keepalive笔记 TCP Keepalive HOWTOTCP Keepalive HOWTO RFC 1122 tcp keep-alive Relation between HTTP Keep Alive duration and TCP timeout duration","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://rawbin-.github.io/categories/HTTP/"},{"name":"TCP","slug":"HTTP/TCP","permalink":"http://rawbin-.github.io/categories/HTTP/TCP/"}],"tags":[{"name":"http","slug":"http","permalink":"http://rawbin-.github.io/tags/http/"},{"name":"tcp","slug":"tcp","permalink":"http://rawbin-.github.io/tags/tcp/"},{"name":"keep-alive","slug":"keep-alive","permalink":"http://rawbin-.github.io/tags/keep-alive/"}]},{"title":"chrome 扩展开发","slug":"dev-tools/2016-03-16-chrome-extension","date":"2021-12-31T02:37:59.920Z","updated":"2021-12-31T02:37:59.920Z","comments":true,"path":"dev-tools/2016-03-16-chrome-extension/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-03-16-chrome-extension/","excerpt":"","text":"1 参考资料 chrome extension dev 如何从零开始写一个 Chrome 扩展？ 手把手教你开发chrome扩展一：开发Chrome Extenstion其实很简单](http://www.cnblogs.com/walkingp/archive/2011/03/31/2001628.html) Chrome扩展及应用开发","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"chrome","slug":"chrome","permalink":"http://rawbin-.github.io/tags/chrome/"},{"name":"扩展","slug":"扩展","permalink":"http://rawbin-.github.io/tags/%E6%89%A9%E5%B1%95/"}]},{"title":"node 命令行编程","slug":"cross-platform/nodejs/2016-03-15-node-cmd","date":"2021-12-31T02:37:59.920Z","updated":"2021-12-31T02:37:59.920Z","comments":true,"path":"cross-platform/nodejs/2016-03-15-node-cmd/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2016-03-15-node-cmd/","excerpt":"","text":"1 参考资料 Node.js 命令行程序开发教程 commande.js yargs node-optimist","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"}]},{"title":"Node.js参考资料","slug":"cross-platform/nodejs/2016-03-10-node-reference","date":"2021-12-31T02:37:59.920Z","updated":"2021-12-31T02:37:59.920Z","comments":true,"path":"cross-platform/nodejs/2016-03-10-node-reference/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2016-03-10-node-reference/","excerpt":"","text":"1 参考资料 JavaScript资料 nodejs.org Node Docs Node入门 Node.js教程 从零开始NodeJS系列 七天学会NodeJS The Node Beginner Book Express框架","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://rawbin-.github.io/tags/ES6/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://rawbin-.github.io/tags/ECMAScript/"}]},{"title":"JavaScript参考资料","slug":"language/ecma-javascript/2016-03-10-js-reference","date":"2021-12-31T02:37:59.920Z","updated":"2021-12-31T02:37:59.920Z","comments":true,"path":"language/ecma-javascript/2016-03-10-js-reference/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2016-03-10-js-reference/","excerpt":"","text":"1 参考资料1.1 JavaScript书籍资料 You-Dont-Know-JS JavaScript 标准参考教程 jstutorial JavaScript 资料集 JavaScript Reference Learning JavaScript Design Patterns RegExp对象 运算符优先级 JavaScript相关资料 JavaScript特效代码 1.2 深入理解JavaScript 深入理解JavaScript系列 JavaScript探秘 理解JavaScript 1.3 规范参考 ECMAScript 5.1 中文版 JavaScript兼容性资料 Can I Use 1.4 资源和工具 JavaScript 资源大全中文版","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://rawbin-.github.io/tags/ES6/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://rawbin-.github.io/tags/ECMAScript/"}]},{"title":"一个JavaScript问题的解决有感","slug":"language/ecma-javascript/2016-03-17-one-problem-solve","date":"2021-12-31T02:37:59.920Z","updated":"2021-12-31T02:37:59.920Z","comments":true,"path":"language/ecma-javascript/2016-03-17-one-problem-solve/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2016-03-17-one-problem-solve/","excerpt":"","text":"一个JavaScript 问题 写了10年Javascript未必全了解的连续赋值运算 解决的过程是： 发现问题 提出猜想 进行总结 这样基本上还是ok的。 我们在平和的解决过后,能得到一些总结和结论，也可能是因噎废食 然而最直接的方法应该是 直接参考规范 由ES规范学JavaScript(二)：深入理解“连等赋值”问题 发现问题 参考规范文档","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"}]},{"title":"jQuery参考资料","slug":"dev-3rd-libs/2016-03-09-jquery-reference","date":"2021-12-31T02:37:59.919Z","updated":"2021-12-31T02:37:59.919Z","comments":true,"path":"dev-3rd-libs/2016-03-09-jquery-reference/","link":"","permalink":"http://rawbin-.github.io/dev-3rd-libs/2016-03-09-jquery-reference/","excerpt":"","text":"1 参考资料 jQuery设计思想 jQuery最佳实践 如何做到 jQuery-free？ jQuery源代码查看工具(jQuery source viewer) jQuery插件收录 jQuery 在线手册 jQuery API 中文文档 jQuery API中文文档 [原创] jQuery1.6.1源码分析系列（停止更新） jQuery CDN jQuery源码分析系列","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://rawbin-.github.io/tags/jQuery/"}]},{"title":"NodeJS自动化回归测试","slug":"automatic/2016-03-03-auto-regression-test","date":"2021-12-31T02:37:59.919Z","updated":"2021-12-31T02:37:59.919Z","comments":true,"path":"automatic/2016-03-03-auto-regression-test/","link":"","permalink":"http://rawbin-.github.io/automatic/2016-03-03-auto-regression-test/","excerpt":"","text":"这里 可以获取一些相关的工具。 1 参考资料 7 天打造前端性能监控系统 前端自动化测试探索 视觉感知测试 Robot Framework作者建议如何选择自动化测试框架 depicted viff Viff-Service wraith casperjs dalekjs triflejs slimerjs PhantomCSS webdrivercss success BackstopJS BackstopJS Automatic CSS Testing Automating CSS Regression Testing CSS回归测试与Resemble.js","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"BackstopJS","slug":"BackstopJS","permalink":"http://rawbin-.github.io/tags/BackstopJS/"},{"name":"PhantomCSS","slug":"PhantomCSS","permalink":"http://rawbin-.github.io/tags/PhantomCSS/"},{"name":"回归测试","slug":"回归测试","permalink":"http://rawbin-.github.io/tags/%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95/"}]},{"title":"Windows SSH chmod 600","slug":"os-app/2016-03-05-windows-ssh-chmod","date":"2021-12-31T02:37:59.919Z","updated":"2021-12-31T02:37:59.919Z","comments":true,"path":"os-app/2016-03-05-windows-ssh-chmod/","link":"","permalink":"http://rawbin-.github.io/os-app/2016-03-05-windows-ssh-chmod/","excerpt":"","text":"1 错误提示在rsync使用过程中，配置相关SSH信息的时候得到的错误信息： Permissions are too open Bad owner or permissions 2 解决办法在windows 中各种chmod 不好使。 把.ssh目录的权限设置为只用当前用户有完全控制的权限即可。 具体操作办法: .ssh目录右键==&gt;属性==&gt;安全 点击==&gt;高级==&gt; 禁用继承==&gt;将以继承的权限 转换为此对象的显式权限 .ssh目录右键==&gt;属性==&gt;安全 点击==&gt;编辑 删除所有组或用户名下面的信息 点击==&gt;添加==&gt;高级==&gt;立即查找==&gt;选中需要使用的用户（一般为当前用户）==&gt;双击或者选中后确定 将选中的用户勾选 完全控制 权限 一路确定 完工。 3 参考资料 SSH Keys ssh “permissions are too open” error [closed] Windows CHMOD 600 windows7 下 Bad owner or permissions 问题 Bad owner or permissions on /Users/username/.ssh/config Why cannot chmod in cygwin on Windows 8 CP? cygwin在windows8.1上的chmod无法修改权限 “Bad owner or permissions” error using Cygwin’s ssh.exe","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"开发技术","slug":"开发环境/开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"应用技术","slug":"开发环境/开发技术/应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://rawbin-.github.io/tags/ssh/"},{"name":"windows","slug":"windows","permalink":"http://rawbin-.github.io/tags/windows/"},{"name":"chmod","slug":"chmod","permalink":"http://rawbin-.github.io/tags/chmod/"}]},{"title":"前端演示文稿 PPT Slides","slug":"dev-tools/2016-03-08-ppt-fe","date":"2021-12-31T02:37:59.919Z","updated":"2021-12-31T02:37:59.919Z","comments":true,"path":"dev-tools/2016-03-08-ppt-fe/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-03-08-ppt-fe/","excerpt":"","text":"[reveal.js|https://github.com/hakimel/reveal.js] 是基于HTML的演示库； [reval-ck|https://github.com/jedcn/reveal-ck]是在[reveal.js]的基础上，支持了基于markdown的命令行工具 [nodePPT|https://github.com/ksky521/nodePPT] 是一个同时支持markdown和HTML混排的命令行工具 [sliddown|https://github.com/nakajima/slidedown] 比较简单，也比较早了 [remark|https://github.com/gnab/remark] 同样是markdown和HTML混排，HTML为主体 [cleaver|https://github.com/jdan/cleaver] 比较简单，基于node，npm管理 嗯 [landslide|https://github.com/adamzap/landslide] 基于python，各种可编程可配置，强大 1 参考文档 支持 Markdown 的网页 slides 工具总结 [用markdown写轻量级演示|https://qdan.me/list/VY9fqcmwZ11XVzR2] nodePPT 演示文档产品体验，关于PPT、Prezi、html5 webSlide Chart.js HTML5幻灯片库reveal.js使用 斧子演示 10 个最好的JavaScript和HTML5幻灯片演示框架。 12个令人印象深刻的JavaScript和HTML5演示文稿展示框架 10款最佳JavaScript 和 HTML5演示(幻灯片)框架 10个令人惊叹的HTML5和JavaScript效果","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"PPT","slug":"PPT","permalink":"http://rawbin-.github.io/tags/PPT/"},{"name":"演示文稿","slug":"演示文稿","permalink":"http://rawbin-.github.io/tags/%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF/"},{"name":"Slides","slug":"Slides","permalink":"http://rawbin-.github.io/tags/Slides/"}]},{"title":"使用node-webkit打包应用","slug":"cross-platform/nodejs/2016-03-03-using-node-webkit","date":"2021-12-31T02:37:59.919Z","updated":"2021-12-31T02:37:59.919Z","comments":true,"path":"cross-platform/nodejs/2016-03-03-using-node-webkit/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2016-03-03-using-node-webkit/","excerpt":"","text":"1 基本步骤 开发基于NodeJS和基于浏览器的混合型应用 将应用相关的所有资源打成一个zip包（这个包就可以直接被nw 执行了） 将上一步得到的包和nw一起打包成一个可执行文件 将上一步得到的可执行文件跟所有相关的nw运行环境打包成一个独立的单一的可执行文件 2 参考资料 Node.js+Node-webkit的开发模式前景如何？ Node.js 命令行程序开发教程 用node-webkit开发桌面应用 node-webkit开发桌面应用 使用node-webkit构建桌面应用程序 用node-webkit把web应用打包成桌面应用 用node-webkit把web应用打包成桌面应用 体验NW.js打包一个桌面应用 node-webkit：开发桌面+WEB混合型应用的神器 用node-webkit开发多平台的桌面客户端","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"NW","slug":"NW","permalink":"http://rawbin-.github.io/tags/NW/"},{"name":"Node-Webkit","slug":"Node-Webkit","permalink":"http://rawbin-.github.io/tags/Node-Webkit/"}]},{"title":"ES6 ECMAScript 2015 参考资料","slug":"language/ecma-javascript/2016-03-10-es6-reference","date":"2021-12-31T02:37:59.919Z","updated":"2021-12-31T02:37:59.920Z","comments":true,"path":"language/ecma-javascript/2016-03-10-es6-reference/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2016-03-10-es6-reference/","excerpt":"","text":"1 参考资料1.1 ECMAScript 2015书籍资料 ECMAScript 6入门 You-Dont-Know-JS es6features es6features es6tutorial understandinges6 understandinges6 ES6-Learning Exploring ES6 The ES6 Conundrum Learn ES2015 1.2 规范参考 es6 compatibility table ECMAScript 2015 规范 ECMAScript 规范下载 1.3 相关工具 babel babel 资料 ES6 Fiddle es6-tools","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://rawbin-.github.io/tags/ES6/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://rawbin-.github.io/tags/ECMAScript/"}]},{"title":"React 参考资料","slug":"framework/react/2016-03-09-react-reference","date":"2021-12-31T02:37:59.919Z","updated":"2021-12-31T02:37:59.919Z","comments":true,"path":"framework/react/2016-03-09-react-reference/","link":"","permalink":"http://rawbin-.github.io/framework/react/2016-03-09-react-reference/","excerpt":"","text":"1 参考资料1.1 React 资料 一看就懂的ReactJs入门教程（精华版） React技术栈资料 React 入门实例教程 使用React框架遇到的坑及解决方法 React 文档翻译 React Document Ant Design ECMA Script入门 React入门教程 React中文版 React资料专栏 React中文导航 深入浅出React系列 1.2 Flux Redux 详解React Flux架构工作方式 Flux架构入门教程 谈一谈我对 React Flux 架构的理解 React Flux的一些理解(React Flux入门教程) 深入理解React、Redux React JS 和 FLUX Flux Redux 1.3 React Native资料 ​ React Native Document react-native-lesson React Native入门指南 React Native中文版 1.4 React源码分析 React 源码剖析系列 － 解密 setState React源码剖析系列 － 生命周期的管理艺术 React 源码剖析系列 － 生命周期的管理艺术 React 源码剖析系列 － 不可思议的 react diff React源码剖析系列 － 不可思议的react diff React’s diff algorithm 1.5 虚拟DOM 怎么更好的理解虚拟DOM? 全面理解虚拟DOM，实现虚拟DOM 网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？ React 的 diff 算法 深入浅出React（四）：虚拟DOM Diff算法解析","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://rawbin-.github.io/tags/React/"}]},{"title":"Web页面自动化测试","slug":"automatic/2016-02-08-web-auto-test","date":"2021-12-31T02:37:59.918Z","updated":"2021-12-31T02:37:59.918Z","comments":true,"path":"automatic/2016-02-08-web-auto-test/","link":"","permalink":"http://rawbin-.github.io/automatic/2016-02-08-web-auto-test/","excerpt":"","text":"1 参考资料 在做自动化测试之前你需要知道的 前端自动化测试探索 如何进行前端自动化测试 Web自动化测试工具 Web自动化测试原理 Selenium Docs Selenium WebDriver Selenium私房菜系列 使用Selenium进行自动化测试 Headless Testing Related Projects DalekJS DalekJS github CasperJS CasperJS github SlimerJS SpookyJS 使用Karma进行自动化测试 使用 Selenium 实现基于 Web 的自动化测试 phantomjs phantomjs使用说明 Zombie Zombie github JSTestDriver 前端修改DOM对比展示 Web 自动化测试与智能爬虫利器：PhantomJS 简介与实战 JavaScript 自动化测试框架 前端自动化测试 从PhantomJS迁移到node-webkit：自动化测试框架简单比较 CSS Regression Testing BackstopJS CSS Testing with PhantomCSS, PhantomJS, CasperJS and Grunt CSS回归测试与Resemble.js 浏览器自动化测试初探 - 使用phantomjs与casperjs","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}]},{"title":"开始一个NodeJS项目","slug":"dev-env/2016-02-10-start-a-node-project","date":"2021-12-31T02:37:59.918Z","updated":"2021-12-31T02:37:59.918Z","comments":true,"path":"dev-env/2016-02-10-start-a-node-project/","link":"","permalink":"http://rawbin-.github.io/dev-env/2016-02-10-start-a-node-project/","excerpt":"","text":"1 初步了解 首先了解下 npm 包管理 再了解下NodeJS配置文件 package.json 的结构和大致内容。 使用npm init 并按照提示信息初始化一个项目 查看npm run XXX中XXX可以配置的脚本 scripts, 其实可以配置任何自定义的脚本，如果只是项目内部使用。 2 站在巨人的肩上包管理系统的一个作用就是可以很方便的使用和集成这个系统内的其他包。 npm install/uninstall packageName 在当前目录下安装/卸载一个包 npm install/uninstall packageName -g 在全局的npm中安装/卸载一个包 npm install/uninstall packageName --save 在当前工程下安装/卸载一个包，同时处理package.json中的依赖 npm install/uninstall packageName --save-dev 在当前工程下安装/卸载一个包，同时处理package.json中的开发依赖 ​ 3 做得更多 进行单元测试 进行脚本集成 4 参考资料 npm doc 使用Mocha进行JavaScript单元测试 开始使用Browserify","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"}]},{"title":"编写NodeJS模块","slug":"modules/2016-02-15-write-node-module","date":"2021-12-31T02:37:59.918Z","updated":"2021-12-31T02:37:59.918Z","comments":true,"path":"modules/2016-02-15-write-node-module/","link":"","permalink":"http://rawbin-.github.io/modules/2016-02-15-write-node-module/","excerpt":"","text":"1 参考资料 C/C++ Addons Node.js调用C/C++ 动手编写Node的C++模块 用C++为nodejs 写组件，提高node处理效率 NodeJS 模块开发及发布详解 Writing Node.js Addons 详解Node.js API系列C/C++ Addons(1) API文档 详解Node.js API系列C/C++ Addons(2) Google V8引擎 详解Node.js API系列C/C++ Addons(3) 程序实例 详解Node.js API系列C/C++ Addons(4) Javascript也能搞嵌入式？","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"}]},{"title":"使用Mocha进行JavaScript单元测试","slug":"dev-tools/2016-02-17-using-mocha","date":"2021-12-31T02:37:59.918Z","updated":"2021-12-31T02:37:59.918Z","comments":true,"path":"dev-tools/2016-02-17-using-mocha/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-02-17-using-mocha/","excerpt":"","text":"以前也了解过一些JavaScript自动化测试的内容，没有真正上手，这阵子搞一个Velocity模板文件压缩的功能，刚好有机会用上。看这里体会一下效果，结构一目了然，点击测试行，还能看到具体的测试代码。 1 NodeJS环境测试基本看一遍Mocha官网的说明，就可以玩起来了。 先安装npm install mocha -g,这样就可以在命令行使用mocha命令了。 再找一个断言库，chai的功能比较丰富，npm install chai --save-dev 然后建立一个tests目录,在里面创建js文件写测试代码 describe 代表描述信息目录，it代表具体的用例 注意引入断言库，要用it包含断言语句才会被当做case 使用mocha命令执行刚刚的测试文件就ok。 也可以在IDE中搞Mocha相关的插件 2 浏览器环境测试 使用mocha init PATH，初始化一个用于浏览器中展示Test Case的资源目录。 这里面有一个tests.js，在这里面引入上文说到的各个测试文件 然后执行browserify tests.js&gt;tests-browser.js 转换浏览器中能执行的文件 将html中的tests.js改为转换后的 打开页面就可 ​ 3 参考资料 Web页面自动化测试 JavaScript自动化测试，测试框架 测试框架 Mocha 实例教程 Mocha 官网","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"mocha","slug":"mocha","permalink":"http://rawbin-.github.io/tags/mocha/"},{"name":"chai","slug":"chai","permalink":"http://rawbin-.github.io/tags/chai/"},{"name":"单元测试","slug":"单元测试","permalink":"http://rawbin-.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"开始使用Browserify","slug":"dev-tools/2016-02-18-using-browserify","date":"2021-12-31T02:37:59.918Z","updated":"2021-12-31T02:37:59.919Z","comments":true,"path":"dev-tools/2016-02-18-using-browserify/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-02-18-using-browserify/","excerpt":"","text":"1 将NodeJS的依赖进行打包写了一个NodeJS工程，主文件有一堆依赖，需要对外引用，而对应的依赖文件在特定环境下又用不起来。 于是将主文件及其依赖打包到一个文件，使用如下命令： browserify src-main.js --standalone exportModuleName&gt;dst-main.js --node 上面的命令会将src-main.js打包起来，并能同时浏览器和NodeJS环境下运行。但下面的情况除外： 1.1 一个坑查看 node-browserify 文档，参数说明如下 1234567891011121314--bare Alias for both --no-builtins, --no-commondir, and sets --insert-global-vars to just &quot;__filename,__dirname&quot;. This is handy if you want to run bundles in node. --no-browser-field, --no-bf Turn off package.json browser field resolution. This is also handy if you need to run a bundle in node. --node Alias for --bare and --no-browser-field. 即使使用了–node 参数，browserify还是会处理__dirname 导致转换后的代码，跟转换前的代码运行结果不一致。可以用下面的代码测一下： module.js 12345678910111213141516var sysFs = require(&#x27;fs&#x27;);var sysPath = require(&#x27;path&#x27;);var testModule = &#123; test:function()&#123; if(sysFs.existsSync(&quot;aa.txt&quot;))&#123; console.log(&quot;exist&quot;) &#125;else&#123; console.log(&quot;not exist&quot;); &#125; console.log(sysPath.join(__dirname,&#x27;aa&#x27;)) &#125;&#125;module.exports = testModule; 然后通过 browserify module.js --standalone exportModuleName&gt;module-bundle.js --node 然后查看module-bundle.js的代码，__dirname被转换写死了。 原则上这个是需要browserify中处理这个参数逻辑，也没找到其他能规避的参数，既然都强制使用–node了为什么还需要Node环境的变量呢？ 这里提了好些个Issue。 2 NodeJS的模块，在浏览器里面跑直接看这里 将NodeJS的单元测试模块直接，转换为浏览器可用的版本，在浏览器里面运行同样的代码。 使用browserify src.js &gt; dst.js 即可。 3 参考资料 浏览器加载 CommonJS 模块的原理与实现 解析browserify工作原理 Browserify原理 browserify运行原理分析 通过 Browserify 在浏览器中使用 NodeJS 模块 browserify.org node-browserify","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"Browserify","slug":"Browserify","permalink":"http://rawbin-.github.io/tags/Browserify/"}]},{"title":"开始使用PhantomJS","slug":"dev-tools/2016-02-12-using-phantomjs","date":"2021-12-31T02:37:59.918Z","updated":"2021-12-31T02:37:59.918Z","comments":true,"path":"dev-tools/2016-02-12-using-phantomjs/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-02-12-using-phantomjs/","excerpt":"","text":"1 需求对一批页面进行了内容压缩，想要测试压缩后的结果和压缩前的结果内容是否一致。这时候人肉已经不满足日益增长的页面数量的需要了。需要进行部分自动化。希望可以得到一个类似于单元测试的结果输出，能直观看出前后的结果差异。 2 初步使用PhantomJS 可以很方便的用来做浏览器模拟测试，网页截图等，它是一个命令行工具，执行JavaScript文件。 在使用的过程中，发现如下的问题: 生成的page对象，只能打开一个页面，需要打开另一个页面的话需要另外create一个page对象，同时page对象的使用不恰当的话，命令行不会报错的； 同时在evaluate中，使用console.log是无法打印出来东西的； 在PhantomJS的交互中，老出错定义一个page对象都出错； 整个PhantomJS执行的脚本中，无法共享NodeJS的模块； 这样就很不爽了，需要异步操作的库，比如Promise呢？ 3 寻求出路上面的问题的解决办法： 每打开一个页面，就先新建一个page对象 这个可以通过page.onConsoleMessage来获取 页面内部的console信息，类似的有onAlert，onPompt，onConfirm 这个没法玩 寻找其他的替代品 于是就有了能在NodeJS平台中跑的phantom，这里有简单的区别说明,用法基本都差不多是PhantomJS的用法，这里我们使用phantomjs-node。 phantomjs-node, node-phantom Node和npm的出现使得JavaScript的工具库出现了百花齐放、百家争鸣的景象，同一个库有很多个实现（比如Promise），同时你也可以根据自己的需要对开放的模块进行改装。比如基于PhantomJS的各种不同的封装，PhantomJS是命令行工具，PhantomJS-Node则是可以在Node平台跑的PhantomJS工具。 3.1 代码比较一开始使用比较两个页面html的方式来判断页面差异，最后发现如下问题： 页面中会有不少请求的url带上了时间戳，导致diff差异大； 同时页面中有JS动态生成的内容，执行的时间差异会导致内容不一样； 页面差异粒度太细，玩不下去了 这部分的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980byMinCode:function()&#123; function getPageContent(url)&#123; var _page; return phantomObj.then(function(ph)&#123; return ph.createPage(); &#125;).then(function(page)&#123; _page = page; return page.open(url) &#125;).then(function(status)&#123; if(status === &#x27;success&#x27;)&#123; return _page.evaluate(function()&#123; return document.documentElement.outerHTML; &#125;); &#125;else&#123; throw new Error(&#x27;fail to load page&#x27;) &#125; &#125;).then(function(content)&#123; return content; &#125;).catch(function(error)&#123; console.log(error) &#125;); &#125; var pathMaps = this.config.pathMaps; var tasks = [],tmpTask; var taskResults = &#123;&#125;; pathMaps.forEach(function(pathMap,index)&#123; var srcPath = pathMap[0]; var dstPath = pathMap[1]; var tmpResult = &#123; srcPath:srcPath, dstPath:dstPath &#125;; taskResults[srcPath] = tmpResult; tmpTask = Promise.all([getPageContent(srcPath),getPageContent(dstPath)]).then(function(results)&#123; var minifiedResults = results.map(function(content)&#123; return minifier(content,&#123; minifyCSS:true, minifyJS:true, // collapseInlineTagWhitespace:true, // collapseWhitespace:true, // conservativeCollapse:true &#125;); &#125;); tmpResult.srcContent = results[0]; tmpResult.dstContent = results[1]; tmpResult.isOriginEqual = tmpResult.srcContent === tmpResult.dstContent; tmpResult.minSrcContent = minifiedResults[0]; tmpResult.minDstContent = minifiedResults[1]; tmpResult.isMinEqual = tmpResult.minSrcContent === tmpResult.minDstContent; var dirName = sysPath.join(process.cwd(), &#x27;output&#x27;, &#x27;mincode&#x27;); if(!sysFs.existsSync(dirName))&#123; mkdirp.sync(dirName); &#125; sysFs.writeFileSync(sysPath.join(dirName, &#x27;srcContent-&#x27; + index),tmpResult.srcContent,&#x27;utf-8&#x27;); sysFs.writeFileSync(sysPath.join(dirName, &#x27;dstContent-&#x27; + index),tmpResult.dstContent,&#x27;utf-8&#x27;); sysFs.writeFileSync(sysPath.join(dirName, &#x27;minSrcContent-&#x27; + index),tmpResult.minSrcContent,&#x27;utf-8&#x27;); sysFs.writeFileSync(sysPath.join(dirName, &#x27;minDstContent-&#x27; + index),tmpResult.minDstContent,&#x27;utf-8&#x27;); &#125;).catch(function(reason)&#123; console.error(reason) &#125;); tasks.push(tmpTask); &#125;); Promise.all(tasks).then(function()&#123; Object.keys(taskResults).forEach(function(key)&#123; var result = taskResults[key]; console.log(result.srcPath) console.log(result.dstPath) console.log(result.isOriginEqual) console.log(result.isMinEqual) &#125;); process.exit(); &#125;);&#125; 3.2 渲染的图片比较刚说PhantomJS擅长浏览器模拟和截图，模拟上面我们已经试过了，这里看看截图功能的使用。在phantomjs-node中清一色的基于Promise的API，渲染图片的时候也是异步操作，跟PhantomJS中的使用有些差别。 这样我们就能方便的获得处理前后的页面的页面截图了，然后需要进行图片比较。我们到npmjs.org，去查找类似于”image diff”或者“image compar”的关键字，在得到的列表中找出我们喜欢的模块，当然node平台下的有图有示例代码的自然是优先的。比如resemblejs,就不错但是基于浏览器HTML5 API的，然后有一些基于Node的修改版 node-resemble-js 改了代码也改了文档 node-resemble.js 改了代码没改文档 node-resemble 改了代码和文档 resemble 我们使用node-resemble 来试试，然后这个包需要依赖node-canvas,然后就是神奇的依赖环境Windows，对于node-gyp和node-canvas来说都是很感人的，尤其是对于Win10来说。 本身机子安装了Visual Studio Express 2013，玩不起来，安装node-canvas会报错。 用Visual Studio Community 2015在线安装包，安装会报组件包找不到，怎么提供都不行。 用小水管下 Visual Studio Community 2015 Update 1 完整ISO（将近4G），安装还是会报组件包找不到，怎么着都不行。。。 用小水管继续下Visual Studio Community 2015 Update 2 完整ISO（将近7G），一路等待。 安装环境小结：参考 node-gyp 和 node-canvas 的安装说明。 安装Python 2.7 安装Visual Studio Community 2015 最新版，选Visual C++ 配置环境变量 GYP_MSVS_VERSION=2015 执行安装npm install node-resemble --GTK_Root=D:\\Applications\\gtkplus-bundle-2.22.1-win64\\ 这部分的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374bySnapShot:function()&#123; function getPageContent(url)&#123; var _page; return phantomObj.then(function(ph)&#123; return ph.createPage(); &#125;).then(function(page)&#123; _page = page; return page.open(url) &#125;).then(function(status)&#123; if(status === &#x27;success&#x27;)&#123; return _page; &#125;else&#123; throw new Error(&#x27;fail to load page&#x27;) &#125; &#125;).catch(function(error)&#123; console.log(error) &#125;); &#125; var pathMaps = this.config.pathMaps; var tasks = [],tmpTask; var taskResults = &#123;&#125;; pathMaps.forEach(function(pathMap,index)&#123; var srcPath = pathMap[0]; var dstPath = pathMap[1]; var tmpResult = &#123; srcPath:srcPath, dstPath:dstPath &#125;; taskResults[srcPath] = tmpResult; tmpTask = Promise.all([getPageContent(srcPath),getPageContent(dstPath)]).then(function(results)&#123; var srcPage = results[0]; var dstPage = results[1]; var dirName = sysPath.join(process.cwd(), &#x27;output&#x27;, &#x27;snapshots&#x27;); if(!sysFs.existsSync(dirName))&#123; mkdirp.sync(dirName); &#125; tmpResult.srcSnapshot = sysPath.join(dirName,&#x27;srcSnapshot-&#x27; + index + &#x27;.png&#x27;); tmpResult.dstSnapshot = sysPath.join(dirName,&#x27;dstSnapshot-&#x27; + index + &#x27;.png&#x27;); tmpResult.snapshotDiff = sysPath.join(dirName,&#x27;snapshotDiff-&#x27; + index + &#x27;.png&#x27;); //这个也是异步的 return Promise.all([srcPage.render(tmpResult.srcSnapshot),dstPage.render(tmpResult.dstSnapshot)]).then(function()&#123; return new Promise(function(resolve,reject)&#123; var srcSnapshotData = sysFs.readFileSync(tmpResult.srcSnapshot); var dstSnapshotData = sysFs.readFileSync(tmpResult.dstSnapshot); resemble(srcSnapshotData).compareTo(dstSnapshotData).onComplete(function(data)&#123; var dataUrl = data.getImageDataUrl(); var prefix = &quot;data:image/png;base64,&quot;; var base64Data = dataUrl.slice(prefix.length); var fileData = new Buffer(base64Data,&#x27;base64&#x27;); sysFs.writeFileSync(tmpResult.snapshotDiff,fileData); resolve(); &#125;); &#125;); &#125;); &#125;).catch(function(reason)&#123; console.error(reason) &#125;); tasks.push(tmpTask); &#125;); Promise.all(tasks).then(function()&#123; Object.keys(taskResults).forEach(function(key)&#123; var result = taskResults[key]; console.log(result.srcPath) console.log(result.dstPath) &#125;); process.exit(); &#125;);&#125; 4 参考资料 PhantomJS PhantomJS 教程 phantomjs-node node-phantom phantomjs入门学习笔记 phantomjs使用说明 利用nodejs+phantomjs+casperjs采集淘宝商品的价格 鼓捣phantomjs，做ajax网站的信息采集 NodeJS + PhantomJS 抓取页面信息以及截图 Resemble Resemble.js github CasperJS SlimerJS SpookyJS PhantomCSS Headless Testing Related Projects Moving from PhantomJS to node-webkit 从PhantomJS迁移到node-webkit：自动化测试框架简单比较 CSS Regression Testing CSS Testing with PhantomCSS, PhantomJS, CasperJS and Grunt CSS回归测试与Resemble.js 浏览器自动化测试初探 - 使用phantomjs与casperjs image-diff blink-diff","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://rawbin-.github.io/tags/javascript/"},{"name":"phantomjs","slug":"phantomjs","permalink":"http://rawbin-.github.io/tags/phantomjs/"},{"name":"nodejs","slug":"nodejs","permalink":"http://rawbin-.github.io/tags/nodejs/"}]},{"title":"使用git submodule管理公共项目","slug":"dev-tools/git/2016-02-14-using-gitsubmodule","date":"2021-12-31T02:37:59.918Z","updated":"2021-12-31T02:37:59.918Z","comments":true,"path":"dev-tools/git/2016-02-14-using-gitsubmodule/","link":"","permalink":"http://rawbin-.github.io/dev-tools/git/2016-02-14-using-gitsubmodule/","excerpt":"","text":"1 引子svn 有一个引用外部版本库的方式，svn:external；把另外一个版本库作为当前版本库的资源（一部分）。默认开启自动检出外部引用，这个外部引用可以指向一个分支的某个版本，也可以一直指向最新版本。 git submodule跟这个类似，两个不同点：一个是默认不自动检出，另一个是只能指向某个特定的版本。 进入子模块目录，可以向主工程信息一样进行git操作。 2 操作方法2.1 查看外部版本库信息git submodule 类似于git branch 2.2 添加外部库git submodule add REPOSITORY_URL PATH_TO_SUBMODULE 在当前目录中生成一个.gitmodules的文件，里面记录了每个submodule额仓库和路径信息 2.3 查看外部库状态git submodule status 2.4 初始化外部库git submodule init 这个命令修改.git/config中的内容，对外部库（子模块）进行注册。 2.5 更新外部库信息git submodule update 这个命令会按照主项目中包含的子模块的信息更新指定版本的子模块的内容，如果子模块目录中存在未提交的更改，内容可能会丢失。 2.6 删除外部库 git rm --cached PATH_TO_SUBMODULE然后删除.gitmodules和.git/config中响应的module的内容。 或者 git submodule deinit PATH_TO_SUBMODULE 然后删除.gitmodules中对应的module内容 3 应用3.1 检出一个带有外部版本库的项目123git clone REPOSITORY_URL NAMEgit submodule initgit submodule update 3.2 修改外部版本库的引用版本12345cd PATH_TO_SUBMODULEgit chechout REVISIONcd PATH_TO_MAIN_PROJECTgit add .git ci -m &quot;update submodule revision&quot; 4 参考资料 Git Submodule使用完整教程 Git Submodule管理项目子模块 git submodule 管理子工程 git submodule git 子模块 How to Remove Git Submodules git 子树合并","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"开发环境/Git","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://rawbin-.github.io/tags/git/"},{"name":"submodule","slug":"submodule","permalink":"http://rawbin-.github.io/tags/submodule/"}]},{"title":"开始使用fetch api","slug":"async/2016-02-05-using-fetch","date":"2021-12-31T02:37:59.917Z","updated":"2021-12-31T02:37:59.917Z","comments":true,"path":"async/2016-02-05-using-fetch/","link":"","permalink":"http://rawbin-.github.io/async/2016-02-05-using-fetch/","excerpt":"","text":"1 参考资料 作为基础的Promise fetch API 简介 深入浅出Fetch API 带你入解应用场景及适用问题 传统 Ajax 已死，Fetch 永生 传统 Ajax 已死，Fetch 永生 fetch API 简单解读 【翻译】这个API很“迷人”——(新的Fetch API) Fetch and its polyfill fetch whatwg fetch caniuse MDN fetch fetch isomorphic-fetch fetch-ie8 fetch-jsonp node-fetch","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"fetch","slug":"fetch","permalink":"http://rawbin-.github.io/tags/fetch/"},{"name":"ajax","slug":"ajax","permalink":"http://rawbin-.github.io/tags/ajax/"},{"name":"javascript","slug":"javascript","permalink":"http://rawbin-.github.io/tags/javascript/"}]},{"title":"Web前端技术栈参考","slug":"dev-general/2016-02-05-frontend-reference","date":"2021-12-31T02:37:59.917Z","updated":"2021-12-31T02:37:59.917Z","comments":true,"path":"dev-general/2016-02-05-frontend-reference/","link":"","permalink":"http://rawbin-.github.io/dev-general/2016-02-05-frontend-reference/","excerpt":"","text":"参考资料 前端开发者手册 Web前端开发大系概览 （前端开发技术栈） 前端开发技术栈 【开源推荐】JavaScript开发工具大合集 Node.js最新Web技术栈 JavaScript 开发者年度调查报告 2016 年前端开发领域有什么趋势值得关注？ 2016年这9大开发趋势预测你还不知道就out了 2016年的前端技术栈展望 2016年的前端技术栈展望 ​","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"技术栈","slug":"技术栈","permalink":"http://rawbin-.github.io/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"正则表达式和字符串匹配算法","slug":"structure-algorithm/2016-02-05-regex-string-match","date":"2021-12-31T02:37:59.917Z","updated":"2021-12-31T02:37:59.917Z","comments":true,"path":"structure-algorithm/2016-02-05-regex-string-match/","link":"","permalink":"http://rawbin-.github.io/structure-algorithm/2016-02-05-regex-string-match/","excerpt":"","text":"参考资料 正则表达式精萃 正则表达式匹配解析过程探讨分析（正则表达式匹配原理） 正则表达式中的回溯 正则表达式之回溯 字符串匹配算法比较 关于字符串匹配算法研究 字符串匹配的KMP算法 字符串匹配的KMP算法 字符串匹配算法 KMP字符串模式匹配详解 多种字符串匹配算法杂谈 字符串匹配 字符串 模式匹配","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://rawbin-.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"}]},{"title":"Chrome 开发者工具使用参考","slug":"dev-tools/2016-02-06-chrome-inspect","date":"2021-12-31T02:37:59.917Z","updated":"2021-12-31T02:37:59.917Z","comments":true,"path":"dev-tools/2016-02-06-chrome-inspect/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-02-06-chrome-inspect/","excerpt":"","text":"1 参考资料 Chrome 35个开发者工具的小技巧 Chrome Dev Tips动画版 Chrome开发者工具使用技巧 Chrome 开发者工具的技巧 Chrome开发者工具不完全指南 前端调试效率低？试试这10个“Chrome开发者工具”使用技巧 移动前端调试方案（Android + Chrome 实现远程调试） Chrome DevTool Tips and Tricks Chrome DevTool中文翻译ing 你所不知道的10个“Chrome开发者工具”使用技巧 使用 Chrome 开发者工具进行 JavaScript 问题定位与调试 Chrome开发者工具不完全指南（一、基础功能篇） Chrome开发者工具不完全指南（二、进阶篇） Chrome开发者工具不完全指南：（三、性能篇） Chrome开发者工具不完全指南（四、性能进阶篇） Chrome开发者工具不完全指南（五、移动篇） Chrome开发者工具不完全指南（六、插件篇）","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://rawbin-.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Inspect","slug":"Inspect","permalink":"http://rawbin-.github.io/tags/Inspect/"},{"name":"Chrome","slug":"Chrome","permalink":"http://rawbin-.github.io/tags/Chrome/"}]},{"title":"JavaScript事件学习参考","slug":"web-standard/2016-02-05-javascript-events","date":"2021-12-31T02:37:59.917Z","updated":"2021-12-31T02:37:59.917Z","comments":true,"path":"web-standard/2016-02-05-javascript-events/","link":"","permalink":"http://rawbin-.github.io/web-standard/2016-02-05-javascript-events/","excerpt":"","text":"参考资料 W3C UIEvents W3C UIEvents Code HTML DOM Event HTML事件属性 Javascript事件参考手册","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Events","slug":"Events","permalink":"http://rawbin-.github.io/tags/Events/"},{"name":"事件","slug":"事件","permalink":"http://rawbin-.github.io/tags/%E4%BA%8B%E4%BB%B6/"}]},{"title":"开始使用Promise","slug":"async/2016-02-04-using-promise","date":"2021-12-31T02:37:59.916Z","updated":"2021-12-31T02:37:59.916Z","comments":true,"path":"async/2016-02-04-using-promise/","link":"","permalink":"http://rawbin-.github.io/async/2016-02-04-using-promise/","excerpt":"","text":"1 有哪些特性 ECMA2015(ES6) 标准 解决回调金字塔问题 链式调用，表达更加直观 逐步被各种库和浏览器实现 2 实质是什么 一种表达形式 一个类（JavaScript函数对象），及其相关的属性和方法 可以自定义实现 3 如何使用 什么是Promise Promise实战 4 如何实现 Promise实现原理 闲话Promise机制 深入实现Promise A+规范 教你一步一步实现一个Promise ​ ​ 5 参考资料 ES6 Promise的感性认识 Promise对象 Javascript 中的神器——Promise Promise的前世今生和妙用技巧 Promise API We have a problem with promises Promise Anti-patterns [译] 深入理解 Promise 五部曲 JavaScript Promise 迷你书中文版 【翻译】Promises/A+规范 Promise/A+规范 JavaScript Promise promise guide MDN Promise Promise 对象 JavaScript Promise启示录 JavaScript Promise启示录 JS魔法堂：剖析源码理解Promises/A规范 Promise/A的误区以及实践 es6-promise","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"http://rawbin-.github.io/tags/Promise/"}]},{"title":"Spring 配置velocity tools","slug":"framework/2016-01-18-spring-velocity-tools","date":"2021-12-31T02:37:59.916Z","updated":"2021-12-31T02:37:59.916Z","comments":true,"path":"framework/2016-01-18-spring-velocity-tools/","link":"","permalink":"http://rawbin-.github.io/framework/2016-01-18-spring-velocity-tools/","excerpt":"","text":"配置velocity tools 让velocity更灵活地处理数据渲染，降低数据和展示的耦合。 1 参考资料 velocity tools custom tool for velocity springMVC+velocity配置 Spring MVC下配置Velocity velocity模板引擎学习(2)-velocity tools 2.0 spring mvc 配置 velocity Tool 让 Spring3 支持 velocity tools 2.x spring velocity-tools-2.0配置问题 Velocity 工具类配置 spring3下velocity配置问题解决 velocity 时间显示 时间格式化 时间转化 Velocity Date format 常见异常解决 maven版本问题 GC overhead limit exceeded填坑心得","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"Java开发","slug":"开发技术/Java开发","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Java%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://rawbin-.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://rawbin-.github.io/tags/Spring/"},{"name":"Velocity","slug":"Velocity","permalink":"http://rawbin-.github.io/tags/Velocity/"},{"name":"Velocity-tools","slug":"Velocity-tools","permalink":"http://rawbin-.github.io/tags/Velocity-tools/"}]},{"title":"JavaScript正则表达式应用 移除注释","slug":"language/ecma-javascript/2016-01-18-javascript-regex-uglify","date":"2021-12-31T02:37:59.916Z","updated":"2021-12-31T02:37:59.916Z","comments":true,"path":"language/ecma-javascript/2016-01-18-javascript-regex-uglify/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2016-01-18-javascript-regex-uglify/","excerpt":"","text":"1 使用JavaScript正则表达式匹配注释1.1 匹配velocity注释 单行注释 /##[^\\r\\n]*/g 多行注释 /#*[\\s\\S]*?*#/g 1.2 匹配HTML注释 匹配HTML注释保护IE条件注释 /&lt;!--(?!\\s*\\[if)[\\s\\S]*?--&gt;/g 1.3 匹配CSS 匹配CSS 标签 /&lt;(style)[\\w\\W]*?\\1/g 匹配CSS 注释 /\\/*[\\s\\S]*?*\\//g 匹配JavaScript 匹配JavaScript标签 /&lt;(script)[\\w\\W]*?\\1&gt;/g 匹配单行注释 /(^|\\b|\\s|[^&#39;&quot;:\\w\\d])(\\/\\/[^\\r\\n]*)/g 匹配多行注释 /\\/*[\\s\\S]*?*\\//g ​ 2 参考资料 JavaScript正则表达式及其应用 Finding Comments in Source Code Using Regular Expressions Finding Comments in HTML Source Code Using Regular Expressions 正则表达式匹配多行注释 正则表达式匹配多行注释 【正则表达式 去掉注释】_正则表达式 去掉注释的相关文章，教程，源码 IE条件注释详解","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://rawbin-.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"移除注释","slug":"移除注释","permalink":"http://rawbin-.github.io/tags/%E7%A7%BB%E9%99%A4%E6%B3%A8%E9%87%8A/"}]},{"title":"高效的jQuery选择器实践","slug":"language/ecma-javascript/2016-02-02-efficient-css-selector","date":"2021-12-31T02:37:59.916Z","updated":"2021-12-31T02:37:59.916Z","comments":true,"path":"language/ecma-javascript/2016-02-02-efficient-css-selector/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2016-02-02-efficient-css-selector/","excerpt":"","text":"1 参考资料 如何提升 CSS 选择器性能 jQuery 2.0.3 源码分析Sizzle引擎 - 词法解析 Web最佳实践：JQuery高性能优化 针对 jQuery 性能优化的28个建议 【翻译】Jquery性能优化之选择器优化 Optimize Selectors jQuery性能优化方案——选择器 jQuery性能优化大全 Writing efficient CSS","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://rawbin-.github.io/tags/jQuery/"},{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"}]},{"title":"react 实战参考","slug":"framework/react/2016-01-18-react-basics","date":"2021-12-31T02:37:59.916Z","updated":"2021-12-31T02:37:59.916Z","comments":true,"path":"framework/react/2016-01-18-react-basics/","link":"","permalink":"http://rawbin-.github.io/framework/react/2016-01-18-react-basics/","excerpt":"","text":"1 参考资料 React官方文档 React中文文档 React中文文档 React入门实例教程 React入坑指南 一看就懂的ReactJs入门教程（精华版） React中文开发手册 React Native官方文档 React Native中文参考 深入浅出React Native From JSXTransformer to Babel","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://rawbin-.github.io/tags/React/"}]},{"title":"网站速度检测工具汇总","slug":"performance/2016-01-12-website-speed","date":"2021-12-31T02:37:59.915Z","updated":"2021-12-31T02:37:59.915Z","comments":true,"path":"performance/2016-01-12-website-speed/","link":"","permalink":"http://rawbin-.github.io/performance/2016-01-12-website-speed/","excerpt":"","text":"1 网站性能数据分析 https://gtmetrix.com/ 页面各种性能测试 http://tools.pingdom.com/fpt/ 网站综合性能测试 http://www.iqm.cn/index.php 网站速度测试 http://www.linkwan.com/gb/ 不同地区的网速测试 http://www.speedtest.cn/ 上传下载网速测试 2 不同节点网站速度测试 http://tool.chinaz.com/speedcom.aspx 网站速度对比 http://tool.chinaz.com/speedtest.aspx 不同节点速度测试 http://ping.chinaz.com/ 不同节点ping http://www.17ce.com/ 全国多节点网速测试，可对比 http://www.webkaka.com/ 国内和全球节点速度测试 http://ce.cloud.360.cn/ 不同节点速度测试","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"Web性能优化","slug":"应用技术/Web性能优化","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"网站速度检测","slug":"网站速度检测","permalink":"http://rawbin-.github.io/tags/%E7%BD%91%E7%AB%99%E9%80%9F%E5%BA%A6%E6%A3%80%E6%B5%8B/"},{"name":"延时检测","slug":"延时检测","permalink":"http://rawbin-.github.io/tags/%E5%BB%B6%E6%97%B6%E6%A3%80%E6%B5%8B/"},{"name":"性能测试","slug":"性能测试","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"Win10 耳机 扬声器自动切换，插入耳机关闭扬声器","slug":"os-app/2016-01-14-win10-audio-auto-switch","date":"2021-12-31T02:37:59.915Z","updated":"2021-12-31T02:37:59.915Z","comments":true,"path":"os-app/2016-01-14-win10-audio-auto-switch/","link":"","permalink":"http://rawbin-.github.io/os-app/2016-01-14-win10-audio-auto-switch/","excerpt":"","text":"1 现象Win10中的VIA驱动，插入耳机无法自动关闭扬声器，耳机没有声音；手动切换耳机为默认设备之后，插入插入耳机可以正常播放，但拔掉耳机无法自动切换到扬声器。 这个也是Win10自以为牛逼的改进功能，将扬声器和耳机作为了独立的设备，可以不共享音源。 2 解决办法 自然是安装原版VIA驱动，安装完成之后就会有 VIA HD Audio Deck这个可以管理音频配置 打开配置之后，都是一些属性配置，看看边边角角（我的在右下角）有没有带扳手或者齿轮或者设置的东东 打开之后可能发现只能设置一个语言选项，别灰心 将如下内容另存为，xxx.reg，然后管理员权限运行。 12345Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\System\\CurrentControlSet\\Services\\VIA HD Audio Codec Default\\VDeckINI\\VDeck\\NB_CASE]&quot;Show_HP_Mode_Change_Option&quot;=&quot;1&quot; 关闭VIA HD Audio Deck（右下角右键退出），然后再打开 在同样的设置的地方（如果没有请重启或者过会再试，注册表有生效延迟），会有“喇叭和耳机设为同一音源”的选项，选中这个即可。 3 参考资料 【麦·技术】解决WIN10系统 VIA HD驱动无法自动切换外置","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"操作系统","slug":"应用技术/操作系统","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://rawbin-.github.io/tags/Win10/"},{"name":"VIA","slug":"VIA","permalink":"http://rawbin-.github.io/tags/VIA/"},{"name":"耳机","slug":"耳机","permalink":"http://rawbin-.github.io/tags/%E8%80%B3%E6%9C%BA/"},{"name":"扬声器","slug":"扬声器","permalink":"http://rawbin-.github.io/tags/%E6%89%AC%E5%A3%B0%E5%99%A8/"}]},{"title":"Node JS版本管理，多版本切换，多套开发环境","slug":"dev-tools/2016-01-11-node-version-management","date":"2021-12-31T02:37:59.915Z","updated":"2021-12-31T02:37:59.915Z","comments":true,"path":"dev-tools/2016-01-11-node-version-management/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2016-01-11-node-version-management/","excerpt":"","text":"1 缘由NodeJS 跟Python类似，版本间差异较大，版本中组件的依赖关系较严格，所以我们不能用一套NodeJS环境解决所有项目的问题；最常用是不同的项目或者不同的组件或者不同的工具，可能使用不同的Node版本环境；所以，我们需要在不同的NodeJS版本间进行自由快速切换。 1.1 工具NodeJS在类Unix环境中使用问题较少，在Windows中问题稍多，但我们必须直面Windows下使用的问题。 我们需要一个比较符合国情的NodeJS管理工具，nvm比较适合，nvmw比较适合，因为他们可以配置国内镜像的安装路径。其实nvm-windows更加简单，但无法配置国内镜像，在NodeJS和Github网络环境较好的时候使用为佳。 1.1.1 Linux n nvm ​ 1.1.2 Windows nvmw nvm-windows nvm-for-windows nodlist 1.2 nvm-windows使用这里使用nvm-windows来做一个全程使用示例，其他类似。 使用nvm来管理，就不需要手动安装NodeJS了，直接使用nvm来安装和卸载 1.2.1 原理 有一个公用的NodeJS版本的代理路径 每一个NodeJS版本放入一个目录（包括相应的npm） 每次切换NodeJS版本的时候，就将这个代理路径指向目标NodeJS版本对应的目录 这样外部访问路径都是同一个，不同的版本进入不同目录 1.2.2 安装到 这里 去下载最新的nvm-windows版本，然后安装。 安装之前卸载之前安装的NodeJS，避免安装后版本错乱问题 注意使用右键 管理员权限 如果有系统防护类软件报警，需要允许 安装完成之后，打开命令行，输入nvm 便可以看到简单的几条命令说明（悄悄看） 1.2.3 配置如果使用nvm-windows默认的配置，会到nodejs.org上去下载相应的资源，这样会很慢，或者根本下不下来 可以选择使用一个VPN或者能连接nodejs.org的环境，这个是nvm-windows的软肋， nvm和nvmw都有配置国内镜像源的环境变量，但我使用了nvmw配置了镜像源，然并卵 1.2.4 使用 nvm ls查看当前的node环境列表 nvm list avaliable 查看哪些可以安装的版本列表 nvm install x.xx.xx 安装这个版本 nvm uninstall x.xx.xx 卸载这个版本 nvm use x.xx.xx 切换到这个版本 1.2.5 在这之上上面我们已经有了基础的node环境了，我们可以使用nvm install安装不同的NodeJS环境，然后使用nvm use 切换到不同的版本，然后再当前版本下安装适合当前NodeJS版本的Node模块。 nvm use 0.12.12 npm install fekit@0.2.85 -g nvm use 4.4.0 npm install fekit -g 这样我们就在本机安装了两个fekit版本，可以根据需要使用nvm use来切换NodeJS环境，从而达到切换fekit版本的目的 1.2.6 一些优化配置npm官网访问速度相当的慢，安装npm 组件包，很可能就失败了。一个比较有效的方法: npm install nrm -g --registry=http://registry.npm.taobao.org/ 这样我们就装了一个npm 镜像管理的组件，然后可以很方便的切换npm组件源 nrm use taobao切换到淘宝npm源 nrm use cnpm切换到cnpm的源 nrm use npm 切回官方的npm源 1.3 参考资料 nvm管理node，并加速nvm、加速npm 快速搭建 Node.js 开发环境以及加速 npm 快速搭建 Node.js 开发环境以及加速 npm","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"前端开发","slug":"开发技术/前端开发","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"开发环境","slug":"开发技术/前端开发/开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"node","slug":"node","permalink":"http://rawbin-.github.io/tags/node/"},{"name":"nvm","slug":"nvm","permalink":"http://rawbin-.github.io/tags/nvm/"},{"name":"n","slug":"n","permalink":"http://rawbin-.github.io/tags/n/"},{"name":"nvmw","slug":"nvmw","permalink":"http://rawbin-.github.io/tags/nvmw/"}]},{"title":"JavaScript数值处理小结","slug":"language/ecma-javascript/2016-01-16-javascript-number","date":"2021-12-31T02:37:59.915Z","updated":"2021-12-31T02:37:59.915Z","comments":true,"path":"language/ecma-javascript/2016-01-16-javascript-number/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2016-01-16-javascript-number/","excerpt":"","text":"1 数值处理的方法1.1 全局转换方法1.1.1 parseFloat从参数字符串的第一个字符开始进行解析，处理所有连续的有效浮点数字的部分（包含小数点），如果一个有效数位都没有就返回NaN，否则返回从第一个字符开始连续的数字部分的值。 1.1.2 parseInt从参数字符串的第一个字符开始，按照给定的进制（不提供默认为10）进行解析，处理所有连续的指定进制的有效整形数字的部分（不包含小数点），如果一个有效数位都没有就返回NaN，否则返回从第一个字符开始连续的数字部分的值。 1.2 Number对象1.3 Math对象1.3.1 Math.min1.3.2 Math.max1.3.3 Math.floor1.3.4 Math.ceil1.3.5 Math.round","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"数值","slug":"数值","permalink":"http://rawbin-.github.io/tags/%E6%95%B0%E5%80%BC/"},{"name":"int","slug":"int","permalink":"http://rawbin-.github.io/tags/int/"},{"name":"float","slug":"float","permalink":"http://rawbin-.github.io/tags/float/"}]},{"title":"fekit mock 内存泄露问题排查和解决","slug":"dev-tools/fekit/2016-01-14-fekit-mock-memleak","date":"2021-12-31T02:37:59.915Z","updated":"2021-12-31T02:37:59.915Z","comments":true,"path":"dev-tools/fekit/2016-01-14-fekit-mock-memleak/","link":"","permalink":"http://rawbin-.github.io/dev-tools/fekit/2016-01-14-fekit-mock-memleak/","excerpt":"","text":"1 现象Win10 NodeJS 0.12.12 使用fekit 最新版 0.2.141 本地开发 fekit server -m package_b2c_admin/tests/mock.conf fekit进程内存很快会涨到1G以上，基本上就是卡死状态，浏览器刷不出来静态资源 可以通过如上命令起本地server，多次刷新带较多静态资源的页面，同时监控进程占用的内存 2 解决办法 切换NodeJS版本 实测Node 0.10.42, Node 0.10.43, Node 5.9.0 无此问题 Node 4.3.0, 4,4.0, 0.12.12 有此问题 推测，相关的大版本应该都有问题 简单调整fekit mock.js代码 修改FEKIT_HOME/lib/middleware/mock.js 将sandbox 的定义提到闭包外面来 进一步优化fekit mock.js代码 修改FEKIT_HOME/lib/middleware/mock.js 将mock_file()的结果缓存起来，如果被更新了才进行重新计算。 3 原因分析原因这里就不分析了，记一次 Node.js 应用内存暴涨分析，这个小伙伴已经分析的很不错了。 4 排查过程4.1 不带mock信息无此问题，内存在100M上下波动，正常 4.2 与0.2.85 比较，发现代码几乎无差别，改动的代码对此几乎无影响4.3 在FEKIT_HOME/lib/command/server.js中进行中间件切除发现去掉mock后 .use(middleware.mock(options)) 问题基本解决 4.4 上面两条有点相互矛盾4.5 通过node-inspector 调试node-debug &quot;C:\\Users\\liao.zhang\\AppData\\Roaming\\nvm\\v4.3.0\\node_modules\\fekit\\bin\\fekit&quot; server -m package_b2c_admin/tests/mock.conf node --debug-brk &quot;C:\\Users\\liao.zhang\\AppData\\Roaming\\nvm\\v4.3.0\\node_modules\\fekit\\bin\\fekit&quot; server -m package_b2c_admin/tests/mock.conf 查看profile数据，发现fekit占用的内容并不多 4.6 不管上面的矛盾看看这里面闭包比较多的地方，分片注释，可以定位到 try &#123; vm.runInNewContext(exjson(mock_file()), sandbox); &#125; catch (err) &#123; sandbox.module.exports = &#123;&#125;; utils.logger.error(&quot;mock 配置文件出错 &quot; + (err.toString())); &#125; JavaScript虚拟机内存没有被释放，调用的次数又太多（每一个请求都调用），所以内存爆了 4.7 再回来可以说已经不是fekit的问题了，85的代码和141的代码一样的时候，也会有这样的问题 4.8 NodeJS文档 0.10.x 0.12.x 大致测试，0.10.xx 应该没有这个问题；0.11.x,0.12.xx, 4.4.0 有这个问题，法不责众，我们回过头来看看fekit。 4.9 换个姿势上面说可以说是不是fekit的问题，因为NodeJS也有问题，再来看看fekit到底有没有问题 module.exports = function(options) &#123; var mock_file; if (!(options.mock &amp;&amp; utils.path.exists(options.mock))) &#123; return noop; &#125; utils.logger.log(&quot;成功加载 mock 配置 &quot; + options.mock); mock_file = utils.file.io.readbymtime(options.mock); return function(req, res, next) &#123; var action, key, pattern, pieces, result, rule, rules, sandbox, url, _i, _len, _ref; sandbox = &#123; module: &#123; exports: &#123;&#125; &#125; &#125;; try &#123; vm.runInNewContext(exjson(mock_file()), sandbox); &#125; catch (err) &#123; sandbox.module.exports = &#123;&#125;; utils.logger.error(&quot;mock 配置文件出错 &quot; + (err.toString())); &#125; //....... &#125; 上面的代码是fekit mock 中间件的主要代码，这片代码会在每个请求到达的时候被执行；可以看到在闭包里面申明了，一个沙盒变量，每次请求都会申请这么一片内存。 对于mock，在每次请求时内容不一样的情况是不可能事件，这里可以有两种解决办法：1、将执行前的文件内容进行缓存，判断如果一样，就不执行了，执行了也没啥意义2、直接申请同一片内存，后面的复写前面的，刷了就刷了 先用第二条改改试试效果。 module.exports = function(options) &#123; var mock_file,sandbox; if (!(options.mock &amp;&amp; utils.path.exists(options.mock))) &#123; return noop; &#125; utils.logger.log(&quot;成功加载 mock 配置 &quot; + options.mock); mock_file = utils.file.io.readbymtime(options.mock); sandbox = &#123; module: &#123; exports: &#123;&#125; &#125; &#125;; return function(req, res, next) &#123; var action, key, pattern, pieces, result, rule, rules, url, _i, _len, _ref; try &#123; vm.runInNewContext(exjson(mock_file()), sandbox); &#125; catch (err) &#123; sandbox.module.exports = &#123;&#125;; utils.logger.error(&quot;mock 配置文件出错 &quot; + (err.toString())); &#125; //....... &#125; 再来看看配合缓存结果，以空间换时间的方法： module.exports = function(options) &#123; var mock_file,sandbox,lastMockConfig = &quot;&quot;; if (!(options.mock &amp;&amp; utils.path.exists(options.mock))) &#123; return noop; &#125; sandbox = &#123; module: &#123; exports: &#123;&#125; &#125; &#125;; utils.logger.log(&quot;成功加载 mock 配置 &quot; + options.mock); mock_file = utils.file.io.readbymtime(options.mock); return function(req, res, next) &#123; var action, key, pattern, pieces, result, rule, rules, url, _i, _len, _ref; var thisMockConfig = mock_file(); //读文件都有缓存，计算自然也可以有，重复计算也没有意义 if(thisMockConfig !== lastMockConfig)&#123; lastMockConfig = thisMockConfig; try &#123; vm.runInNewContext(exjson(thisMockConfig), sandbox); &#125; catch (err) &#123; sandbox.module.exports = &#123;&#125;; utils.logger.error(&quot;mock 配置文件出错 &quot; + (err.toString())); &#125; &#125; // ...... &#125; 于是这里的内存泄露问题得到解决。 5 参考文档 记一次 Node.js 应用内存暴涨分析 记一次 Node.js 应用内存暴涨分析 使用Node.js的VM执行脚本之后，沙箱所占的内存没有被清掉 Node内存泄漏专题 NodeJS内存泄露的几种情况及解决方案 Memory leak patterns in JavaScript 浅谈V8引擎中的垃圾回收机制 深入理解Node.js中的垃圾回收和内存泄漏的捕获 Node.js如何应对内存泄露？ node-inspector 查看 Node.js 中的内存泄露 NodeJS调试GC及内存暴涨的分析 使用Chrome+node-inspector查找NodeJS内存泄漏 The node.js Profiling Guide that Hasn’t Existed - Profiling node.js Applications The node.js Profiling Guide that Hasn’t Existed - Finding a potential memory leak using memwatch The node.js Profiling Guide that Hasn’t Existed - Finding The Cause of a Memory Leak Using Heap Snapshots","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"应用技术","slug":"开发技术/应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"fekit","slug":"fekit","permalink":"http://rawbin-.github.io/tags/fekit/"},{"name":"mock","slug":"mock","permalink":"http://rawbin-.github.io/tags/mock/"},{"name":"内存泄露","slug":"内存泄露","permalink":"http://rawbin-.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"}]},{"title":"Git常用操作命令梳理","slug":"dev-tools/git/2016-01-18-git-commands","date":"2021-12-31T02:37:59.915Z","updated":"2021-12-31T02:37:59.916Z","comments":true,"path":"dev-tools/git/2016-01-18-git-commands/","link":"","permalink":"http://rawbin-.github.io/dev-tools/git/2016-01-18-git-commands/","excerpt":"","text":"1 基本操作1.1 仓库生成12git init [DIR-NAME] //将当前目录，或者指定的DIR-NAME目录初始化为仓库git clone REPOSITORY-URL [DIR-NAME] //将远端工程放入当前目录，或者重命名为指定的DIR-NAME的目录 1.2 分支操作1234567git branch 显示本地分支，-r 显示远程分支 -a 显示所有分支git branch NEW-BRANCH 以当前分支为基础创建一个分支git branch NEW-BRANCH BASE-BRANCH 以BASE-BRANCH为基础创建一个分支git checkout -b NEW-BRENCH 以当前分支为基础创建一个分支git checkout -b NEW-BRANCH BASE-BRANCH 以BASE-BRANCH为基础创建一个分支git checkout BRANCH-NAME 切换到分支git branch -d BRANCH-NAME 删除BRANCH-NAME指定的分支（如果要删除的分支有内容未合并到当前分支，不能删除） -D表示无条件删除 1.3 内容整合1234git fetch [REPOSITORY-URL REMOTE-BRANCH] 取回远端分支内容git merge ANOTHER-BRANCH 将ANOTHER-BRANCH的内容合并到当前分支git pull [REPOSITORY-URL REMOTE-BRANCH:LOCAL-BRANCH] 将远端分支的内容取回并尝试合并git mergetool 使用合并工具进行合并 1.4 内容提交12345git status 查看当前改动提交状态git diff 对比工作区和暂存区，--cached 为比较暂存区和HEADgit add . 添加所有改动到git 跟踪，指定FILEPATH则只添加指定内容git commit -m &quot;commit log&quot; 提交所有改动到本地仓库， --amend 表示调整上一次提交git push [REPOSITORY-URL LOCAL-BRANCH:REMOTE-BRANCH] 推动本地仓库信息到远端仓库 2 使用实践2.1 当前工作未完成，临时切换到其他分支12345git stash 暂存当前未提交的内容git stash save &quot;stash log&quot; 暂存内容并提供描述信息git stash pop 将最后一个暂存的内容取出git stash list 查看所有暂存git stash pop [stash@&#123;n&#125;] 取出一个特定的暂存 2.2 查找某处变更是哪次提交生成的（bug是谁在什么时候写的~）2.2.1 方法一1git blame FILE-NAME -L m,n 查看m到n行之间的最后一次变更的信息 2.2.2 方法二1git log -L m,n:FILE-NAME 查看文件的m到n行之间的变化 2.2.3 方法三1234git bisect start 开始一个二分查找git bisect bad COMMIT-ID 设置一个已经出问题的版本git bisect good COMMIT-ID 设置一个没有问题的版本git bisect good|bad 持续的给结果，最后会定位到一个版本，结果跟方法二的类似 2.2.4 方法四1git show :/KEY-WORD 查找关键信息的变更，这里给出的是一个大致信息，比如是在其他分支做出的改动 2.2.5 方法五1git log -p -S &quot;字符串&quot; 查找字符串在整个提交历史的出现， -G &quot;正则表达式&quot; 2.2 查看文件的历史 包括被删除的文件123git log -- FILE_NAMEgit log --diff-filter=D --summary | grep FILE_NAME -C 5git log --follow --graph --summary -- FILE_NAME 2.3 检查当前分支内容是否包含了最新的主干内容12git cherry origin/master origin/BRANCH_NAMEgit log origin/master ^origin/BRANCH_NAME –oneline 3 修改历史 版本信息的引用 相对一个版本 比如 HEAD^ 相对N个版本 比如 HEAD@{10} 相对N个版本 比如 HEAD~10 相对N个版本 比如 HEAD@{5}^~5 版本区间 A..B, A不可达&amp;&amp;B可达的的范围，如果是同一条主线上，则是前开后闭区间，否则视情况而定 ^A B 等同于 A..B B —not A 等同于 A..B A…B A可达&amp;&amp;B可达除掉AB都可达的范围，前后闭区间 3.1 修改已经提交的log信息3.1.1 修改上次的log12git commit --amendgit push -f 谨慎谨慎，只有提交了远端仓库才需要这个 3.1.2 合并上几次的log,原来五条123git reset HEAD^^~3 在当前分支回退五个版本的提交历史git commit -m &quot;combined commit&quot; git push -f git push -f 谨慎谨慎，只有提交了远端仓库才需要这个 3.2 修改提交内容的历史 现有的版本A,B,C,D,E 删掉C的提交内容 3.2.1 使用revert1git revert C 简单，但会增加一次提交，而且C原来的提交也会留在历史中 3.2.2 使用rebase1git rebase -i B 删掉想要删掉的C提交，然后保存 3.2.3 使用cherry-pick123git checkout B 先切到D之前的提交git cherry-pick C..E 将后面的提交再拉进来git checkout -b xxx 放入新的分支中 4 参考资料 git docs git docs Pro Git 2nd git community book中文 Git - Tutorial 《Git权威指南》 《版本控制之道-使用Git》 git 相关书籍 github漫游指南 github漫游指南 github秘籍 git工作流指南 github help 怎样使用github github使用指南 github中fork和更新原作者变更","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"开发环境","slug":"开发技术/开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"开发技术/开发环境/Git","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://rawbin-.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"http://rawbin-.github.io/tags/github/"}]},{"title":"使用Beyond Compare作为git diff merge 工具","slug":"dev-env/2016-01-07-git-beyondcompare","date":"2021-12-31T02:37:59.914Z","updated":"2021-12-31T02:37:59.914Z","comments":true,"path":"dev-env/2016-01-07-git-beyondcompare/","link":"","permalink":"http://rawbin-.github.io/dev-env/2016-01-07-git-beyondcompare/","excerpt":"","text":"1 直接修改.gitconfig 一般修改全局路径下的1.1 Windows下配置[diff] tool = bc [difftool &quot;bc&quot;] path = C:\\\\Program Files\\\\Beyond Compare 4\\\\BCompare.exe [merge] tool = bc [mergetool &quot;bc&quot;] path = C:\\\\Program Files\\\\Beyond Compare 4\\\\BCompare.exe 1.2 Mac下配置要生效的话需要在beyond compare 菜单中，选择 install command line tool 安装可在命令行调用的可执行文件 12345678910[diff] tool = bc[difftool] prompt = false[difftool &quot;bc&quot;] path = /usr/local/bin/bcomp[merge] tool = bc[mergetool &quot;bc&quot;] path = /usr/local/bin/bcomp Using Beyond Compare with Version Control SystemsGit下使用Beyond Compare作为比较和合并工具","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://rawbin-.github.io/tags/git/"},{"name":"diff","slug":"diff","permalink":"http://rawbin-.github.io/tags/diff/"},{"name":"merge","slug":"merge","permalink":"http://rawbin-.github.io/tags/merge/"},{"name":"beyondcompare","slug":"beyondcompare","permalink":"http://rawbin-.github.io/tags/beyondcompare/"}]},{"title":"jekyll 3.1.2 导致的github pages 静态资源无效","slug":"knowledge-management/2016-01-10-jekyll-error-github-pages","date":"2021-12-31T02:37:59.914Z","updated":"2021-12-31T02:37:59.914Z","comments":true,"path":"knowledge-management/2016-01-10-jekyll-error-github-pages/","link":"","permalink":"http://rawbin-.github.io/knowledge-management/2016-01-10-jekyll-error-github-pages/","excerpt":"","text":"1 问题 原来好好的github上的博客，打开样式乱了，静态资源找不到 404了 查看页面源代码，发现缺少了主题字段的路径 2 解决 github目录搜索了一下 “assets/themes” 这个关键字 原有的配置文件中默认添加主题名称的，但这里明星没有添加 原来的配置文件 # By default, the asset_path is automatically defined relative to BASE_PATH plus the enabled theme. # ex: [BASE_PATH]/assets/themes/[THEME-NAME] # # Override this by defining an absolute path to assets here. # ex: # http://s3.amazonaws.com/yoursite/themes/watermelon # /assets # ASSET_PATH : false 修改后的配置文件 # By default, the asset_path is automatically defined relative to BASE_PATH plus the enabled theme. # ex: [BASE_PATH]/assets/themes/[THEME-NAME] # # Override this by defining an absolute path to assets here. # ex: # http://s3.amazonaws.com/yoursite/themes/watermelon # /assets # ASSET_PATH : /assets/themes/bootstrap3 上传后就ok了 3 参考资料 升级 Jekyll 3 之前你一定要注意的一件事情 Github page使用jekyll 3.0 以后导致的问题","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://rawbin-.github.io/tags/javascript/"},{"name":"fekit","slug":"fekit","permalink":"http://rawbin-.github.io/tags/fekit/"},{"name":"node-inspector","slug":"node-inspector","permalink":"http://rawbin-.github.io/tags/node-inspector/"}]},{"title":"JavaScript 文件上传 change 触发问题","slug":"dev-app/javascript/2015-09-15-input-file-change","date":"2021-12-31T02:37:59.914Z","updated":"2021-12-31T02:37:59.914Z","comments":true,"path":"dev-app/javascript/2015-09-15-input-file-change/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2015-09-15-input-file-change/","excerpt":"","text":"1 问题来源使用input type=“file”做文件上传，选择文件后自动上传，绑定input的change事件。 在相邻两次选择同一个文件时，不会触发change事件，原因是两次的值没有发生变化。 2 解决办法在选择文件的时候，清空原来的值，每次自动触发change事件。 在标准浏览器中可以直接通过value=’’来直接重置input type=”file”的值，但在IE中无法实现。 于是通过Form自带的reset方法来实现。代码如下： ​&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;/head&gt; &lt;form id=&quot;test-form&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;file-test&quot;&gt; &lt;/form&gt; &lt;body&gt; &lt;script&gt; var form = document.getElementById(&#39;test-form&#39;); var el = document.getElementById(&quot;file-test&quot;); var changeFunc = function()&#123; console.log(&quot;change event&quot;); &#125; var clickFunc = function()&#123; console.log(&#39;click event&#39;); //el.value = &#39;&#39;; form.reset(); &#125; var propertychangeFunc = function()&#123; console.log(&#39;property change event&#39;) &#125; if(window.addEventListener)&#123; el.addEventListener(&#39;change&#39;,changeFunc); el.addEventListener(&#39;click&#39;,clickFunc); el.addEventListener(&#39;propertychange&#39;,propertychangeFunc); &#125;else&#123; el.attachEvent(&#39;onchange&#39;,changeFunc) el.attachEvent(&#39;onclick&#39;,clickFunc) el.attachEvent(&#39;onpropertychange&#39;,propertychangeFunc) &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"input","slug":"input","permalink":"http://rawbin-.github.io/tags/input/"},{"name":"file","slug":"file","permalink":"http://rawbin-.github.io/tags/file/"},{"name":"change","slug":"change","permalink":"http://rawbin-.github.io/tags/change/"}]},{"title":"fekit 带中文文件的目录 页面内容渲染不全","slug":"dev-tools/fekit/2016-01-05-fekit-page-content","date":"2021-12-31T02:37:59.914Z","updated":"2021-12-31T02:37:59.914Z","comments":true,"path":"dev-tools/fekit/2016-01-05-fekit-page-content/","link":"","permalink":"http://rawbin-.github.io/dev-tools/fekit/2016-01-05-fekit-page-content/","excerpt":"","text":"1 问题 随便一个目录，用fekit 起一个server 浏览器打开目录 在这个目录中添加一个中文文件 刷新刚打开的目录页面 某些目录或者文件未被渲染出来 2 排查fekit 使用了connect框架来做静态资源的server connect目录在$FEKIT_HOME\\node-modules\\connect\\中 查看connect框架中处理静态目录的处理：$FEKIT_HOME\\node-modules\\connect\\lib\\middleware\\directory.js， 其中静态处理的代码如下: exports.html = function(req, res, files, next, dir, showUp, icons)&#123; fs.readFile(__dirname + &#39;/../public/directory.html&#39;, &#39;utf8&#39;, function(err, str)&#123; if (err) return next(err); fs.readFile(__dirname + &#39;/../public/style.css&#39;, &#39;utf8&#39;, function(err, style)&#123; if (err) return next(err); if (showUp) files.unshift(&#39;..&#39;); str = str .replace(&#39;&#123;style&#125;&#39;, style) .replace(&#39;&#123;files&#125;&#39;, html(files, dir, icons)) .replace(&#39;&#123;directory&#125;&#39;, dir) .replace(&#39;&#123;linked-path&#125;&#39;, htmlPath(dir)); res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;); //res.setHeader(&#39;Content-Length&#39;, str.length); res.setHeader(&#39;Content-Length&#39;, new Buffer(str,&#39;utf-8&#39;).length); res.end(str); &#125;); &#125;); &#125;; 基本流程是读取一个静态模板，然后填充相应的内容。如果文件名存在中文，在计算相应长度的时候会存在问题（算少了），所以会出现页面看不到某些靠后的内容一样。 原因是编码不一样，计算结果不一致，参考","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://rawbin-.github.io/tags/javascript/"},{"name":"fekit","slug":"fekit","permalink":"http://rawbin-.github.io/tags/fekit/"},{"name":"node-inspector","slug":"node-inspector","permalink":"http://rawbin-.github.io/tags/node-inspector/"}]},{"title":"使用node-inspector 调试fekit 解决渲染velocity JS语法错误","slug":"dev-tools/fekit/2016-01-05-fekit-velocity","date":"2021-12-31T02:37:59.914Z","updated":"2021-12-31T02:37:59.914Z","comments":true,"path":"dev-tools/fekit/2016-01-05-fekit-velocity/","link":"","permalink":"http://rawbin-.github.io/dev-tools/fekit/2016-01-05-fekit-velocity/","excerpt":"","text":"1 fekit velocity 渲染结果不理想fekit 渲染velocity 在低版本使用的是velocityjs，从2015年8月中下旬开始的版本开始也使用velocity.java 同时支持低版本的velocity的渲染，在启动的时候启动使用--without-java或-w参数即可。 但同样的问题，本地mock vm拍的数据的时候，如果是复合类型的数据，都会有问题 使用velocity.java 的结果 dataList value [&#123;name=zhang, email=zhang@test.com&#125;, &#123;name=wang, email=wang@test.com&#125;] dataMap value &#123;key=key, value=value&#125; &lt;script type=&quot;text/javascript&quot;&gt; var dataList = [&#123;name=zhang, email=zhang@test.com&#125;, &#123;name=wang, email=wang@test.com&#125;]; var dataMap = &#123;key=key, value=value&#125;; &lt;/script&gt; 使用velocityjs 的结果： dataList value [object Object],[object Object] dataMap value [object Object] &lt;script type=&quot;text/javascript&quot;&gt; var dataList = [object Object],[object Object]; var dataMap = [object Object]; &lt;/script&gt; 对于VM来说，可能是数据渲染本身写的有问题，对于JS代码来的，就是语法错误。 我们想要的是这个样子的： dataList value [&#123;&quot;name&quot;:&quot;zhang&quot;,&quot;email&quot;:&quot;zhang@test.com&quot;&#125;,&#123;&quot;name&quot;:&quot;wang&quot;,&quot;email&quot;:&quot;wang@test.com&quot;&#125;] dataMap value &#123;&quot;key&quot;:&quot;key&quot;,&quot;value&quot;:&quot;value&quot;&#125; &lt;script type=&quot;text/javascript&quot;&gt; var dataList = [&#123;&quot;name&quot;:&quot;zhang&quot;,&quot;email&quot;:&quot;zhang@test.com&quot;&#125;,&#123;&quot;name&quot;:&quot;wang&quot;,&quot;email&quot;:&quot;wang@test.com&quot;&#125;]; var dataMap = &#123;&quot;key&quot;:&quot;key&quot;,&quot;value&quot;:&quot;value&quot;&#125;; &lt;/script&gt; 看起来很好改的样子，尤其是对于js来说。 2 使用node-inspector调试fekit 进程2.1 安装 安装node-inspector: npm install node-inspector -g 启动简单的启动方法： 第一个命令行窗口执行 node-inspector 第二个命令行窗口执行 node-debug cmd params (这里会自动打开浏览器并定位到相同地址) 2.1.1 完整的启动 启动node-inspector 监听进程: node-inspector 这里会输出调试地址 类似于 http://127.0.0.1:8080/?port=5858 启动node-inspector 监听的fekit进程 node --debug-brk &quot;C:\\Users\\liao.zhang\\AppData\\Roaming\\nvm\\v4.3.0\\node_modules\\fekit\\bin\\fekit&quot; server 这样会在服务器还没启动时断点在fekit 脚本中 浏览器打开调试地址 2.1.2 调试 切换到刚打开的调试地址 闭上眼睛，默念30遍“一定能出来”，然后等啊等啊等。。。心诚则灵，第一次总不是那么容易~ 不用打开F12，整个页面就是一个F12 执行现有代码让服务器启动起来 浏览器刷新要调试的页面 http://zhangliao.qunar.com/tests/fekit-vm/test.vm 打响应位置的断点，比如我们要调试的velocity.js中的某处 下次刷新要调试页面就可到断点处 3 修改相应的源代码3.1 修改velocityjs代码路径在 $FEKIT_HOME\\node-modules\\velocityjs 经过翻看源代码和上面的调试，我们可以定位到渲染的代码在$FEKIT_HOME\\node-modules\\velocityjs\\src\\compile\\compile.js中：对compile.js中_render方法作如下更改，将JSON序列化的结果进行渲染而不是默认的toString： utils.forEach(asts, function(ast)&#123; var tmpValue; switch(ast.type) &#123; case &#39;references&#39;: //str += this.getReferences(ast, true); tmpValue = this.getReferences(ast, true); try&#123; if(typeof tmpValue === &#39;object&#39;)&#123; str += JSON.stringify(tmpValue); &#125;else&#123; str += tmpValue; &#125; &#125;catch(e)&#123; str += tmpValue; &#125; break; 至此，我们就可以使用fekit server -w的情况下，将数据以JSON序列化的方式渲染到页面。 3.2 修改velocity.java代码路径在 $FEKIT_HOME\\node-modules\\velocity.java 经过调试我们可以看出，这里面的渲染是通过内部的一个httpserver来做的，启动了一个执行了一个jar包的进程，来处理渲染并返回流数据。 jar包路径是$FEKIT_HOME\\node-modules\\velocity.java\\bin\\velocity-cli.jar其实就是一个压缩包。 使用压缩软件解压出来，可以看到一些响应的编译过的资源文件（字节码）。 从META-INF\\MANIFEST.MF中可以看到主类是VelocityCli,当然这里也可以直接从源码中轻易看出来，就两个文件，带main方法那个肯定是主类。 下面开始搞： 搞一个Java工程，把velocity.java中的两个java文件拷出来，放入源码中 先下载zip包解压出来的相关jar包，jackson系列，velocity，velocity-tool的下载下来 把我们的测试vm也拷贝到src目录中来 配置环境，让VelocityCli.java能够正确的运行起来 写一点劫持数据的代码进行断点调试： import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ObjectNode; import java.io.IOException; /** * Created by liao.zhang on 2016/2/21. */ public class test &#123; public static void main(String[] args) throws Exception &#123; String data = &quot;&#123;\\&quot;dataList\\&quot;:[&#123;\\&quot;name\\&quot;:\\&quot;zhang\\&quot;,\\&quot;email\\&quot;:\\&quot;zhang@test.com\\&quot;&#125;,&#123;\\&quot;name\\&quot;:\\&quot;wang\\&quot;,\\&quot;email\\&quot;:\\&quot;wang@test.com\\&quot;&#125;],\\&quot;dataMap\\&quot;:&#123;\\&quot;key\\&quot;:\\&quot;key\\&quot;,\\&quot;value\\&quot;:\\&quot;value\\&quot;&#125;,\\&quot;velocity.java.filename\\&quot;:\\&quot;src\\\\\\\\test.vm\\&quot;&#125;&quot;; String json = new String(data.getBytes(), &quot;UTF-8&quot;); ObjectMapper mapper = new ObjectMapper(); ObjectNode node = (ObjectNode)mapper.readTree(json); String res = VelocityCli.render(node); System.out.println(res); &#125; &#125; 可以发现是在 org.apache.velocity.runtime.parser.node.ASTReference的render方法中，直接调用了Object.toString所致，跟js的一样 value = EventHandlerUtil.referenceInsert(this.rsvc, context, this.literal(), value); String toString = null; if(value != null) &#123; toString = value.toString(); &#125; if(value != null &amp;&amp; toString != null) &#123; if(context.getAllowRendering()) &#123; writer.write(this.escPrefix); writer.write(this.morePrefix); writer.write(toString); &#125; 不改了 要改的话，下载一份velocity源代码，把这一部分改成JSON渲染的字符串， 然后编译，把对应的字节码替换到jar包相应位置即可。 参考资料 Node.js 调试指南","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://rawbin-.github.io/tags/javascript/"},{"name":"fekit","slug":"fekit","permalink":"http://rawbin-.github.io/tags/fekit/"},{"name":"node-inspector","slug":"node-inspector","permalink":"http://rawbin-.github.io/tags/node-inspector/"},{"name":"velocity","slug":"velocity","permalink":"http://rawbin-.github.io/tags/velocity/"}]},{"title":"fekit 性能优化 ","slug":"dev-tools/fekit/2016-01-11-fekit-performance","date":"2021-12-31T02:37:59.914Z","updated":"2021-12-31T02:37:59.915Z","comments":true,"path":"dev-tools/fekit/2016-01-11-fekit-performance/","link":"","permalink":"http://rawbin-.github.io/dev-tools/fekit/2016-01-11-fekit-performance/","excerpt":"","text":"1 重要的写前面1.1 解决办法修改$FEKIT_HOME/lib/util.js,性能能提升N倍。 exists: function(path) &#123; //return _fileExistsWithCaseSync(path); if (fs.existsSync) &#123; return fs.existsSync(path); &#125; if (syspath.existsSync) &#123; return syspath.existsSync(path); &#125; &#125; 1.2 效果pack、min 过程减少N分钟 1.3 原因分析说实话没看懂到底要干啥，github上抠代码，发现 是2014年12月份提交的， 当时的提交日志是“开发时require区分大小写”。 发布时间是v0.2.88之后 0.2.99之前 看完又是懵逼了，代码里面没有看到大小写，整个工程中也就这一个文件用到了这个方法。 技术原因倒也简单，递归的效率太低（指数增长），这里一次能搞定的东东，搞了很多次，自然慢了。 找一个工程 打印exists调用次数 618958,写一段代码测试下 1000次执行的差异，可以看出这个工程可以提升近十分钟： ################ 修改后: 50 ################ 修改前N级目录: 607 ################ 修改前N+2级目录: 785 ################ 修改前N+4级目录: 976 代码如下： var fs = require(&quot;fs&quot;); var syspath = require(&#39;path&#39;); var _fileExistsWithCaseSync = function (filepath) &#123; //console.log(&quot;pid:&quot;, process.pid, &#39;--&#39;, filepath, + new Date()) var dir, filenames; if (!fs.existsSync(filepath)) &#123; return false; &#125; dir = syspath.dirname(filepath); if (dir === &#39;/&#39; || dir === &#39;.&#39; || (/^\\w:\\\\$/.test(dir))) &#123; //console.log(&quot;pid:&quot;, process.pid, &#39;--&#39;, filepath, + new Date()) return true; &#125; filenames = fs.readdirSync(dir); if (filenames.indexOf(syspath.basename(filepath)) === -1) &#123; return false; &#125; return _fileExistsWithCaseSync(dir); &#125;; var exists = function (path) &#123; // return _fileExistsWithCaseSync(path); //console.log(&quot;pid:&quot;, process.pid, &#39;--&#39;, path, + new Date()) if (fs.existsSync) &#123; //console.log(&quot;pid:&quot;, process.pid, &#39;--&#39;, path, + new Date()) return fs.existsSync(path); &#125; if (syspath.existsSync) &#123; //console.log(&quot;pid:&quot;, process.pid, &#39;--&#39;, path, + new Date()) return syspath.existsSync(path); &#125; &#125; var counter = 1000; console.log(&quot;################&quot;) var startTime = new Date(); for(var i = 0;i &lt; counter;i++)&#123; exists(&quot;D:/OpenSource/fekit/lib/commands/pack.js&quot;) &#125; console.log(&quot;修改后:&quot;,new Date() - startTime); console.log(&quot;################&quot;) startTime = new Date(); for(var i = 0; i &lt; counter; i++)&#123; _fileExistsWithCaseSync(&quot;D:/OpenSource/fekit/lib/commands/pack.js&quot;) &#125; console.log(&quot;修改前N级目录:&quot;,new Date() - startTime); console.log(&quot;################&quot;) startTime = new Date(); for(var i = 0; i &lt; counter; i++)&#123; _fileExistsWithCaseSync(&quot;D:/OpenSource/fekit/lib/commands/test/longer/pack.js&quot;) &#125; console.log(&quot;修改前N+2级目录:&quot;,new Date() - startTime); console.log(&quot;################&quot;) startTime = new Date(); for(var i = 0; i &lt; counter; i++)&#123; _fileExistsWithCaseSync(&quot;D:/OpenSource/fekit/lib/commands/test/longer/test/longer/pack.js&quot;) &#125; console.log(&quot;修改前N+4级目录:&quot;,new Date() - startTime); 2 问题由来一开始一直使用的fekit 的一个比较老旧的版本，&#102;&#x65;&#107;&#x69;&#x74;&#64;&#x30;&#46;&#x32;&#46;&#x38;&#53;；后来需要做一段touch开发，工程需要支持sass，于是升级了fekit至最新版。 也就是噩梦的开始，期间换个多个版本，效果都是一样。一个字，太慢了。刷一个页面要而二三十秒。 也尝试过去解决，希望可以找到一个临界版本，然后进行目录比较得到结果。事情没有能够顺利的进行，因为中间有好多版本没法使用（在windows上），所以根本没法这样获得结果。 也跟维护者进行过咨询和讨论，也没有得到一个较好的解决办法。 于是使用fekit 的-b -c 各种参数来进行性能提升，慢慢的强迫症有些消退，也适应了这种老牛拉破车的节奏。 3 转折点然而，虽然我个人慢慢的适应了这个状态，但心里始终有个心结。后来其他部门的小伙伴，其他职位的小伙伴也慢慢的反映出此问题来了。 当邮件组再次出现这样的问题的时候，我也没有像一开始那么激动地要上去煽一把火，期待火大点总能燃起来。 只是默默的想着，我要有点时间，必搞搞此问题。 恰好来了个周末。 4 问题解决过程4.1 搭环境 使用nvm搞了两个node 环境，每一个node装一个fekit，一个最新版，一个0.2.85 用同一个项目（自然是同一台机子），进行对比测试（还是老样子） 然后是打log，尝试了node-inspector, 报错 对比fekit pack，fekit min同理 4.2 代码对比分析 差异太大 0.2.85是单进程，最新版是多进程 各种模块有差异 先改了改安装后的源代码，嵌入了一段代码，记录所有打包文件耗时的top5 然后根据这个top5 分析代码特征 发现都是一大片的require 于是查看fekit 的CHANGE LOG，发现跟require相关的差异比较大的sass模块，替换上，没多大影响 于是就懵逼了 4.3 目录对比，还是目录对比 前面说到了，分析不下去了 到这个份上了，只能硬比，硬不起来也要比 生物学实验的氛围立马营造了起来 0.2.85是单进程，最新版是多进程，首先把多进程搞成单进程 尽量把最新版的模块都替换成参照物的0.2.85的模块 然后是各种匹配，替换，各种失败 不说了，都是泪 看着看着发现某些代码差异比较大，看起来还io，满以为到头了，结果还是。。。 大块的都搞完了，开始搞小块的了，代码已经被替换的不堪入目了 然后是一个判断环境的一些，直接return一个值，没啥鸟用 最后到了判断路径存在的，居然还是一个递归。。。。，替换到这儿，撞上了。 4.4 全是代码4.4.1 一个记录TopN的小工具topNManager = &#123; n:5, maxN:[], infoMap:&#123;&#125;, raceTop:function(timeDelta,path)&#123; var self = this; if(self.maxN.length &lt; self.n)&#123; self.maxN.push(timeDelta); self.infoMap[timeDelta] = path; &#125;else&#123; var min = Math.min.apply(null,self.maxN); if(min &lt; timeDelta)&#123; self.maxN.splice(self.maxN.indexOf(min),1,timeDelta); self.infoMap[timeDelta] = path; &#125; &#125; &#125;, print:function()&#123; var self = this; utils.logger.log(&quot;耗时Top&quot;,self.n); self.maxN.sort(function(a,b)&#123;return b - a&#125;) self.maxN.forEach(function(value,index)&#123; utils.logger.log(&quot;耗时&quot;,value,&quot;, 路径:&quot;,self.infoMap[value]); &#125;) &#125; &#125; 4.4.2 瓶颈点的代码exists: function(path) &#123; //return _fileExistsWithCaseSync(path); if (fs.existsSync) &#123; return fs.existsSync(path); &#125; if (syspath.existsSync) &#123; return syspath.existsSync(path); &#125; &#125;, _fileExistsWithCaseSync = function(filepath) &#123; console.log(&quot;pid:&quot;,process.pid,&#39;--&#39;,filepath, + new Date()) var dir, filenames; if (!fs.existsSync(filepath)) &#123; return false; &#125; dir = syspath.dirname(filepath); if (dir === &#39;/&#39; || dir === &#39;.&#39; || (/^\\w:\\\\$/.test(dir))) &#123; return true; &#125; filenames = fs.readdirSync(dir); if (filenames.indexOf(syspath.basename(filepath)) === -1) &#123; return false; &#125; return _fileExistsWithCaseSync(dir); &#125;; 说实话没看懂到底要干啥。 4.5 原因分析说实话没看懂到底要干啥，github上抠代码，发现当时的提交日志是“开发时require区分大小写”。 看完又是懵逼了，代码里面没有看到大小写，整个工程中也就这一个文件用到了这个方法。 技术原因倒也简单，同步递归的效率太低，目录层级成了递归深度，同步递归的时候，这里用了多进程，CPU会都占满掉，然后会不断激活失活，其他进程时间片很少，机子也会出现卡死的状态。 ​​​​","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"应用技术","slug":"前端开发/应用技术","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"开发环境","slug":"前端开发/应用技术/开发环境","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"fekit","slug":"fekit","permalink":"http://rawbin-.github.io/tags/fekit/"},{"name":"前端工程","slug":"前端工程","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"}]},{"title":"JavaScript面向对象编程小结","slug":"architecture/2015-09-12-javascript-oop","date":"2021-12-31T02:37:59.913Z","updated":"2021-12-31T02:37:59.913Z","comments":true,"path":"architecture/2015-09-12-javascript-oop/","link":"","permalink":"http://rawbin-.github.io/architecture/2015-09-12-javascript-oop/","excerpt":"","text":"[TOC] 1 一些必要的前提1.1 面向过程在计算机发展的早期阶段，所有的与计算机相关的操作都是以计算机为中心的（迁就计算机），比如穿孔纸带记录信息，机器码编程，汇编语言编程等。 受早期计算机文化的影响，后来的很多编程语言的设计和实现、以及相关的软件开发过程都与以计算机为中心有关。比如大名鼎鼎的C语言，结构化的设计和编码。 1.2 面向对象 以人为本 我们擅长于对现实世界的事物进行抽象归类，比如好人坏人，男人女人，高富帅，白富美等，也能很容易的道出各种对象的属性和操作，比如有钱、有权、有地位，比如开豪车，泡美眉等。 代码复用 通过分析归纳，根据业务将类型及其关系抽象出来，通过继承的方式复用代码，减少冗余。 1.3 区别和联系 不同的侧重点，面相过程侧重于过程，面向对象侧重于对象（废话，顾名思义） 不同视角的思维方式，面向过程以执行流程为导向，面向对象以对象交互为导向。 不同的抽象程度，面向过程着眼于具体流程，抽象程度低；面向对象可以更高级别的抽象。 总是同时出现，面向对象的操作就是一个个的过程，面向过程的作用目标就是对象。 一个例子,参考： 面向对象： 狗.吃(屎) 面向过程： 吃.(狗,屎) 看完了你好像知道该怎么选了，^_^。狗，屎都是对象，吃是一个过程，二者是难舍难分啊，所以面向对象和面向过程是无法一刀切开的。 面向过程更关注吃这个过程（狗和屎都是依赖），面向对象更关注狗这个对象，吃只是操作，屎是操作的数据。 2 JavaScript 面向对象编程2.1 原型（prototype）JavaScript通过原型属性来实现继承，几个概念揉在了一起，咱们撕开来看看： 函数原型 FuncObj.prototype 对象函数对象（一切皆是对象，函数也不例外）的原型对象（是一个对象，一个对象） 对象原型 obj.proto 对象对象引用的构造器提供的原型，在ECMAScript规范中使用[[Prototype]]内部属性来表达，在IE中不知道是什么，在W3C浏览器中使用__proto__属性来表达，可直接访问。在ECMAScript5之前是非标准属性，在ECMAScript2015（ES6）中__proto__被标准化为一个对象的原型属性。 函数prototype 属性 对象内部[[Prototype]]属性 以上都叫原型 2.2 继承和重写 继承就是要复用现有的代码 可以通过原型的方式实现共享 可以通过浅拷贝的方式进行共享 通过深拷贝的方式实现重写 有了上面这几条就可以变出各种姿势，如jQuery的深浅拷贝，ExtJS的原型继承+浅拷贝等 2.3 原型继承JavaScript特有的原型继承，就是基于上面的原型。 使用过程如下： 定义一个带原型的构造函数 function Person(config) &#123; config = config || &#123;&#125;; this.name = config.name || &#39;defaultName&#39;; &#125; Person.prototype = &#123; say: function () &#123; console.log(this.name, &#39;say something&#39;) &#125; &#125; 通过new Person 生成对象 var jim = new Person(&#123; name:&#39;jim&#39; &#125;); jim.say(); var john = new Person(&#123; name:&#39;john&#39; &#125;); john.say(); jim 和 john这两个对象共享了Person.prototype对象中的say（内存中就一份） new Person的执行过程 创建一个空对象,并把this执行这个对象 将对象的[[Prototype]]属性(proto)设置为Person.prototype 然后执行Person构造函数中的代码 等价的代码： 一种姿势 var jim = new Person(&#123; name: &#39;jim&#39; &#125;) 另一种姿势 var jim = &#123;&#125;; Person.call(jim,&#123; name:&#39;jim&#39; &#125;) 执行的查找过程 var john = new Person(&#123; name:&#39;john&#39; &#125;); john.say(); 调用john.say()时，编译器先查找john本身是否有say这个属性，发现没有；于是查找john.__proto__这个对象里面是否包含say这个属性，结果找到了就做一些检测，比如说是不是函数啊等，然后执行得到结果。 当然调用的this始终是当前的对象。上面的查找过程，就是愚公移山的过程，子又生孙，孙又生子。。。。 2.4 多级继承2.4.1 一个多级继承的实例function Man(config)&#123; this.sex = &#39;man&#39; Person.call(this,config); &#125; Man.prototype = Person.prototype; function Woman(config)&#123; this.sex = &#39;woman&#39; Person.call(this,config) &#125; Woman.prototype = Person.prototype; var man = new Man(&#123; name:&#39;testMan&#39; &#125;); var woman = new Woman(&#123; name:&#39;testWoman&#39; &#125;); man.say(); woman.say(); 2.4.2 需要修改的原型对象如果我们需要修改Man和Women的原型对象，分别加入Man和Women各自特有的属性和方法，那么上面的代码就不太适用，有如下问题： 修改Man或Woman的原型都影响到了Woman或Man的原型 修改Women和Man的原型影响到了Person的原型 上面两句都是废话，因为他们三个引用的是同一个对象 可以用如下方法解决： Man.prototype = new Person(); Woman.prototype = new Person(); 但这样之后： 在查找say方法的过程中多了一次查找到person对象的过程，然后才找到Person.prototype,原型链多了一个层级 在man 或woman对象中有一个name属性，在person中还有一个多余的name属性 我们可以直接用一个空函数来代替作为衔接的构造函数Person,但Person构造函数还会被借用（作为基类构造函数），不能直接干掉。​ function TmpConstructor(){} TmpConstructor.prototype = Person.prototype; Man.prototype = new TmpConstructor(); Woman.prototype = new TmpConstructor(); 这样就解决了冗余熟悉的问题，但多一层原型链，在需要修改原型的需求中不能被干掉，干掉就回到上一步了，满足不了需求。 2.4.3 需要重写的原型属性如果是完全重写的属性或方法，直接在子类的原型中修改就行，这样就会在原型链查找的过程中出现短路的效果，从而无视原型中的同名属性。 但如果只是想在原来的基础上做一些小的改动，增加特殊的操作，完全重写一遍总不是我们想要的，JavaScript没有提供直接访问父类的原型的途径（ES6中可以使用__proto__）还是方法借用，一个简单的方式是直接使用父类原型来访问。这个跟其他像Java这样的面向对象语言的super关键字不一样，只是单纯的方法借用，跟继承关系没有关联。 function Person(config) &#123; config = config || &#123;&#125;; this.name = config.name || &#39;defaultName&#39;; &#125; Person.prototype = &#123; say: function () &#123; console.log(this.name, &#39;say something&#39;) &#125; &#125; function Man(config)&#123; this.sex = &#39;man&#39; Person.call(this,config); &#125; function Woman(config)&#123; this.sex = &#39;woman&#39; Person.call(this,config) &#125; function TmpConstructor()&#123;&#125; TmpConstructor.prototype = Person.prototype; Man.prototype = new TmpConstructor(); Man.prototype.say = function()&#123; console.log(&#39;a man:&#39;) TmpConstructor.prototype.say.call(this); &#125; Woman.prototype = new TmpConstructor(); Woman.prototype.say = function()&#123; console.log(&#39;a woman:&#39;) TmpConstructor.prototype.say.call(this); &#125; var man = new Man(&#123; name:&#39;testMan&#39; &#125;); var woman = new Woman(&#123; name:&#39;testWoman&#39; &#125;); man.say(); woman.say(); 2.5 无招胜有招JavaScript的面向对象实现方式有些局限性，对面向对象的支持还在不断的完善，ES6中会直接提供相关的语法支持。 然而对信息隐藏的支持还是有限，比如想提供一个私有变量，直接读取： function Person(config)&#123; config = config || &#123;&#125;; var secret = config.secret || &#39;mysecret&#39;; this.getSecret = function()&#123; return secret; &#125; &#125; 这样secret作为一个私有变量，只能通过getSecret方法来访问，但这个访问方法每个对象会保存一份。​当然我们的目标是封装和代码复用，有了上面的道道，要用什么姿势，随你~ 3 参考资料 JavaScript面向对象编程 JavaScript prototype 原型 继承 理解","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"面向过程","slug":"面向过程","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"}]},{"title":"一个轻量级的通用表单值存取方案","slug":"dev-app/2015-09-12-lightweight-form-accessor","date":"2021-12-31T02:37:59.913Z","updated":"2021-12-31T02:37:59.913Z","comments":true,"path":"dev-app/2015-09-12-lightweight-form-accessor/","link":"","permalink":"http://rawbin-.github.io/dev-app/2015-09-12-lightweight-form-accessor/","excerpt":"","text":"1 由来一个数据list，展示数据概要，然后通过点击编辑弹层展示数据详情的表单，是web开发中一个很常见的交互场景。 在这个场景中，涉及到整个表单值的存和整个表单值的取，当然这只是一个聚合结果，更细一步说，其实就是每个表单元素的值的存取。 2 实现方式2.1 基本类结构于是我们可以定义如下一个类： function BaseFormDataAccessor(config)&#123; this.init(config) &#125; BaseFormDataAccessor.prototype = &#123; init:function(config)&#123; // &#125;, getData:function()&#123; return &#123;&#125; &#125;, setData:function(data)&#123; // &#125;, getElementData:function(el)&#123; return &#123;&#125; &#125;, setElementData:function(el,data)&#123; // &#125; &#125; 这就是一个大体的结构。 在此基础上，我们只需要在具体的form实现类中，继承这个基类，传入响应的表单配置，就实现了一个表单值的存取。 2.2 实现类一个实现类的代码： function UserInfoForm(container,config) &#123; this.elsConfig = config.elsConfig || []; BaseFormDataClass.call(this, container); &#125; UserInfoForm.prototype = new BaseFormDataClass(); 2.3 类的使用一个使用类的代码： var userInfoForm = new UserInfoForm(&#39;.js-user-info-container&#39;，&#123; elsConfig: [&#123; dataKey: &#39;loginname&#39;, //提供给后台的数据key，不用写数据适配了，直接改这儿就行 selector: &#39;.js-login-name&#39; //表单不用写name了，直接配一个当前container内唯一选择器就行 &#125;, &#123; dataKey: &#39;nickname&#39;, selector: &#39;.js-nick-name&#39; &#125;, &#123; dataKey: &#39;portrait&#39;, selector: &#39;.js-portrait-container&#39;, //简单数据处理什么都不需要配置， dataGetter:function()&#123; //可以根据需要灵活自定义数据处理方式 var $container = this.$el; return $container.children(&#39;img&#39;).attr(&#39;src&#39;); &#125;, dataSetter:function(imgUrl)&#123; var $container = this.$el; var $img = $container.children(&#39;img&#39;); if($img.length === 0)&#123; $container.html(&#39;&lt;img src=&quot;&#39; + imgUrl +&#39;&quot;&gt;&#39;); &#125;else&#123; $img.attr(&#39;src&#39;) = imgUrl; &#125; &#125; &#125;] &#125;); 2.4 基类基类代码如下： function BaseFormDataAccessor(container)&#123; if(container)&#123; this.init(container); &#125; &#125; BaseFormDataAccessor.prototype = &#123; elsConfig:[], keysMap:&#123;&#125;, init:function(container)&#123; if (container) &#123; this.$container = $(container); &#125; if (!this.$container) &#123; return; &#125; else &#123; var cfgList = this.elsConfig; var keysMap = this.keysMap || &#123;&#125;; var tmpConfig; for(var i = cfgList.length; i--;)&#123; tmpConfig = cfgList[i]; keysMap[tmpConfig.dataKey] = tmpConfig; tmpConfig[&#39;$el&#39;] = $(tmpConfig.selector); &#125; &#125; &#125;, isInitialized: function()&#123; return this.$container &amp;&amp; this.$container.length &gt; 0; &#125;, checkForm:function()&#123; if (!this.isInitialized()) &#123; throw new Error(&#39;请先初始化表单上下文&#39;); &#125; &#125;, getData:function(keyList,targetKeyList)&#123; this.checkForm(); keyList = keyList || Object.keys(this.keysMap); var formData = &#123;&#125;; var key,targetKey; if(!targetKeyList)&#123; for (var i = keyList.length; i--;) &#123; key = keyList[i]; formData[key] = this.getElementData(this.keysMap[key]); &#125; &#125;else&#123; for (var i = keyList.length; i--;) &#123; key = keyList[i]; targetKey = targetKeyList[i]; formData[targetKey] = this.getElementData(this.keysMap[key]); &#125; &#125; return formData; &#125;, setData: function (data, isFull) &#123; this.checkForm(); var key; var keyList = isFull?Object.keys(this.keysMap): Object.keys(data); for (var i = keyList.length; i--;) &#123; key = keyList[i]; if(key in this.keysMap)&#123; this.setElementData(this.keysMap[key],data[key]); &#125;else&#123; //throw new Error(&#39;指定的配置不存在&#39;) //pass &#125; &#125; &#125;, getElementData:function(config)&#123; if(config.dataGetter &amp;&amp; $.isFunction(config.dataGetter))&#123; return config.dataGetter.call(config); &#125;else&#123; return config.$el.val() &#125; &#125;, setElementData:function(config,value)&#123; value = this.serializeValue(value); if(config.dataSetter &amp;&amp; $.isFunction(config.dataSetter))&#123; config.dataSetter.call(config,value); &#125;else&#123; config.$el.val(value); &#125; &#125;, serializeValue:function(value)&#123; if(!value)&#123; return &#39;&#39; &#125; if(typeof value === &#39;object&#39;)&#123; try&#123; return JSON.stringify(value) &#125;catch(e)&#123; return value.toString(); &#125; &#125;else if(typeof value === &#39;string&#39; || typeof value === &#39;number&#39;)&#123; return value &#125;else&#123; return &#39;&#39;; &#125; &#125;, getElement:function(key)&#123; var config = this.keysMap[key]; return config?config.$el:null; &#125; &#125;","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"表单值存取","slug":"表单值存取","permalink":"http://rawbin-.github.io/tags/%E8%A1%A8%E5%8D%95%E5%80%BC%E5%AD%98%E5%8F%96/"}]},{"title":"前端模块管理 依赖管理 包管理 工具","slug":"modules/2015-09-10-frontend-module-management","date":"2021-12-31T02:37:59.913Z","updated":"2021-12-31T02:37:59.913Z","comments":true,"path":"modules/2015-09-10-frontend-module-management/","link":"","permalink":"http://rawbin-.github.io/modules/2015-09-10-frontend-module-management/","excerpt":"","text":"1 参考资料 前端模块管理器简介 browserify npm github npm 官网 npm docs package.json字段详解 package.json 中文版 npm的package.json中文文档 淘宝npm镜像","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://rawbin-.github.io/tags/npm/"},{"name":"browserify","slug":"browserify","permalink":"http://rawbin-.github.io/tags/browserify/"}]},{"title":"JavaScript模块化编程小结","slug":"modules/2015-09-12-javascript-modular","date":"2021-12-31T02:37:59.913Z","updated":"2021-12-31T02:37:59.913Z","comments":true,"path":"modules/2015-09-12-javascript-modular/","link":"","permalink":"http://rawbin-.github.io/modules/2015-09-12-javascript-modular/","excerpt":"","text":"1 引子 软件的生命周期跟人的生命周期类似，开发测试阶段只是其中很短的一部分（怀胎十月），而后期的运营维护阶段占据了整个生命周期的绝大部分（人的生长发育到最后down掉的几十年）。 一个比较直观的数据，需求分析和设计占1/5,开发测试占1/5,运营维护占3/5（这个占比可能会比这个大得多，比如一个几个月搞定的项目，可能会使用几年甚至几十年）。 因此，一切工程化手段都希望能够提升软件的可维护性，让运维周期更长，从而降低成本。 模块化概念最先出现在工程设计领域，比较常见的例子就是电脑的各个组成元件，手机的各个元件；在模块化的设计和生产之后，各大厂商可以很方便的进行组装，只需要相应的组件规格匹配就行。 这里就需要一个共同认可的规格文档，说明相应的规范参数，比如CPU的引脚，形状尺寸；内存的金手指数，卡槽位置等。 引申到软件设计上来，模块化的对外规范就是与其他模块的交互入口，可以是接口、信号、事件等传递数据的方式。至于内部使用什么样的逻辑来实现，对外部模块使用者来说其实并不太关注。​ 2 JavaScript模块化2.1 什么是模块？前面大致已经讲到了，模块是一个比较通用的概念，就是一个独立的功能体，与其相似的名词有插件，组件； 2.2 为什么要模块化？这个问题基本上已经回答了，简单列一下： 模块化后的功能代码更加独立，更容易修改和复用 独立的功能更容易组装，提高生产效率 始终都会有的一条，更容易维护 更容易组装生产、快速响应变化、缩短研发周期 2.3 怎么样做模块化?还是先回到软件生命周期，看看整个运维过程中可能出现的问题。 代码在运维的过程中经过N轮需求更替，需求的变化可能与原来的有出入甚至是完全推翻 代码运维过程中开发人员的水平参差不齐，编码风格各异，即使有统一的规范也难以保持一致的风格 随着项目的迭代，原来高质量的代码质量逐渐降低，低质量的代码质量降到更低 随着时间的推移，现有的开发人员难以hold住原有代码的时候就面临着废弃或重写 针对上面的这些问题，我们能做什么？ 功能抽象在生产一个功能的时候，尽可能的将不变的内容和可变的内容分离，让可变的内容可配置，这样固定的部分就可以被最大限度的复用，解决了不断复制一大片代码，修改其中一点作为新用的问题。 学习的代码新代码的写入，应该是与现有的代码环境相适应，不管遗产代码质量怎样，都会被作为学习的对象；进一步说，不管你写的这片代码质量怎样，将来都可能被学习甚至是被复制；所以，好好写现在的代码，别误导新同学。 大胆开发，细心测试如果现有的代码已经难以被复用了，不得不复制一份的时候，在复制的同时，输出一份可复用的代码，让复制止于此，让后面的同学可以愉快地复用现有代码。 人人为我，我为人人；功在当下，利在千秋跳出恶性循环，进入良性迭代，我们的工作虽然只是多增加一只蝴蝶，却能让蝴蝶效应来的更猛烈。 3 参考资料 回顾：前端模块化和AMD、CMD规范（全） JavaScript模块化编程 JavaScript模块化加载","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"组件化","slug":"组件化","permalink":"http://rawbin-.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"Webpack 生产环境 参考资料","slug":"dev-tools/webpack/2015-09-10-webpack-reference","date":"2021-12-31T02:37:59.913Z","updated":"2021-12-31T02:37:59.913Z","comments":true,"path":"dev-tools/webpack/2015-09-10-webpack-reference/","link":"","permalink":"http://rawbin-.github.io/dev-tools/webpack/2015-09-10-webpack-reference/","excerpt":"","text":"1 Webpack相关文档 webpack on github webpack 文档主页 Webpack 官方文档 Webpack Github Wiki webpack how-to webpack compared ​ 2 参考资料 Book of Modern frontend tooling Book of Modern frontend tooling Choosing a Build Tool – Babel, Browserify, Webpack, Grunt and Gulp How to choose a build system for javascript app webpack compared developing with webpack 入门webpack看这篇就够了 入门webpack看这篇就够了 Webpack 入门指迷 基于webpack搭建前端工程解决方案探索 基于webpack搭建前端工程解决方案探索 Webpack Compared Webpack+React+ES6开发模式入门指南 详解前端模块化工具-webpack Webpack傻瓜式指南系列 Webpack傻瓜式指南（一） Webpack傻瓜式指南（二） Webpack实战 基于ES6，使用React、Webpack、Babel构建模块化JavaScript应用 基于ES6，使用React、Webpack、Babel构建模块化JavaScript应用 Webpack入门及实践 Webpack: 为Web开发而生的模块管理器 深入浅出React hjs-webpack Webpack-dev-server结合后端服务器的热替换配置","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"开发环境","slug":"Web开发/前端开发/开发环境","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"ES6","slug":"ES6","permalink":"http://rawbin-.github.io/tags/ES6/"},{"name":"React","slug":"React","permalink":"http://rawbin-.github.io/tags/React/"},{"name":"Webpack","slug":"Webpack","permalink":"http://rawbin-.github.io/tags/Webpack/"}]},{"title":"Web前端URL编码","slug":"encoding-decoding/2015-09-01-web-url-encoding","date":"2021-12-31T02:37:59.912Z","updated":"2021-12-31T02:37:59.912Z","comments":true,"path":"encoding-decoding/2015-09-01-web-url-encoding/","link":"","permalink":"http://rawbin-.github.io/encoding-decoding/2015-09-01-web-url-encoding/","excerpt":"","text":"1 参考资料 关于URL编码 字符编码笔记：ASCII，Unicode和UTF-8 URL编码与解码 URL编码与解码 浏览器URL编码 浏览器URL编码 每个 Web 开发者都应该知道的关于 URL 编码的知识 What every web developer must know about URL encoding 解析WEB开发编码问题 Web编码总结 url 编码（percentcode 百分号编码）","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"编码","slug":"编码","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"解码","slug":"解码","permalink":"http://rawbin-.github.io/tags/%E8%A7%A3%E7%A0%81/"},{"name":"URL","slug":"URL","permalink":"http://rawbin-.github.io/tags/URL/"}]},{"title":"JavaScript Web编辑器 剪贴板操作 复制 粘贴","slug":"dev-app/javascript/2015-09-03-javascript-clipboard-aother","date":"2021-12-31T02:37:59.912Z","updated":"2021-12-31T02:37:59.912Z","comments":true,"path":"dev-app/javascript/2015-09-03-javascript-clipboard-aother/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2015-09-03-javascript-clipboard-aother/","excerpt":"","text":"1 参考资料 windlow.clipboardData兼容性 检测浏览器是否支持HTML5功能 W3C Clipboard API clipboardData Support UndoManager and DOM Transaction HTML5 Editing HTML5 Editing Rich-Text Editing in Mozilla Web Editing Web Editing API “Copy to Clipboard” Made Easy with Clipboard.js Javascript: Copy To Clipboard Cross Browser 在IE、Gecko、WebKit下执行execCommand的常用效果差别。 编辑器中经常用到的execCommand方法参考。 Javascript: document.execCommand cross-browser? 实现JS复制、粘贴，Chrome/Firefox下可用 [document.execCommand() 用法说明(http://www.cnblogs.com/top5/archive/2010/12/01/1893276.html) Document.execCommand execCommand compatibility W3C execCommand execCommand Support Reading and copying selected text to clipboard using JavaScript clipboard copypin with jquery How do i copy to clipboard with javascript","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"复制","slug":"复制","permalink":"http://rawbin-.github.io/tags/%E5%A4%8D%E5%88%B6/"},{"name":"粘贴","slug":"粘贴","permalink":"http://rawbin-.github.io/tags/%E7%B2%98%E8%B4%B4/"},{"name":"clipboard","slug":"clipboard","permalink":"http://rawbin-.github.io/tags/clipboard/"},{"name":"copy","slug":"copy","permalink":"http://rawbin-.github.io/tags/copy/"},{"name":"paste","slug":"paste","permalink":"http://rawbin-.github.io/tags/paste/"}]},{"title":"JavaScript 浏览器 剪贴板操作 复制 粘贴","slug":"dev-app/javascript/2015-09-03-javascript-clipboard","date":"2021-12-31T02:37:59.912Z","updated":"2021-12-31T02:37:59.912Z","comments":true,"path":"dev-app/javascript/2015-09-03-javascript-clipboard/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2015-09-03-javascript-clipboard/","excerpt":"","text":"1 参考资料 The Definitive Guide to Copying and Pasting in JavaScript The Definitive Guide to Copying and Pasting in JavaScript JavaScript Local I/O tests Copy &amp; Paste &amp; The Web clipboard.js How do I copy to the clipboard in JavaScript? Accessing the System Clipboard with JavaScript – A Holy Grail? Cut and Copy Commands W3C Clipboard API and events Clipboard API兼容性 Document.execCommand兼容性 各浏览器中 document.execCommand Document.execCommand MDN MSDN execCommand MDN execCommand Using the clipboard Javascript: Copy To Clipboard Cross Browser JS获取剪贴板内容和设置剪贴板内容 JavaScript get clipboard data on paste event (Cross browser) JavaScript 如何获得粘贴的内容 clipboard.js JavaScript实现复制粘贴功能 实现JS复制、粘贴，Chrome/Firefox下可用 Clipboard cut, copy and paste with JavaScript Accessing the System Clipboard with JavaScript Javascript 在网页中实现读取剪贴板截图功能","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"复制","slug":"复制","permalink":"http://rawbin-.github.io/tags/%E5%A4%8D%E5%88%B6/"},{"name":"粘贴","slug":"粘贴","permalink":"http://rawbin-.github.io/tags/%E7%B2%98%E8%B4%B4/"},{"name":"clipboard","slug":"clipboard","permalink":"http://rawbin-.github.io/tags/clipboard/"},{"name":"copy","slug":"copy","permalink":"http://rawbin-.github.io/tags/copy/"},{"name":"paste","slug":"paste","permalink":"http://rawbin-.github.io/tags/paste/"}]},{"title":"JavaScript 点击下载 下载页面文件","slug":"dev-app/javascript/2015-09-04-javascript-click-download","date":"2021-12-31T02:37:59.912Z","updated":"2021-12-31T02:37:59.912Z","comments":true,"path":"dev-app/javascript/2015-09-04-javascript-click-download/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2015-09-04-javascript-click-download/","excerpt":"","text":"1 哪些方法可以用在翻看了众多页面之后，可以列出一些可以尝试的点： 1.1 直接打开URL window.open1.2 HTML5 A 标签 的download属性可以如下实现 &lt;a href=&quot;/url/to/file/path&quot; download=&quot;downloadName&quot;&gt;点击下载&lt;/a&gt; 1.3 使用封装的JavaScript库2 参考资料 Save/download data generated in JavaScript JavaScript Local I/O tests Force Download an Image Using Javascript How to trigger a file download when clicking an html button or javascript Using HTML5/Javascript to generate and save a file 在浏览器端用JS创建和下载文件 JavaScript多文件下载 JavaScript多文件下载 Starting file download with Javascript 什么是data URI scheme及如何使用data URI scheme Data URI和MHTML完整解决所有浏览器 DataURL在Web浏览器中的兼容性总结 Download data url file JS魔法堂：Data URI Scheme介绍 How to write a file / give it to the user HTML5 Cross Browser Polyfills How to force save as dialog box in firefox besides changing headers? Better approach to download file in JavaScript Does execCommand SaveAs work in Firefox? Saving generated files on the client-side Save to Drive Button 通过js保存图片到本地 2.1 HTTP Content Disposition Content-Disposition header - forcing SaveAs in browsers Content-Disposition 2.2 HTML5 A 标签 W3C HTML5 A HTML: The Living Standard HTML5 download attribute with JavaScript Better approach to download file in JavaScript Save files on disk using JavaScript Downloading resources in HTML5 变通方法实现保存文件 2.3 下载库参考 HTML5 Blob.js canvas-toBlob.js FileServer.js Downloadify Downloadify Example jquery.fileDownload jQuery File Download Plugin for Ajax","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"点击下载","slug":"点击下载","permalink":"http://rawbin-.github.io/tags/%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD/"}]},{"title":"JavaScript选区 内容选中","slug":"dev-app/javascript/2015-09-05-javascript-selection","date":"2021-12-31T02:37:59.912Z","updated":"2021-12-31T02:37:59.912Z","comments":true,"path":"dev-app/javascript/2015-09-05-javascript-selection/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2015-09-05-javascript-selection/","excerpt":"","text":"1 参考资料 JS Range HTML文档/文字内容选中、库及应用介绍 SD9031: 各浏览器对 Range 接口的实现存在差异 JavaScript标准Selection操作 富文本兼容性问题归纳(win) Selection and ranges in JavaScript Everything need to know about Javascript selection and range Document Object Model Range W3C Selection MDN Range MDN selection对象和range对象在不同浏览器上的操作差异 TextRange MSDN Range在各浏览器下的问题和常见处理办法 ie下光标在input,div中的定位–createTextRange的text和htmltext的用法 rangy selection range 库 window.getSelection和document.selection input和textarea设置文本选中和获取选中文本","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Selection","slug":"Selection","permalink":"http://rawbin-.github.io/tags/Selection/"},{"name":"Range","slug":"Range","permalink":"http://rawbin-.github.io/tags/Range/"}]},{"title":"JavaScript异步编程","slug":"async/2015-09-01-javascript-async","date":"2021-12-31T02:37:59.911Z","updated":"2021-12-31T02:37:59.911Z","comments":true,"path":"async/2015-09-01-javascript-async/","link":"","permalink":"http://rawbin-.github.io/async/2015-09-01-javascript-async/","excerpt":"","text":"1 参考资料 谈谈JavaScript的异步实现 Javascript异步编程的4种方法 探索Javascript异步编程 探索Javascript异步编程 JS魔法堂：剖析源码理解Promises/A规范","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"asynchronous","slug":"asynchronous","permalink":"http://rawbin-.github.io/tags/asynchronous/"},{"name":"promise","slug":"promise","permalink":"http://rawbin-.github.io/tags/promise/"}]},{"title":"HTTP pipeline","slug":"protocol/2015-09-01-http-pipeline","date":"2021-12-31T02:37:59.911Z","updated":"2021-12-31T02:37:59.911Z","comments":true,"path":"protocol/2015-09-01-http-pipeline/","link":"","permalink":"http://rawbin-.github.io/protocol/2015-09-01-http-pipeline/","excerpt":"","text":"1 参考资料 HTTP/1.1 Pipelining FAQ Pipeline模式 HTTP Pipeline BigPipe学习研究 BigPipe学习研究 The Asset Pipeline Asset Pipeline","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"bigpipe","slug":"bigpipe","permalink":"http://rawbin-.github.io/tags/bigpipe/"},{"name":"pipeline","slug":"pipeline","permalink":"http://rawbin-.github.io/tags/pipeline/"},{"name":"http","slug":"http","permalink":"http://rawbin-.github.io/tags/http/"}]},{"title":"DOM Attribute Property 区别","slug":"dev-app/javascript/2015-09-01-dom-attribute-property","date":"2021-12-31T02:37:59.911Z","updated":"2021-12-31T02:37:59.911Z","comments":true,"path":"dev-app/javascript/2015-09-01-dom-attribute-property/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2015-09-01-dom-attribute-property/","excerpt":"","text":"1 参考资料 DOM 中 Property 和 Attribute 的区别 DOM中Property与Attribute的区别 DOM元素的特性（Attribute）和属性（Property） DOM对象属性(property)与HTML标签特性(attribute) JavaScript的attribute和property辨析 js原生操作HTML对象的属性区别 jquery中attr方法和prop方法的区别 jquery attr jquery prop","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"http://rawbin-.github.io/tags/DOM/"},{"name":"property","slug":"property","permalink":"http://rawbin-.github.io/tags/property/"},{"name":"attribute","slug":"attribute","permalink":"http://rawbin-.github.io/tags/attribute/"}]},{"title":"ECMAScript 严格模式","slug":"language/ecma-javascript/2015-09-01-ecma-strict-mode","date":"2021-12-31T02:37:59.911Z","updated":"2021-12-31T02:37:59.911Z","comments":true,"path":"language/ecma-javascript/2015-09-01-ecma-strict-mode/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2015-09-01-ecma-strict-mode/","excerpt":"","text":"1 参考资料 ECMAScript文档 附录C Javascript 严格模式详解 MSDN严格模式 MDN 严格模式 MDN Stirct mode Javascript 严格模式详解 JavaScript的严格模式 “use strict” JavaScript 严格模式 ECMA-262-5 in detail chapter2 strict mode","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://rawbin-.github.io/tags/ECMAScript/"},{"name":"严格模式","slug":"严格模式","permalink":"http://rawbin-.github.io/tags/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"}]},{"title":"JavaScript日期时间选择器","slug":"dev-3rd-libs/2015-08-17-javascript-datetimepicker","date":"2021-12-31T02:37:59.910Z","updated":"2021-12-31T02:37:59.910Z","comments":true,"path":"dev-3rd-libs/2015-08-17-javascript-datetimepicker/","link":"","permalink":"http://rawbin-.github.io/dev-3rd-libs/2015-08-17-javascript-datetimepicker/","excerpt":"","text":"1 参考资料 My97 日期控件 自己写一个简单的jQuery日期选择器 JS日期时间选择控件 Adding a Timepicker to jQuery UI Datepicker Yet another jQuery time picker plugin A clock-style timepicker for Bootstrap (or jQuery). bootstrap-datetimepicker Date/Time Datepicker for Bootstrap","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"日期选择器","slug":"日期选择器","permalink":"http://rawbin-.github.io/tags/%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"DateTimePicker","slug":"DateTimePicker","permalink":"http://rawbin-.github.io/tags/DateTimePicker/"}]},{"title":"浏览器安全 前端安全","slug":"security/2015-08-17-frontend-security","date":"2021-12-31T02:37:59.910Z","updated":"2021-12-31T02:37:59.910Z","comments":true,"path":"security/2015-08-17-frontend-security/","link":"","permalink":"http://rawbin-.github.io/security/2015-08-17-frontend-security/","excerpt":"","text":"1 参考资料 浅谈CSRF攻击方式 深入理解JavaScript Hijacking原理 Google 浏览器安全手册","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"http://rawbin-.github.io/tags/CSRF/"},{"name":"Hijacking","slug":"Hijacking","permalink":"http://rawbin-.github.io/tags/Hijacking/"}]},{"title":"字符串匹配算法","slug":"structure-algorithm/2015-08-17-text-match-algorithm","date":"2021-12-31T02:37:59.910Z","updated":"2021-12-31T02:37:59.911Z","comments":true,"path":"structure-algorithm/2015-08-17-text-match-algorithm/","link":"","permalink":"http://rawbin-.github.io/structure-algorithm/2015-08-17-text-match-algorithm/","excerpt":"","text":"1 参考资料 字符串匹配的Boyer-Moore算法 字符串匹配的KMP算法 KMP算法详解 KMP算法详解\\ KMP算法解析 The Knuth-Morris-Pratt Algorithm in my own words","categories":[{"name":"算法结构","slug":"算法结构","permalink":"http://rawbin-.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"KMP","slug":"KMP","permalink":"http://rawbin-.github.io/tags/KMP/"}]},{"title":"NodeJS 调试技术","slug":"cross-platform/nodejs/2015-08-17-node-debug","date":"2021-12-31T02:37:59.910Z","updated":"2021-12-31T02:37:59.910Z","comments":true,"path":"cross-platform/nodejs/2015-08-17-node-debug/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2015-08-17-node-debug/","excerpt":"","text":"1 参考资料 Node.js调试指南 欲善其功，必先利其器–Nodejs调试技术总结 node.js调试 利用node-inspector来调试node node-gyp NodeJS的代码调试和性能调优 现在有多少 Node 调试的工具和方案 node.js调试 开始学nodejs —— 调试篇 开始学nodejs —— 调试篇","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"node-inspector","slug":"node-inspector","permalink":"http://rawbin-.github.io/tags/node-inspector/"},{"name":"gyp","slug":"gyp","permalink":"http://rawbin-.github.io/tags/gyp/"}]},{"title":"NodeJS 服务监控","slug":"cross-platform/nodejs/2015-08-17-node-monitor","date":"2021-12-31T02:37:59.910Z","updated":"2021-12-31T02:37:59.910Z","comments":true,"path":"cross-platform/nodejs/2015-08-17-node-monitor/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2015-08-17-node-monitor/","excerpt":"","text":"1 参考资料 写给Node.js学徒的7个建议 Node.js企业开发 五服务监控 告别node-forever,拥抱PM2 Nodejs服务器管理模块forever","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"PM2","slug":"PM2","permalink":"http://rawbin-.github.io/tags/PM2/"},{"name":"forever","slug":"forever","permalink":"http://rawbin-.github.io/tags/forever/"}]},{"title":"NodeJS 桌面应用开发","slug":"cross-platform/nodejs/2015-08-17-node-desktop-app","date":"2021-12-31T02:37:59.910Z","updated":"2021-12-31T02:37:59.910Z","comments":true,"path":"cross-platform/nodejs/2015-08-17-node-desktop-app/","link":"","permalink":"http://rawbin-.github.io/cross-platform/nodejs/2015-08-17-node-desktop-app/","excerpt":"","text":"1 参考资料 electron Atom Shell UI nw.js nw.js node-webkit 教程 使用 Dojo 和 node-webkit 开发跨平台桌面应用 node-webkit：开发桌面+WEB混合型应用的神器 node-webkit让web技术编写桌面应用 node-webkit开发桌面应用 Node-Webkit作者王文睿：桌面应用的全新开发方式 用node-webkit开发多平台的桌面客户端 RobotJS appjs parse AIR：使用 HTML + Javascript 开发桌面应用 USING HTML5 AND NODE.JS heX——基于 HTML5 和 Node.JS 开发桌面应用 hex TideSDK Demo 试用TideSDK及Windows 7下TideSDK的安装方法","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"NW","slug":"NW","permalink":"http://rawbin-.github.io/tags/NW/"},{"name":"桌面应用","slug":"桌面应用","permalink":"http://rawbin-.github.io/tags/%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"name":"node-webkit","slug":"node-webkit","permalink":"http://rawbin-.github.io/tags/node-webkit/"},{"name":"robotjs","slug":"robotjs","permalink":"http://rawbin-.github.io/tags/robotjs/"},{"name":"hex","slug":"hex","permalink":"http://rawbin-.github.io/tags/hex/"},{"name":"tideSDK","slug":"tideSDK","permalink":"http://rawbin-.github.io/tags/tideSDK/"},{"name":"appjs.AIR","slug":"appjs-AIR","permalink":"http://rawbin-.github.io/tags/appjs-AIR/"}]},{"title":"使用NodeJS实现前后端分离","slug":"architecture/2015-08-16-frontend-backend-separate","date":"2021-12-31T02:37:59.909Z","updated":"2021-12-31T02:37:59.909Z","comments":true,"path":"architecture/2015-08-16-frontend-backend-separate/","link":"","permalink":"http://rawbin-.github.io/architecture/2015-08-16-frontend-backend-separate/","excerpt":"","text":"1 参考资料 Web 研发模式的演变 Web 研发模式演变 淘宝前后端分离实践 前后端分离的思考与实践（一） 前后端分离的思考与实践（二） 前后端分离的思考与实践（三） 前后端分离的思考与实践（一） 前后端分离的思考与实践（二） 前后端分离的思考与实践（三） 前后端分离的思考与实践（四） 前后端分离的思考与实践（五） 前后端分离的思考与实践（六） 前后端分离的思考与实践(1) 前后端分离的思考与实践(2) 基于NodeJS的前端后端分离 基于NodeJS的前后端分离 前后端分离项目实践分析 Web前后端分离开发思路 再来讨论前后端分离的实践 架构设计：前后端分离之Web前端架构设计 一个简单粗暴的前后端分离方案 前后端分离开发部署模式 系统架构：Web应用架构的新趋势—前端和后端分离的一点想法 Web系统开发构架再思考-前后端的完全分离 Node.js Web应用代码热更新的另类思路 前后端完全分离初探 前后端分离了，然后呢？ 前后端分离了，然后呢？ Web 前后端分离的意义大吗？ Web系统开发构架再思考-前后端的完全分离 前后端分离方案交流，大家发表一下看法","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]},{"title":"JavaScript浏览器兼容性","slug":"dev-app/2015-08-16-javascript-browser-compatibility","date":"2021-12-31T02:37:59.909Z","updated":"2021-12-31T02:37:59.909Z","comments":true,"path":"dev-app/2015-08-16-javascript-browser-compatibility/","link":"","permalink":"http://rawbin-.github.io/dev-app/2015-08-16-javascript-browser-compatibility/","excerpt":"","text":"1 浏览器特性检测绝大部分通过User-Agent的检测方式已经一去不复返了，越来越分不清楚了；特性检测成为现有的JS类库推行的方式，将浏览器分为支持W3C标准的现代浏览器和非标准浏览器。下面看看一些特性的坑： 1.1 document.all执行代码： console.log(document.all,typeof document.all,!!document.all,&#39;all&#39; in document) 特性值 Firefox Chrome Edge IE11 IE10 IE9 IE8 IE7 IE5 document.all undefined [html,head,script] [object HTMLAllCollection] [object HTMLAllCollection] [object HTMLCollection] [object HTMLCollection] [object] [object] [object] typeof document.all undefined “object” undefined undefined object object object object object !!document.all false false false false true true true true true ‘all’ in document true true true true true true true true true 上面的情况看起来还是比较乱的： Firefox不支持document.all 属性，但保留了all属性，只是没用起来 Chrome 支持document.all属性，但其布尔值跟没支持的效果一样 Edge 支持`document.all 属性，但其布尔值看起来跟没支持一样 IE11的效果跟Edge一样，IE11可被视为现代浏览器的分界线，跟较低的IE版本比较，IE11算是不是IE的IE。 用document.all 来判断是IE已经不是一个靠谱的方法了 1.2 ActiveXObject执行代码： console.log(ActiveXObject,typeof ActiveXObject,!!ActiveXObject,&quot;ActiveXObject&quot; in window) 特性值 Firefox Chrome Edge IE11 IE10 IE9 IE8 IE7 IE5 ActiveXObject ActiveXObject is not defined ActiveXObject is not defined ActiveXObject is not defined function ActiveXObject(){[native code]} function ActiveXObject(){[native code]} function ActiveXObject(){[native code]} function ActiveXObject(){[native code]} function ActiveXObject(){[native code]} function ActiveXObject(){[native code]} typeof ActiveXObject – – – undefined function function function function function !!ActiveXObject – – – false true true true true true “ActiveXObject” in window – – – true true true true true true 这里的情况比较一致，但其内心还是激荡不已： IE11可被视为现代浏览器的分界线，跟较低的IE版本比较，IE11算是不是IE的IE。 在IE11控制台输入ActiveXObject，和window.ActiveXObject都提示undefined，然而console.log的结果却是一个函数对象 在IE11中使用ActiveXObject来区分IE已经不太靠谱了，勉强可以使用 &quot;ActiveXObject&quot; in window 来判断 综上，要判断一个浏览器是否支持Flash，可如下实现： （/*@cc_on!@*/0 也失效了） function isFlashSupported()&#123; var swf,versionInfo; // mordern W3C browsers if(navigator.plugins &amp;&amp; navigator.plugins.length &gt; 0)&#123; swf = navigator.plugins[&#39;Shockwave Flash&#39;]; swf &amp;&amp; (versionInfo = swf.description) //Plugin &#123;0: MimeType, 1: MimeType, name: &quot;Shockwave Flash&quot;, filename: &quot;pepflashplayer.dll&quot;, description: &quot;Shockwave Flash 20.0 r0&quot;, length: 2&#125; &#125;else&#123; //older IE try&#123; swf = new ActiveXObject(&#39;ShockwaveFlash.ShockwaveFlash&#39;) swf &amp;&amp; (versionInfo = swf.GetVariable(&quot;$version&quot;)) &#125;catch(e)&#123;&#125; &#125; if(swf)&#123; return true &#125;else&#123; return false; &#125; &#125; 在上述浏览器中可以获得正确的结果。 2 参考资料 Can I Use W3Help兼容性 W3Help主页 document.all兼容性 JavaScript初学者建议：不要去管浏览器兼容 很全面：Javascript和CSS浏览器兼容性方面经验总结 不同浏览器的Javascript兼容性总结 Javascript和CSS浏览器兼容总结 Javascript兼容多种浏览器 Javascript不同浏览器差异及兼容方法 【总结】IE和Firefox的Javascript兼容性总结 Javascript解决浏览器兼容性问题 12中JavaScript解决常见浏览器兼容的办法 12中JavaScript解决常见浏览器兼容的办法","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"兼容性","slug":"兼容性","permalink":"http://rawbin-.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"}]},{"title":"前端自动化测试","slug":"automatic/2015-08-16-frontend-automatic-tests","date":"2021-12-31T02:37:59.909Z","updated":"2021-12-31T02:37:59.909Z","comments":true,"path":"automatic/2015-08-16-frontend-automatic-tests/","link":"","permalink":"http://rawbin-.github.io/automatic/2015-08-16-frontend-automatic-tests/","excerpt":"","text":"1 参考资料 如何进行前端自动化测试 前端自动化测试探索 开发模块化的JavaScript组件 测试框架 Mocha 实例教程 dalekjs 7 天打造前端性能监控系统","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"测试","slug":"测试","permalink":"http://rawbin-.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"自动化","slug":"自动化","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"Python中的编码","slug":"encoding-decoding/2015-08-17-encoding-in-python","date":"2021-12-31T02:37:59.909Z","updated":"2021-12-31T02:37:59.910Z","comments":true,"path":"encoding-decoding/2015-08-17-encoding-in-python/","link":"","permalink":"http://rawbin-.github.io/encoding-decoding/2015-08-17-encoding-in-python/","excerpt":"","text":"这里我们简单问题复杂化，说几个编码 1 源文件编码#coding=utf-8 #-*- coding: utf-8 -*- 这样的格式，那么源代码中的内容就会以指定的编码进行存取，比如解析源码中的字符串的时候 2 字符串编码ustr = u’test中文’ 这个就是Unicode编码的字符串 varstr = ‘test中文’ 这个就是系统默认编码的字符串 用sys.getdefaultencoding()可以搞到 3 数据编码 文件存储编码，就是存储文件的时候什么格式，windows默认ansi，unix 默认utf8 文件内容编码，跟字符串编码相同，这个决定读取的数据如何转码 python文件写入的时候，会根据写入的内容确定数据的编码，举例： 手动将文件编码转换为ANSI，那么用python读取此文件内容然后写入另一个文件，则新写入的文件的编码为ANSI，可用NotePad++的格式菜单查看 手动将文件编码转换为UTF-8，那么用python读取此文件内容然后写入另一个文件，则新写入的文件的编码为UTF-8，可用NotePad++的格式菜单查看 如果单独写入字符串，python默认使用UTF8 无BOM的存储格式保存文件，文件的内容编码为UTF8 4 下面这堆就是浮云了：python 中有两种字符串对象，str 和unicode str类型是字节数组，unicode类型的是字符数组 简单举例，unicode 使用两个字节表示字符 strings = ‘“中文测试” #len(strings) = 8 stringu = u’”中文测试” #len(stringu) = 4 unicode是python编码转换的中间编码，有两个方法来做编码转换操作decode(encoding)和encode(encoding) decode 是按照指定的编码对对象进行解码，解码的结果是unicode对象 encode是将unicode对象，按照指定的编码编码成相应的格式比如说gbk str 对象是已经被编码过的对象，需要现将其按照指定编码进行解码成unicode，再转换成其他编码 python中从一个编码到另一个编码之间的转换都是先将对象解码为unicode 然后再将unicode对象编码为指定的编码 5 参考资料 python读写不同编码txt文件 Python字符集编码和文件读写 详解Python2.x中对Unicode编码的使用 Python中的str与unicode处理方法 PYTHON编码处理-str与Unicode的区别 Unicode 码制转换问题 初探python编码 python对16位unicode汉字处理","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"Web开发/前端开发/Python","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Python/"}],"tags":[{"name":"编码","slug":"编码","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"Python","slug":"Python","permalink":"http://rawbin-.github.io/tags/Python/"},{"name":"Unicode","slug":"Unicode","permalink":"http://rawbin-.github.io/tags/Unicode/"},{"name":"str","slug":"str","permalink":"http://rawbin-.github.io/tags/str/"}]},{"title":"HTML性能优化","slug":"performance/2015-08-16-html5-performance","date":"2021-12-31T02:37:59.909Z","updated":"2021-12-31T02:37:59.909Z","comments":true,"path":"performance/2015-08-16-html5-performance/","link":"","permalink":"http://rawbin-.github.io/performance/2015-08-16-html5-performance/","excerpt":"","text":"1 参考资料 前端加载 部署 及性能优化 前端性能优化 Web前端优化最佳实践及工具集锦 移动HTML5前端性能优化指南 移动前端系列——移动页面性能优化 移动网站性能优化：网页加载技术概览 移动网站性能优化：网页加载技术概览 HTML5性能优化与分析 HTML5性能优化分析 7 天打造前端性能监控系统 全是干货！移动HTML 5前端性能优化指南 移动客户端HTML5前端性能优化指南","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://rawbin-.github.io/tags/HTML5/"},{"name":"性能优化","slug":"性能优化","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"使用Fiddler进行HTTP调试","slug":"dev-tools/2015-08-16-fiddler-debug","date":"2021-12-31T02:37:59.909Z","updated":"2021-12-31T02:37:59.909Z","comments":true,"path":"dev-tools/2015-08-16-fiddler-debug/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2015-08-16-fiddler-debug/","excerpt":"","text":"1 参考资料 关于 WEB/HTTP 调试利器 Fiddler 的一些技巧分享 Fiddler 高级用法：Fiddler Script 与 HTTP 断点调试 Fiddler 图文教程 Fiddler 图文教程 Fiddler 官方教程 web debugger fiddler 使用小结","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"HTTP调试","slug":"HTTP调试","permalink":"http://rawbin-.github.io/tags/HTTP%E8%B0%83%E8%AF%95/"},{"name":"请求","slug":"请求","permalink":"http://rawbin-.github.io/tags/%E8%AF%B7%E6%B1%82/"},{"name":"响应","slug":"响应","permalink":"http://rawbin-.github.io/tags/%E5%93%8D%E5%BA%94/"}]},{"title":"JavaScript面向对象编程","slug":"architecture/2015-08-15-javascript-oop","date":"2021-12-31T02:37:59.908Z","updated":"2021-12-31T02:37:59.908Z","comments":true,"path":"architecture/2015-08-15-javascript-oop/","link":"","permalink":"http://rawbin-.github.io/architecture/2015-08-15-javascript-oop/","excerpt":"","text":"1 参考资料 编程的宗派 面向过程的分析(POA)，和面向对象的分析(OOA) 面向对象编程和面向过程编程的差异！ 面向对象和面向过程的区别 JavaScript OO 实现","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"面向过程","slug":"面向过程","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"}]},{"title":"JavaScript模块化，组件化编程","slug":"modules/2015-08-15-javascript-modular","date":"2021-12-31T02:37:59.908Z","updated":"2021-12-31T02:37:59.908Z","comments":true,"path":"modules/2015-08-15-javascript-modular/","link":"","permalink":"http://rawbin-.github.io/modules/2015-08-15-javascript-modular/","excerpt":"","text":"1 参考资料 软件的模块化开发 JavaScript组件化 浅谈模块化的JavaScript 开发模块化的JavaScript组件 前端模块化开发价值 深入理解JavaScript 模块模式 模块化JavaScript Javascript模块化编程（一）：模块的写法 Javascript模块化编程（二）：AMD规范 Javascript模块化编程（三）：require.js的用法 拥抱模块化的JavaScript 拥抱模块化的JavaScript 前端开发：模块化 — 高效重构 前端开发：模块化 — 高效重构 Web Components是不是Web的未来 Web Components - 面向未来的组件标准 Web Components - 面向未来的组件标准 从HTML Components的衰落看Web Components的危机 跨端组件实践 - 移动时代的前端 使用Shadow DOM创建Web组件 2015前端组件化框架之路 2015前端组件化框架之路 Web应用的组件化开发（一） Web应用的组件化开发（二） 组件化的Web王国 2015前端框架何去何从 组件和模块的区别 Modular JS","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"面向过程","slug":"面向过程","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"组件化","slug":"组件化","permalink":"http://rawbin-.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"移动端touch事件小结","slug":"dev-app/2015-08-14-touch-event","date":"2021-12-31T02:37:59.901Z","updated":"2021-12-31T02:37:59.908Z","comments":true,"path":"dev-app/2015-08-14-touch-event/","link":"","permalink":"http://rawbin-.github.io/dev-app/2015-08-14-touch-event/","excerpt":"","text":"1 问题来源iPhone中微信中打开页面，click隐藏fixed 弹层无效。 1.1 参考资料 web移动前端的click点透问题 在手持设备上使用 touchstart 事件代替 click 事件是不是个好主意？ touchend 事件在 iPhone 上过于灵敏，如何解决？ 指尖下的js ——多触式web前端开发之一：对于Touch的处理 iPhone开发中touch的事件随笔 iphone、ipod Touch、ipad触屏时的js事件 UITouch/UIResponder：iOS上触摸事件的视图检测和事件传递 [译]消除iphone中onClick事件延时 REMOVE ONCLICK DELAY ON WEBKIT FOR IPHONE Android 触摸事件 Android 中屏幕点击事件的实现 Android 事件传递机制 安卓事件分发和消费机制 Android的Touch事件处理机制 Android Touch事件传递机制解析","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"移动开发","slug":"Web开发/前端开发/JavaScript/移动开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"touch","slug":"touch","permalink":"http://rawbin-.github.io/tags/touch/"},{"name":"click","slug":"click","permalink":"http://rawbin-.github.io/tags/click/"},{"name":"iOS","slug":"iOS","permalink":"http://rawbin-.github.io/tags/iOS/"},{"name":"android","slug":"android","permalink":"http://rawbin-.github.io/tags/android/"}]},{"title":"MediaElement HTML5 Video播放视频适配过程","slug":"dev-3rd-libs/2015-08-01-mediaelement-video-cross-domain","date":"2021-12-31T02:37:59.900Z","updated":"2021-12-31T02:37:59.900Z","comments":true,"path":"dev-3rd-libs/2015-08-01-mediaelement-video-cross-domain/","link":"","permalink":"http://rawbin-.github.io/dev-3rd-libs/2015-08-01-mediaelement-video-cross-domain/","excerpt":"","text":"1 说明网页中的音视频媒体格式众多，同时在不同的浏览器中的表现经常不一致 mediaelementjs 这个牛逼的组件就是为了给出一个统一的解决方案，来使得不同的浏览器环境尽量做到同样的输出。 2 参考： 官方网站 github 3 资源说明 swf文件，用来模拟视频播放界面的 svg png gif文件 界面交互相关展示的元素 css js 4 操作方法4.1 部署资源将上面的几部分资源分别部署到可以访问的位置，根据视频兼容性和经验建议，将视频转为MP4格式将减少许多麻烦,同时MP4的编码格式必须是AVC(H.264),否则看不到图像。 完成后需要根据部署进行相应的资源属性的修改,所以那些.min.* 的文件不能直接用了，你行你自己改 修改css中图片引用的位置 将里面的相对路径都改为咱们部署的绝对路径 修改flash引用路径 源代码中的pluginPath 默认将js和flash放在同一路径，咱们这里不行，需要单独分开来，加一个options.flashPath的配置项 css js 这些都放在本工程下了，看着改吧 4.2 资源引用 将如下代码放入页面 ( 最好是head区域，参考 ) &lt;script src=&quot;/path/to/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/path/to/mediaelement-and-player.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/path/to/mediaelementplayer.min.css&quot; /&gt; 添加相应的媒体元素, 可选设置相应的属性 &lt;video src=&quot;/path/to/test_video.mp4&quot; poster=&quot;/path/to/poster.jpg&quot; width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot; preload=&quot;none&quot;&gt;&lt;/video&gt; &lt;audio src=&quot;myaudio.mp3&quot;&gt;&lt;/audio&gt; 执行代码绑定额外的事件 $(&#39;video,audio&#39;).mediaelementplayer(&#123; success:function(mediaElement, domObject,player)&#123; console.log(mediaElement) console.log(domObject) console.log(player) &#125; &#125;); 4.3 使用方法 使用跨域的代码: $(function()&#123; $(&#39;video,audio&#39;).mediaelementplayer(&#123; //for related swf file,because they are not on the same path and host flashPath: &#39;//path/to/media_element_flash/&#39;, // name of flash file flashName: &#39;flashmediaelement-cdn.swf&#39;, // set to &#39;always&#39; for CDN version flashScriptAccess: &#39;always&#39;, success:function(mediaElement, domObject,player)&#123; //console.log(mediaElement) //console.log(domObject) //console.log(player) &#125; &#125;); &#125;); 代码解释： //for related swf file,because they are not on the same path and host flashPath: &#39;//path/to/media_element_flash/&#39;, 源码中的js和swf文件都放在同一个路径，所以pluginPath引用了js和swf文件，而咱们的swf放在source下，js放在当前项目下，所以需要分开，新增一个flashPath路径专门引用swf文件，同时修改了源代码 // name of flash file flashName: &#39;flashmediaelement-cdn.swf&#39;, 这个是跨域需要引用的swf文件，默认的flashmediaelement.swf不允许跨域访问，具体表现为在IE8下播放视频是会报JS错误，这里配置的是flash的allowDomain。 // set to &#39;always&#39; for CDN version flashScriptAccess: &#39;always&#39;, 这个是swf加载后的回调需要用到的，默认的值是sameDomain，只允许访问相同域下的脚本，导致无法调用js回调。具体表现为在IE8下播放器样式无法正常渲染。这里配置的是flash的allowScriptAccess属性。 问题解决过程参考MediaElement Issue 属性说明 allowScriptAccess 这个属性一般出现在下面的代码里 &lt;object classid=&#39;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&#39; codebase=&#39;http://download.adobe.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0&#39; height=&#39;100%&#39; width=&#39;100%&#39;&gt; &lt;param name=&#39;src&#39; value=&#39;test.swf&#39;/&gt; &lt;param name=&#39;AllowScriptAccess&#39; value=&#39;never&#39;/&gt; &lt;embed name=&#39;test.swf&#39; pluginspage=&#39;http://www.adobe.com/go/getflashplayer&#39; src=&#39;test.swf&#39; height=&#39;100%&#39; width=&#39;100%&#39; AllowScriptAccess=&#39;never&#39;/&gt; &lt;/object&gt; allowScriptAccess 指定当前的Flash对象对外部环境（html）的脚本访问权限。 never 不允许当前Flash访问外部环境的脚本 sameDomain 只允许当前Flash访问外部环境中与当前Flash同域的脚本 always 允许当前Flash访问外部环境所有脚本 allowDomain 这个属性一般出现在如下代码 &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!--?http://www.mydomain.com/crossdomain.xml?--&gt; &lt;cross-domain-policy&gt; &lt;allow-access-from domain=&quot;www.otherdomain.com&quot; /&gt; &lt;allow-access-from domain=&quot;*.adobe.com&quot; /&gt; &lt;allow-access-from domain=&quot;*&quot; /&gt; &lt;/cross-domain-policy&gt; 或者出现在如下的代码中 Security.allowDomain(&quot;www.domain.com&quot;, &quot;*&quot;); Security.allowInsecureDomain(&quot;www.domain.com&quot;, &quot;*&quot;); allowDomain 允许参数中指定的域下的脚本或SWF访问当前SWF（加载XML策略文件的或者设置allowDomain的Flash文件）的对象和变量,这种权限开放是单向的。allowInsecureDomain 则允许HTTP协议下的资源访问HTTPS下的资源 4.4 参考文档 Creating a cross-browser video player Video on the Web MediaElement Github MediaElement官网 MediaElement Issue ActionScript ExternalInterface ActionScript Security Flash跨域的完全解决方案 彻底理解crossdomain.xml 跨域SWF调用 页面中Flash对象参数 Flash 跨域总结 Flash 安全总结","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"Web前端","slug":"开发技术/Web前端","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://rawbin-.github.io/tags/HTML5/"},{"name":"MediaElement","slug":"MediaElement","permalink":"http://rawbin-.github.io/tags/MediaElement/"},{"name":"Video","slug":"Video","permalink":"http://rawbin-.github.io/tags/Video/"},{"name":"Flash","slug":"Flash","permalink":"http://rawbin-.github.io/tags/Flash/"},{"name":"跨域","slug":"跨域","permalink":"http://rawbin-.github.io/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"跨浏览器JavaScript剪贴板 打印机操作 生成二维码","slug":"dev-app/2015-08-01-javascript-clipboard-printer","date":"2021-12-31T02:37:59.900Z","updated":"2021-12-31T02:37:59.900Z","comments":true,"path":"dev-app/2015-08-01-javascript-clipboard-printer/","link":"","permalink":"http://rawbin-.github.io/dev-app/2015-08-01-javascript-clipboard-printer/","excerpt":"","text":"1 剪贴板操作使用脚本访问剪贴板会导致安全性问题，比如恶意脚本写入剪贴板内容，进行剪贴板投毒 或者 读取剪贴板内容发送到远程，导致用户隐私信息泄露 因此各大浏览器都对脚本访问剪贴板做了不同的限制，比如必须是用户操作（点击，菜单等）的响应才行。 目前有的较通用的剪贴板写入方案是利用透明的Flash，获取用户操作并通过浏览器Flash插件的方式访问系统剪贴板,用Flash插件来兼容低版本浏览器。参考 如果只需要兼容高版本浏览器，可参考，利用新的浏览器API来实现。 1.1 复制到剪贴板使用jquery-zclip 或者直接使用ZeroClipBoard 实现内容的复制。 一个完整的Demo如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;ZeroClipboard Test&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .line&#123;margin-bottom:20px;&#125; /* 复制提示 */ .copy-tips&#123;position:fixed;z-index:999;bottom:50%;left:50%;margin:0 0 -20px -80px;background-color:rgba(0, 0, 0, 0.2);filter:progid:DXImageTransform.Microsoft.Gradient(startColorstr=#30000000, endColorstr=#30000000);padding:6px;&#125; .copy-tips-wrap&#123;padding:10px 20px;text-align:center;border:1px solid #F4D9A6;background-color:#FFFDEE;font-size:14px;&#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.10.1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery.zclip.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;line&quot;&gt; &lt;h2&gt;demo1 点击复制当前文本&lt;/h2&gt; &lt;a href=&quot;#none&quot; class=&quot;copy&quot;&gt;点击复制我&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;line&quot;&gt; &lt;h2&gt;demo2 点击复制表单中的文本&lt;/h2&gt; &lt;a href=&quot;#none&quot; class=&quot;copy-input&quot;&gt;点击复制单中的文本&lt;/a&gt; &lt;input type=&quot;text&quot; class=&quot;input&quot; value=&quot;输入要复制的内容&quot; /&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; /* 定义所有class为copy标签，点击后可复制被点击对象的文本 */ $(&quot;.copy&quot;).zclip(&#123; path: &quot;ZeroClipboard.swf&quot;, copy: function()&#123; return $(this).text(); &#125;, beforeCopy:function()&#123;/* 按住鼠标时的操作 */ $(this).css(&quot;color&quot;,&quot;orange&quot;); &#125;, afterCopy:function()&#123;/* 复制成功后的操作 */ var $copysuc = $(&quot;&lt;div class=&#39;copy-tips&#39;&gt;&lt;div class=&#39;copy-tips-wrap&#39;&gt;? 复制成功&lt;/div&gt;&lt;/div&gt;&quot;); $(&quot;body&quot;).find(&quot;.copy-tips&quot;).remove().end().append($copysuc); $(&quot;.copy-tips&quot;).fadeOut(3000); &#125; &#125;); /* 定义所有class为copy-input标签，点击后可复制class为input的文本 */ $(&quot;.copy-input&quot;).zclip(&#123; path: &quot;ZeroClipboard.swf&quot;, copy: function()&#123; return $(this).parent().find(&quot;.input&quot;).val(); &#125;, afterCopy:function()&#123;/* 复制成功后的操作 */ var $copysuc = $(&quot;&lt;div class=&#39;copy-tips&#39;&gt;&lt;div class=&#39;copy-tips-wrap&#39;&gt;? 复制成功&lt;/div&gt;&lt;/div&gt;&quot;); $(&quot;body&quot;).find(&quot;.copy-tips&quot;).remove().end().append($copysuc); $(&quot;.copy-tips&quot;).fadeOut(3000); &#125; &#125;); &#125;); &lt;/script&gt; 1.2 参考 zeroclipboard官网 zeroclipboard github jquery zclip github clipboard.js Javascript实现复制到剪贴板，兼容所有浏览器 1.3 粘贴剪贴板内容2 打印机操作可以打印页面部分内容，可以选择弹层或者IFrame的方式，直接查看其中的例子即可参考 2.1 参考 jquery 插件 jquery printarea github 3 JavaScript 生成二维码采用Table布局来兼容低版本浏览器，也可以使用Canvas进行二维码绘制。直接参考中的示例即可 3.0.1 参考 jquery qrcode jquery qrcode github 4 其他参考文档 The Definitive Guide to Copying and Pasting in JavaScript Accessing the System Clipboard with JavaScript – A Holy Grail? JS获取剪贴板内容和设置剪贴板内容 JavaScript get clipboard data on paste event (Cross browser) JavaScript 如何获得粘贴的内容 clipboard.js JavaScript实现复制粘贴功能 实现JS复制、粘贴，Chrome/Firefox下可用 Clipboard cut, copy and paste with JavaScript Accessing the System Clipboard with JavaScript Javascript 在网页中实现读取剪贴板截图功能 How do I copy to the clipboard in JavaScript? getData method (clipboardData) Clipboard cut, copy and paste with JavaScript Copy &amp; Paste &amp; The Web 4.1 临时其他function getSelectedText()&#123; if(window.getSelection)&#123; return window.getSelection().toString() &#125;else if(document.selection)&#123; return document.selection.createRange().text &#125; &#125;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"Web开发","slug":"开发技术/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"开发技术/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"打印机","slug":"打印机","permalink":"http://rawbin-.github.io/tags/%E6%89%93%E5%8D%B0%E6%9C%BA/"},{"name":"剪贴板","slug":"剪贴板","permalink":"http://rawbin-.github.io/tags/%E5%89%AA%E8%B4%B4%E6%9D%BF/"},{"name":"复制","slug":"复制","permalink":"http://rawbin-.github.io/tags/%E5%A4%8D%E5%88%B6/"},{"name":"粘贴","slug":"粘贴","permalink":"http://rawbin-.github.io/tags/%E7%B2%98%E8%B4%B4/"},{"name":"部分打印","slug":"部分打印","permalink":"http://rawbin-.github.io/tags/%E9%83%A8%E5%88%86%E6%89%93%E5%8D%B0/"},{"name":"二维码","slug":"二维码","permalink":"http://rawbin-.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"}]},{"title":"升级Win10 Cisco VPN工具不能用","slug":"os-app/2015-07-22-win10-vpn","date":"2021-12-31T02:37:59.900Z","updated":"2021-12-31T02:37:59.900Z","comments":true,"path":"os-app/2015-07-22-win10-vpn/","link":"","permalink":"http://rawbin-.github.io/os-app/2015-07-22-win10-vpn/","excerpt":"","text":"1 问题由来老版本的Cisco VPN Client 在Win10上不能正常使用，新版本的要收费，还要注册才能下载。 Reason 442: Failed to enable Virtual Adapter on Windows 10 这个就是 注册表的问题 2 问题点 安装Global VPN 安装Cisco VPN Client 如果装不上解压出来安装 msi 修改注册表 3 解决办法3.1 直接替换 参考使用Shrew Soft VPNClient 替代 Cisco VPN Client 到 Shrew Soft VPNClient 网站 下载Shrew Soft VPNClient下载,安装 导入原来的配置即可 3.2 问题解决为什么要解决呢，上面的替换工具一般没什么问题，但是但是，如果你是用动态密码登陆，上面的工具登一次之后就再也登不上了，不会有密码同步的效果。Cisco 会在你密码需要同步的时候进行同步提示，即使认证失败了也可以过一会换一个动态密码进行认证。 首先安装winfix和dneupdate解决网络修复网络扩展的问题，参考 然后将Cisco 用WinRAR解压后安装(不解压直接不能装，不修复即使解压后安装到最后也只能回滚)，参考 装完之后将注册表的信息改过来 Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\CVirtA] &quot;DisplayName&quot;=&quot;Cisco Systems VPN Adapter for 64-bit Windows&quot; 如果在Win10 10586上解压后的exe 安装不好使，使用msi安装即可。 切记，一定要将exe解压 后才能安装。 3.3 下载新版新版无法导入配置也是蛋疼 下载地址anyconnect-all-packages-4.2.00096-k9.zip磁力链接anyconnect-all-packages-4.2.01022-k9.zip磁力链接 4 参考资料 Cisco VPN Client 常见问题解析 INSTALL &amp; FIX CISCO VPN CLIENT ON WINDOWS 10 (32 &amp; 64 BIT). FIX REASON 442: FAILED TO ENABLE VIRTUAL ADAPTER Choosing a VPN Client Cisco VPN Client on Windows 10 使用Shrew Soft VPNClient 替代 Cisco VPN Client Shrew Soft VPNClient下载 win10 上安装 Cisco VPN Client win10 上安装 Cisco VPN Client win10 Cisco VPN Client问题解决 Windows 7 安装 Cisco VPN Client 5.0.x Cisco VPN Client 442 DNE Support AnyConnect 各版本下载 anyconnect 下载地址参考 五步搞定VPN","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"系统应用","slug":"操作系统/系统应用","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"Cisco VPN","slug":"Cisco-VPN","permalink":"http://rawbin-.github.io/tags/Cisco-VPN/"},{"name":"VPN","slug":"VPN","permalink":"http://rawbin-.github.io/tags/VPN/"}]},{"title":"Win7 Win8 Win10非Administrator管理员获取管理员权限 打开应用需要开启账户控制","slug":"os-app/2015-07-21-win8-win10-administrator","date":"2021-12-31T02:37:59.900Z","updated":"2021-12-31T02:37:59.900Z","comments":true,"path":"os-app/2015-07-21-win8-win10-administrator/","link":"","permalink":"http://rawbin-.github.io/os-app/2015-07-21-win8-win10-administrator/","excerpt":"","text":"参考 微软的官方文档 权限管理在每个操作系统里面都有，是一种比较安全的控制，微软的UAC，相当于类Unix系统中的sudo 1 内置管理员 Administrator 使用完整管理员权限看这个说明将 用户帐户控制：对内置管理员帐户使用管理员批准模式 禁用 则获取完整的管理员权限 当然 这个选项用户帐户控制: 管理员批准模式中管理员的提升提示行为 不提示直接提升 才行 2 非内置管理员 获取管理员权限，同时开启账户控制（不开启不能使用内置的应用）用户帐户控制:以管理员批准模式运行所有管理员 启用 则每次都需要经过权限批准 有地方说设成 “禁用” Win8非内置系统管理员获得完整权限的方法，就可以获取完整的至高无上的管理员权限。 然而在使用内置应用的时候，会提示“在关闭了用户账户控制的情况下 无法打开xxxx”,这样包括Edge浏览器在内的许多应用都将无法使用，即使在控制面板中开启提示也没用 所以这个还是需要开启的。 当然 这个选项用户帐户控制: 管理员批准模式中管理员的提升提示行为 不提示直接提升 才行 这样看来，开启账户控制，设置成批准不提示提升，才是解决问题的关键。 3 参考资料 Win8非内置系统管理员获得完整权限的方法 Windows 用户帐户控制循序渐进指南 Windows 用户帐户控制循序渐进指南(https://technet.microsoft.com/zh-cn/library/cc709691\\(v=ws.10\\).aspx#BKMK_1) 用户帐户控制：对内置管理员帐户使用管理员批准模式","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"管理员权限","slug":"管理员权限","permalink":"http://rawbin-.github.io/tags/%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90/"},{"name":"非内置管理员","slug":"非内置管理员","permalink":"http://rawbin-.github.io/tags/%E9%9D%9E%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%91%98/"},{"name":"Administrator","slug":"Administrator","permalink":"http://rawbin-.github.io/tags/Administrator/"}]},{"title":"JavaScript正则表达式及其应用","slug":"language/ecma-javascript/2015-08-03-javascript-regex","date":"2021-12-31T02:37:59.900Z","updated":"2021-12-31T02:37:59.900Z","comments":true,"path":"language/ecma-javascript/2015-08-03-javascript-regex/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2015-08-03-javascript-regex/","excerpt":"","text":"正则表达式是一套文本处理的规则，最初在Perl语言中实现，其他各种编程语言的实现或多或少有一些差异，所以需要看具体的语言中的实现和支持情况。 比如Perl语言中的如下正则语法在JavaScript中不被支持： \\a \\e \\l \\u \\L \\U \\E \\Q \\A \\Z \\z \\G (?&lt;= (?&lt;| (?# (?&lt;xxx&gt; 1 JavaScript 正则表达式语法JavaScript正则表达式用于字符串的匹配，分隔，查找，替换。 String对象的match,replace,search,split RegExp对象的test,exec 2 JavaScript正则表达式语法2.1 字符匹配模式 表达式 含义 示例 字母和数字字符 原样匹配 abc123 匹配 abc123 ^ 匹配字符串的开头位置 $ 匹配字符串的结尾位置 \\b 匹配单词的边界 \\B 匹配非单词的边界 (?=p) 接下来的匹配需要匹配p，前面的匹配项才算匹配 (?!p) 接下来的匹配不能匹配p，前面的匹配项才算匹配 […] 括号中字符列表中的任意一个 [^…] 不是括号中字符列表中的任意一个 \\w 任何ASCII字符组成的单词，等价于[a-zA-Z0-9_] \\W 任何不是ASCII字符组成的单词，等价于[a-zA-Z0-9_] \\d 任何ASCII数字，等价于[0-9] \\D 任何非ASCII数字，等价于[^0-9] \\s 任何Unicode空白符，等价于[\\t\\r\\n\\0xB\\f] \\S 任何非Unicode空白符的字符[^\\t\\r\\n\\0xB\\f] . 匹配除换行符和其他Unicode行终止符之外的任意字符 {n} 匹配前面的模式n次 {n,} 匹配前面的模式至少n次 {n,m} 匹配前面的模式至少n次，至多m次 ? 匹配前面的模式0次或者一次，等价于{0,1} * 匹配前面的模式0次或者多次，等价于{0,} + 匹配前面的模式至少一次，等价于{1,} | 选择匹配左边的表达式或者右边的表达式 (…) 将括号内的匹配合为一个单元，并按左括号出现的顺序进行组合编号，可在后续的表达式中使用\\n 来引用第n个匹配，n从1开始 (?:…) 只对括号内的匹配进行组合，但不进行单元编号，不能后续引用 \\o NUL \\u0000 \\t 制表符 \\u0009 \\n 换行符 \\u000A \\v 垂直制表符 \\u000B \\f 换页符 \\u000C \\r 回车符 \\u000D [\\b] 匹配退格键 \\xnn 由十六进制nn 指定的拉丁字符 \\x0A 等价于 \\n \\uxxxx 由十六进制xxxx指定的Unicode字符 \\u000D 等价于 \\r \\cX 控制字符^X 也就是Ctrl+X 如vi编辑器中\\cJ 等价于换行符\\n 2.2 匹配模式修饰 修饰符 含义 示例 i 匹配模式不区分大小写 g 找到所有的匹配，而不是第一个 m 多行匹配模式，^匹配一会的开头和字符串的开头，$匹配行的结束和字符串的结束 3 正则表达式方法3.1 String 对象3.1.1 对象方法3.1.1.1 stringObj.match(regexp) 参数被当做一个正则表达式 如果不包含g属性，则执行一次匹配，如果没找到匹配则返回null；如果有匹配，返回一个数组，第一个元素为匹配字符串，后面的元素依次为分组的结果，数组包含两个属性，index代表匹配文本在string中的开始位置，input则是对该string的引用。 如果包含了g属性，则执行一次全局匹配，在string中查找所有的匹配的子串，如果没有找到则返回null，如果找到则返回一个数组，这时候数组的内容为所有的匹配字符串的结果，此时数组不包括正则分组的信息，也没有index和input属性。 “abc123abcdef789xyz”.match(/((\\d+)([a-z]+))/) //[&quot;123abcdef&quot;, &quot;123abcdef&quot;, &quot;123&quot;, &quot;abcdef&quot;] &quot;abc123abcdef789xyz&quot;.match(/((\\d+)([a-z]+))/g) //[&quot;123abcdef&quot;, &quot;789xyz&quot;] var result = &quot;abc123abcdef789xyz&quot;.match(/((\\d+)([a-z]+))/); console.log(result) //[&quot;123abcdef&quot;, &quot;123abcdef&quot;, &quot;123&quot;, &quot;abcdef&quot;] console.log(result.index) //3 console.log(result.input) //abc123abcdef789xyz var result = &quot;abc123abcdef789xyz&quot;.match(/((\\d+)([a-z]+))/g); console.log(result) //[&quot;123abcdef&quot;, &quot;789xyz&quot;] console.log(result.index) //undefined console.log(result.input) //undefined 3.1.1.2 stringObj.replace(regexp,replacement) 如果查询参数是一个字符串，则只替换字符串对应的文本； 如果查询参数是一个正则表达式直接量或者正则表达式对象，则进行正则替换。 如果查询参数中正则表达式包含g参数，则在字符串中替换所有的匹配，否则替换第一个匹配。 替换参数如果是一个字符串，则进行直接替换，如果是一个函数，可自定义替换规则，函数返回值即为替换文本，函数参数列表为（$&amp;,$1,$2…index,input）,前面为匹配的文本和每个分组的匹配，后面为匹配的起始位置，最后为输入字符串。 如果查询参数是正则表达式，则有特殊的字符串引用可以使用： 符号 含义 $n 查询正则中第n个分组的匹配结果 $&amp; 整个查询正则的匹配结果 $` 匹配子串左边的文本 $’ 匹配子串右边的文本 $$ 美元符号 &quot;abc123abcdef789xyz&quot;.replace(/((\\d+)([a-z]+))/,&quot;#&quot;) //abc#789xyz &quot;abc123abcdef789xyz&quot;.replace(/((\\d+)([a-z]+))/g,&quot;#&quot;) //abc## &quot;abc123abcdef789xyz&quot;.replace(/((\\d+)([a-z]+))/,&quot;#$1,$2,$3#&quot;) //abc#123abcdef,123,abcdef#789xyz &quot;abc123abcdef789xyz&quot;.replace(/((\\d+)([a-z]+))/g,&quot;#$1,$2,$3#&quot;) //abc#123abcdef,123,abcdef##789xyz,789,xyz# &quot;abc123abcdef789xyz&quot;.replace(/((\\d+)([a-z]+))/,function(match,group1,group2,group3,group4)&#123; console.log(arguments) return &quot;#&quot; &#125;) //[&quot;123abcdef&quot;, &quot;123abcdef&quot;, &quot;123&quot;, &quot;abcdef&quot;, 3, &quot;abc123abcdef789xyz&quot;] //abc#789xyz &quot;abc123abcdef789xyz&quot;.replace(/((\\d+)([a-z]+))/g,function(match,group1,group2,group3,group4)&#123; console.log(arguments) return &quot;#&quot; &#125;) //[&quot;123abcdef&quot;, &quot;123abcdef&quot;, &quot;123&quot;, &quot;abcdef&quot;, 3, &quot;abc123abcdef789xyz&quot;] //[&quot;789xyz&quot;, &quot;789xyz&quot;, &quot;789&quot;, &quot;xyz&quot;, 12, &quot;abc123abcdef789xyz&quot;] //abc## 3.1.1.3 stringObj.search(regexp) 此方法按照查询参数在目标字符串中查询匹配，并返回第一个匹配的位置，如果没找到返回-1； 此方法中正则模式的g参数会被忽略，同时正则对象的lastIndex属性也会被忽略，总是返回目标文本中的第一个匹配位置。 “abc123abcdef789xyz”.search(/((\\d+)([a-z]+))/) //3 ​ 3.1.1.4 stringObj.split(delimiter,limit) 在目标字符串中匹配所有delimiter，通过delimiter 的匹配切分字符串 ，返回结果为delimiter之间的部分； 如果delimiter匹配字符串的开头，则返回结果的第一个字符串为空串； 如果没有指定delimiter，则返回的结果是只包含输入字符串一个元素的数组； 如果指定delimiter为空字符串或者匹配控制串的模式，则返回结果是输入字符串中的每个字符分开组成的数组（注意：第一个字符之前和最后一个字符之后的空字符不匹配）； 如果指定delimiter是一个包含分组的正则表达式，则匹配这些分组的子串会包含中返回值数组中。 “123abcdef789xyz”.split(/((\\d+)([a-z]+))/) //匹配开头第一个返回值为空，如果带有分组，一次返回每个分组 //[&quot;&quot;, &quot;123abcdef&quot;, &quot;123&quot;, &quot;abcdef&quot;, &quot;&quot;, &quot;789xyz&quot;, &quot;789&quot;, &quot;xyz&quot;, &quot;&quot;] 3.2 RegExp对象通过正则表达式字面量/pattern/ 或者new RegExp(pattern,attributes)的方式获得正则表达式对象。 3.2.1 对象属性 global 是否具有g属性 ignoreCase 是否具有i属性 lastIndex 上一次匹配的位置，由于在一个字符串内多次匹配 multiline 是否具有m属性 source 正则表达式的源文本 3.2.2 方法3.2.2.1 regexObj.exec(string) 通用的模式匹配 如果没有匹配，返回null 如果有匹配，返回一个结果数组，第一个元素是匹配的结果result[0],后面的都是分组元素的结果。数组具有两个属性index 表示匹配第一个字符的位置，input为输入的字符串。 如果正则表达式包含g属性，则每次则会从lastIndex出开始匹配，如果能匹配上则将lastIndex本次匹配的最后的位置，如果不能匹配则将lastIndex置为0。 var result = /(\\d+)abc([a-z]{3})/.exec(“abc123abcdef123abcdef123”); console.log(result) //[&quot;123abcdef&quot;, &quot;123&quot;, &quot;def&quot;] console.log(result.index) //3 console.log(result.input) //abc123abcdef123abcdef123 var regex = /(\\d+)abc([a-z]&#123;3&#125;)/g; var target = &#39;abc123abcdef789abcxyz789&#39;; result = regex.exec(target) console.log(result) //[&quot;123abcdef&quot;, &quot;123&quot;, &quot;def&quot;] console.log(result.index) //3 console.log(regex.lastIndex) //12 console.log(result.input) //abc123abcdef789abcxyz789 result = regex.exec(target) console.log(result) //[&quot;789abcxyz&quot;, &quot;789&quot;, &quot;xyz&quot;] console.log(result.index) //12 console.log(regex.lastIndex) //21 console.log(result.input) //abc123abcdef789abcxyz789 3.2.2.2 regexObj.test(string) 检测一个字符串是否匹配某个模式如果有检测到匹配返回true，如果没有匹配返回false。 3.2.2.2.1 检测邮箱这是一个较粗糙的表达式，可以根据自身情况进行调整​ /^\\w+@[0-9a-z]+(.\\w+)+$/.test(“&#116;&#x65;&#x73;&#116;&#64;&#x74;&#101;&#115;&#116;&#x2e;&#x63;&#111;&#x6d;&#46;&#99;&#110;“) 3.2.2.2.2 检测IPv4地址将地址的一段分为一位、两位、三位的数字并进行穷举 /^((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)\\.)&#123;3&#125;(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)$/.test(&quot;192.168.1.1&quot;) 4 正则表达式应用4.1 一个坑用一个正则表达式来测试多个字符串是否符合全为数字的规则 var regex = /^\\d+$/g; console.log(regex.test(&quot;123456&quot;)) //true console.log(regex.lastIndex) console.log(regex.test(&quot;123456&quot;)) //false console.log(regex.lastIndex) 4.1.1 解决一 去掉全局匹配var regex = /^\\d+$/; console.log(regex.test(&quot;123456&quot;)) //true console.log(regex.lastIndex) console.log(regex.test(&quot;123456&quot;)) //true console.log(regex.lastIndex) 4.1.2 解决二 每次使用之前重置lastIndex，从头开始var regex = /^\\d+$/g; console.log(regex.test(&quot;123456&quot;)) //true console.log(regex.lastIndex) regex.lastIndex = 0; console.log(regex.test(&quot;123456&quot;)) //true console.log(regex.lastIndex) 4.2 给HTML文件中所有的CSS和JS文件加上版本号将&lt;script src=&quot;./test.js&quot;&gt; 改为 &lt;script src=&quot;./test@dev.js&quot;&gt; 将&lt;link href=&quot;./test.css&quot;&gt; 改为 &lt;script src=&quot;./test@dev.css&quot;&gt;​HTML中属性的表示方式参考SGML Attribute 3.2.2 Attributes Elements may have associated properties, called attributes, which may have values (by default, or set by authors or scripts). Attribute/value pairs appear before the final “&gt;” of an element’s start tag. Any number of (legal) attribute value pairs, separated by spaces, may appear in an element’s start tag. They may appear in any order. In this example, the id attribute is set for an H1 element: This is an identified heading thanks to the id attribute By default, SGML requires that all attribute values be delimited using either double quotation marks (ASCII decimal 34) or single quotation marks (ASCII decimal 39). Single quote marks can be included within the attribute value when the value is delimited by double quote marks, and vice versa. Authors may also use numeric character references to represent double quotes (&#34;) and single quotes (&#39;). For double quotes authors can also use the character entity reference &quot;. In certain cases, authors may specify the value of an attribute without any quotation marks. The attribute value may only contain letters (a-z and A-Z), digits (0-9), hyphens (ASCII decimal 45), periods (ASCII decimal 46), underscores (ASCII decimal 95), and colons (ASCII decimal 58). We recommend using quotation marks even when it is possible to eliminate them. Attribute names are always case-insensitive. Attribute values are generally case-insensitive. The definition of each attribute in the reference manual indicates whether its value is case-insensitive. All the attributes defined by this specification are listed in the attribute index. 匹配script src的正则 /&lt;script.*?src=([&#39;&quot;])([^&#39;&quot;\\s]*?)\\1[^&gt;]*&gt;/ig 匹配link href的正则 /&lt;link.*?href=([&#39;&quot;])([^&#39;&quot;\\s]*?)\\1[^&gt;]*&gt;/ig 为了加入版本号，咱们将script标签匹配为&lt;script ... src=&quot;......和.js ...&gt;，然后在这两段之间加入版本号@dev 将正则表达式做如下调整：​ var regexSrc = /(&lt;script.*?src=([‘“])([^’”\\s]*?))(.js\\2[^&gt;]&gt;)/ig; var regexHref = /(&lt;link.*?href=([‘“])([^’”\\s]*?))(.css\\2[^&gt;]&gt;)/ig; var testStr = [ &#39;&lt;link rel=&quot;stylesheet&quot; href=&quot;http://test.com/test1.css&quot; type=&quot;text/css&quot;/&gt;&#39;, &#39;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://test.com/test2.css&quot;/&gt;&#39;, &#39;&lt;script type=&quot;text/javascript&quot; src=&quot;http://test.com/test1.js&quot;&gt;&lt;/script&gt;&#39;, &#39;&lt;script src=&quot;http://test.com/test2.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&#39; ].join(&#39;&#39;); var regexSrc = /(&lt;script.*?src=([&#39;&quot;])([^&#39;&quot;\\s]*?))(\\.js\\2[^&gt;]*&gt;)/ig; console.log(testStr.match(regexSrc)); console.log(regexSrc.exec(testStr)); var regexHref = /(&lt;link.*?href=([&#39;&quot;])([^&#39;&quot;\\s]*?))(\\.css\\2[^&gt;]*&gt;)/ig; console.log(testStr.match(regexHref)); console.log(regexHref.exec(testStr)); function addVersion(input,regex,version)&#123; input = input || &quot;&quot;; return input.replace(regex,function()&#123; //数星星 var left = arguments[1]; var right = arguments[4] return [left,version,right].join(&#39;&#39;); &#125;); &#125; var result; var version = &quot;@dev&quot;; result = addVersion(testStr,regexSrc,version); console.log(&quot;script result:&quot;,result); result = addVersion(result,regexHref,version); console.log(&quot;style result:&quot;,result); 5 工具推荐 正则表达式教程和工具 Regex Match Tracer Regex Match Tracer 正则表达式测试工具 Regex Buddy,Regex Magic 测试调试工具 6 参考资料 正则表达式教程和工具 正则表达式30分钟入门教程 JavaScript正则表达式 正则表达式图形化工具 MDN 正则表达式 JavaScript正则表达式 JavaScript正则表达式 Regex Expression Info","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"开发技术","slug":"Web开发/前端开发/开发技术","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"Web开发/前端开发/开发技术/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://rawbin-.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"让My97DatePicker支持modular编译","slug":"dev-3rd-libs/2015-07-19-my97datepicker-modular","date":"2021-12-31T02:37:59.899Z","updated":"2021-12-31T02:37:59.899Z","comments":true,"path":"dev-3rd-libs/2015-07-19-my97datepicker-modular/","link":"","permalink":"http://rawbin-.github.io/dev-3rd-libs/2015-07-19-my97datepicker-modular/","excerpt":"","text":"My97DatePicker 是一个老牌的日期时间选择器，简约而不简单。 但免费使用的源代码是经过压缩和加密过的。 文件结构清晰My97DatePicker—-WdatePicker.js //主文件—-calendar.js //日期时间选择器封装—-lang——–zh-CN.js——–en.js——–zh-TW.js 简单打开文件查看： WdatePicker中除了配置部分，均经过混淆 calendar.js 进行过加密，使用eval执行 语言包未进行过压缩或者加密 使用浏览器打开demo页面，点击并选择一个日期，在调试工具中可以看到加载的这些资源。使用调试工具中的代码美化工具可以将WdatePicker.js 进行格式美化，便于调试和阅读。但在calendar的代码，只是一行eval代码，在Chrome和Firefox下无法查看详细代码。但在IE8-11、Edge中可以通过开发人员工具查看资源动态代码中的 eval code并进行代码美化，。 使用状态如下： Chrome中无法查看eval 代码； Firefox Firebug插件能查看eval代码，无法进行代码格式化，可以拷出来在编辑器或者在线代码格式化工具中进行格式化； IE开发人员工具中可以查看eval code并进行代码格式化； 拿到了eval code之后，基本的代码逻辑就有了，没有混淆过的代码。 直接用eval code 替换calendar.js的内容，其实本身代码效果就是一样的。 修改部分如下： WdatePicker.js 代码末尾加 window.$dp = $dp; window.WdatePicker = WdatePicker; calendar.js 代码末尾加 window.My97DP = My97DP; window.$c = $c; lang/zh-CN.js 代码末尾加 window.$lang = $lang 原本以为这样将每个模块对外输出的对象挂到window上就行了，结果发现还是找不到$c这个对象。将$c相关的代码抽取出来效果如下“ (funciton()&#123; var $c; function My97DP() &#123; $c = this; //window.$c = $c = this; ...... &#125; window.My97DP = My97DP; window.$c = $c; &#125;()); new My97DP(); console.log(window.$c) 在My97DP函数中，改变的是它所在的闭包环境中的$c的值，在调用new My97DP()执行$c = this后$c会指向My97DP，然而并不改变windows.$c的值。 因为在外层IIFE执行后，window.$c的值为未初始化的$c的值undefined。 这是基本数据类型值传递的过程。 最终的解决办法就是被注释的那行代码window.$c = $c = this;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"Web开发","slug":"开发技术/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"My97Datepicker","slug":"My97Datepicker","permalink":"http://rawbin-.github.io/tags/My97Datepicker/"},{"name":"Modular","slug":"Modular","permalink":"http://rawbin-.github.io/tags/Modular/"},{"name":"模块化编译","slug":"模块化编译","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E8%AF%91/"},{"name":"日期时间选择器","slug":"日期时间选择器","permalink":"http://rawbin-.github.io/tags/%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E5%99%A8/"}]},{"title":"解决使用bootstrap时的CSS样式冲突问题","slug":"dev-3rd-libs/2015-07-18-bootstrap-style-conflict","date":"2021-12-31T02:37:59.899Z","updated":"2021-12-31T02:37:59.899Z","comments":true,"path":"dev-3rd-libs/2015-07-18-bootstrap-style-conflict/","link":"","permalink":"http://rawbin-.github.io/dev-3rd-libs/2015-07-18-bootstrap-style-conflict/","excerpt":"","text":"遇到过两个类似的问题，在这里小结一下： bootstrap的box-sizing 引起的宽度挤压 导致的内容换行 自定义样式被bootstrap覆盖 导致样式错乱 一般的使用场景是： 页面本身是使用bootstrap风格的 页面本身是自定义样式，单独引入bootstrap风格的组件的 在上面第一种场景里面，问题相对容易解决，找到对应的样式，在自定义的样式表中重写相应的样式，并在合适的位置添加 !important 标志即可。 在自定义样式和bootstrap组件混搭的样式里面，问题相对难处理。 样式的引入要么bootstrap在前，要么自定义样式在前，但不论怎样都会存在或多或少的样式冲突问题。 冲突的来源大致如下： bootstrap的box-sizing 引起的 bootstrap中对基本元素 如input ul li 等元素的样式定义引起的 bootstrap和自定义样式中的同名样式覆盖引起的 冲突的解决办法： 不使用相关的组件 这样可以避免由组件引入的bootstrap样式引起的冲突问题，但结果要么重新选组件，要么自己写组件 使用相关组件，处理样式问题 添加样式的方法 不引人bootstrap完整样式，使用浏览器调试工具将使用到的样式剥离出来，加入相应的命名空间 删除样式的方法。 引入完整的bootstrap样式，将引起冲突的样式进行重写或者删除。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"Web前端","slug":"开发技术/Web前端","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://rawbin-.github.io/tags/bootstrap/"},{"name":"css","slug":"css","permalink":"http://rawbin-.github.io/tags/css/"},{"name":"样式冲突","slug":"样式冲突","permalink":"http://rawbin-.github.io/tags/%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81/"}]},{"title":"","slug":"encoding-decoding/2015-07-17-read-encoded-js-code","date":"2021-12-31T02:37:59.899Z","updated":"2021-12-31T02:37:59.899Z","comments":true,"path":"encoding-decoding/2015-07-17-read-encoded-js-code/","link":"","permalink":"http://rawbin-.github.io/encoding-decoding/2015-07-17-read-encoded-js-code/","excerpt":"","text":"layout: posttitle: “如何阅读混淆加密过的JavaScript代码”categories: [开发技术, Web前端]tags: [JavaScript,加密,混淆] 1 代码混淆 删除注释和多于的空格换行等分隔符 变量和函数名称替换为较短的a,b,c等 压缩代码体积减少流量和提高页面加载性能 降低代码可读性，在一定程度上保护代码、增加攻击难度、提高安全性 2 代码加密 通过字符串分隔、替换、拼接等方式生成JavaScript源代码文本 通过将代码转换为十进制、十六进制，进行编码等方式来进行加密 通过eval和Function来执行生成的JavaScript源代码文本 最终始终会生成能被JavaScript引擎解析的JavaScript代码 最终始终会生成能被JavaScript引擎解析的JavaScript代码 最终始终会生成能被JavaScript引擎解析的JavaScript代码 重要的事情说三遍 3 解决办法3.1 代码混淆 直接通过各大浏览器的 “{}” 代码美化工具进行格式化 通过各种在线的代码美化、格式化工具进行格式化 3.2 代码加密 直接避开加密算法，在代码生成之后在浏览器调试工具中中进行获取 研究下代码加密方法，然后在生成后浏览器调试工具中进行获取 写解密方法，获取代码 4 实例My97DatePicker 是一个老牌的日期时间选择器，简约而不简单。 但免费使用的源代码是经过压缩和加密过的。 文件结构清晰My97DatePicker—-WdatePicker.js //主文件—-calendar.js //日期时间选择器封装—-lang——–zh-CN.js——–en.js——–zh-TW.js 简单打开文件查看： WdatePicker中除了配置部分，均经过混淆 calendar.js 进行过加密，使用eval执行 语言包未进行过压缩或者加密 使用浏览器打开demo页面，点击并选择一个日期，在调试工具中可以看到加载的这些资源。使用调试工具中的代码美化工具可以将WdatePicker.js 进行格式美化，便于调试和阅读。但在calendar的代码，只是一行eval代码，在Chrome和Firefox下无法查看详细代码。但在IE8-11、Edge中可以通过开发人员工具查看资源动态代码中的 eval code并进行代码美化，。 使用状态如下： Chrome中无法查看eval 代码； Firefox Firebug插件能查看eval代码，无法进行代码格式化，可以拷出来在编辑器或者在线代码格式化工具中进行格式化； IE开发人员工具中可以查看eval code并进行代码格式化； 拿到了eval code之后，基本的代码逻辑就有了，没有混淆过的代码。 先来看一段拿到的eval code： if($cfg.eCont) &#123; $dp = &#123; &#125;; for(var p in $pdp) &#123; if(typeof $pdp[p] == &quot;object&quot;) &#123; $dp[p] = &#123; &#125;; for(var pp in $pdp[p]) &#123; $dp[p][pp] = $pdp[p][pp]; &#125; &#125; else &#123; $dp[p] = $pdp[p]; &#125; &#125; &#125; else &#123; $dp = $pdp; &#125; for(p in $cfg) &#123; $dp[p] = $cfg[p]; &#125; var $c; 再来看一段eval 中函数的第一个参数： &#39;l($4o.44)&#123;$f=&#123;&#125;;1b(q p 4r $2s)l(6p $2s[p]==&quot;6o&quot;)&#123;$f[p]=&#123;&#125;;1b(q 4G 4r $2s[p])$f[p][4G]=$2s[p][4G]&#125;t $f[p]=$2s[p]&#125;t $f=$2s;1b(p 4r $4o)$f[p]=$4o[p];q $c; 大致可以看出，这里面就是做了一个字符串映射和替换： if--&gt;l $dp--&gt;$f; for--&gt;1b; var--&gt;q; 等等 然后再来看看这个加密函数： eval(function(p, a, c, k, e, d) &#123; e = function(c) &#123; return (c &lt; a ? &quot;&quot; : e(parseInt(c / a))) + ((c = c % a) &gt; 35 ? String.fromCharCode(c + 29) : c.toString(36)) &#125; ; if (!&#39;&#39;.replace(/^/, String)) &#123; while (c--) d[e(c)] = k[c] || e(c); k = [function(e) &#123; return d[e] &#125; ]; e = function() &#123; return &#39;\\\\w+&#39; &#125; ; c = 1; &#125; ;while (c--) if (k[c]) p = p.replace(new RegExp(&#39;\\\\b&#39; + e(c) + &#39;\\\\b&#39;,&#39;g&#39;), k[c]); return p; &#125;(codeString,62,575,keywordString.split(&#39;|&#39;),0,&#123;&#125;)); 参数对应： codeString--&gt;p //这里就是加密过的代码 62----------&gt;a 575---------&gt;c //猜这里是一个执行的限度，大小跟关键字列表的大小相同 keywords----&gt;k //代码中的关键字列表 0-----------&gt;e //会直接被重写，不论传什么值效果都一样，或者说这个值没有意义 &#123;&#125;----------&gt;d //存放临时结果的字典 再回过头去看代码，并除掉一些冗余代码之后： eval(function(p, a, c, k, e, d) &#123; //重写e, 不论传什么值进来结果都一样 e = function(c) &#123; return (c &lt; a ? &quot;&quot; : e(parseInt(c / a))) + ((c = c % a) &gt; 35 ? String.fromCharCode(c + 29) : c.toString(36)) &#125; // 有值就取值，没有值就算一个值,构成一个完整的字典 while (c--) d[e(c)] = k[c] || e(c); //把对应位置上的关键字替换回来 p = p.replace(new RegExp(&#39;\\\\b\\\\w+\\\\b&#39;,&#39;g&#39;), function(e) &#123; return d[e] &#125;); return p; &#125;(codeString,62,575,keywordString.split(&#39;|&#39;),0,&#123;&#125;)); 还没解决的一个问题，这个62 是什么意思？ 等我收拾好了Chrome和Firefox的调试工具看看再说，调试工具失效了。 5 参考文档 使用 estools 辅助反混淆 Javascript JS混淆还原 JS混淆代码还原－JS反混淆：利用JS进行赋值实现 JAVASCRIPT加密解密终级指南 如何去除My97DatePicker控件上右键弹出官网的链接—如何debug混淆过的代码 My97DatePicker Demo My97DatePicker 官网","categories":[],"tags":[]},{"title":"升级Win10 后 休眠 睡眠 无法唤醒的问题解决","slug":"os-app/2015-07-20-notebook-win10-wakeup-problem","date":"2021-12-31T02:37:59.899Z","updated":"2021-12-31T02:37:59.899Z","comments":true,"path":"os-app/2015-07-20-notebook-win10-wakeup-problem/","link":"","permalink":"http://rawbin-.github.io/os-app/2015-07-20-notebook-win10-wakeup-problem/","excerpt":"","text":"解决办法参考 惠普官方论坛 1 操作 到Intel Management Engine下载 下载最新版的驱动，下载后解压待用 在命令行输入 devmgmt.msc 打开设备管理器，或者我的电脑右键管理，设备管理器 在 系统设备 下找到 Intel(R) Management Engine Interface,右键更新驱动 找到刚刚解压的驱动目录，安装即可，可能需要重启 参考版本 2015/8/31 11.0.0.1166 版本好使 2 参考资料 惠普客服支持 HP电脑-睡眠和休眠的问题 惠普电脑驱动下载 Win10 无法关机和无法唤醒问题解决 Intel Management Engine下载","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"操作系统","slug":"应用技术/操作系统","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"睡眠","slug":"睡眠","permalink":"http://rawbin-.github.io/tags/%E7%9D%A1%E7%9C%A0/"},{"name":"休眠","slug":"休眠","permalink":"http://rawbin-.github.io/tags/%E4%BC%91%E7%9C%A0/"},{"name":"无法唤醒","slug":"无法唤醒","permalink":"http://rawbin-.github.io/tags/%E6%97%A0%E6%B3%95%E5%94%A4%E9%86%92/"}]},{"title":"前端加载 部署 及性能优化","slug":"dev-app/2015-07-11-fe-load-deploy-opt","date":"2021-12-31T02:37:59.898Z","updated":"2021-12-31T02:37:59.898Z","comments":true,"path":"dev-app/2015-07-11-fe-load-deploy-opt/","link":"","permalink":"http://rawbin-.github.io/dev-app/2015-07-11-fe-load-deploy-opt/","excerpt":"","text":"1 参考资料 大公司里怎样开发和部署前端代码？ 前端性能优化指南 前端性能优化 前端技术的前后端分离思想 web高性能开发系列随笔 前端性能优化的14个规则 JavaScript 的性能优化：加载和执行 前端工程与性能优化 前端工程与性能优化 Web前端性能优化进阶路 web前端页面性能优化小结 前端各种优化","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"Web前端","slug":"开发技术/Web前端","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"加载","slug":"加载","permalink":"http://rawbin-.github.io/tags/%E5%8A%A0%E8%BD%BD/"},{"name":"部署","slug":"部署","permalink":"http://rawbin-.github.io/tags/%E9%83%A8%E7%BD%B2/"},{"name":"优化","slug":"优化","permalink":"http://rawbin-.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"XMPP HTTP bind ie8 session cookie","slug":"dev-app/cors/2015-07-15-xmpp-httpbind-ie8","date":"2021-12-31T02:37:59.898Z","updated":"2021-12-31T02:37:59.898Z","comments":true,"path":"dev-app/cors/2015-07-15-xmpp-httpbind-ie8/","link":"","permalink":"http://rawbin-.github.io/dev-app/cors/2015-07-15-xmpp-httpbind-ie8/","excerpt":"","text":"1 问题描述1.1 场景一个简单的单点登录的场景，客户端需要访问app.test.com这个域，而app这个域要求客户端经过auth.test.com的认证，那么就需要向auth域发送一个认证请求，并在认证通过后设置认证相关信息的cookie，这个cookie需要是app域的，因为在访问app域的时候需要带上。浏览器的隐私策略可能在访问app这个域的时候，不会带上刚刚设置的这个认证信息的cookie参考, 甚至可以不执行这个认证cookie的设置（这个可以在浏览器的隐私策略中配置）。 当然问题类似但不限于这个，比如 cookie带不上 又一个cookie带不上 还有这个 Iframe也出问题 等等 1.2 原因分析当然，这个问题主要是针对IE啦，谁让微软浏览器出那么早呢。同时目前还没看到通过编程的方式自动降低IE隐私策略的方法，即使有也难以登堂，因为用户不能同意；同时我们也不能以编程的方式直接将咱们的域名加入浏览器的信任站点列表。由于浏览器安全的要求，注定这样的方法不可能存在。 先来看看IE几级隐私策略（从高到地，从严格到宽松，IE11，不同版本可能不一样）： 阻止所有Cookie 阻止来自所有网站的所有Cookie 该计算机上已有的Cookie不能被网站读取 高 阻止来自没有精简隐私策略的网站的所有Cookie 阻止没有经你明确同意就保存你的联系信息的第三方Cookie 中高 阻止没有精简策略的第三方Cookie 阻止没有经你明确同意就保存你的联系信息的第三方Cookie 阻止没有经你默许就保存你的联系信息的第三方Cookie 中 阻止没有精简策略的第三方Cookie 阻止没有经你明确同意就保存你的联系信息的第三方Cookie 限制没有经你默许就保存你的联系信息的第三方Cookie 低 阻止没有精简策略的第三方Cookie 限制没有经你默许就保存你的联系信息的第三方Cookie 授权所有Cookie 保存来自任何网站的Cookie 该计算机上已有的Cookie可被创建他们的网站获取 从上面可以看出，第三方Cookie总是打击对象，而我们的认证信息Cookie就属于第三方。为了避免受打击，我们需要一些办法来保护我们的认证信息免受打击。第三方Cookie简言之就是非目的站点的Cookie，比如场景中我们访问app.test.com 那么auth.test.com 设置的Cookie就是第三方Cookie。 什么是“什么是第三方Cookie”参考：这里，这里，这里。 1.3 解决办法1.3.1 惹不起躲得起这是一个简单粗暴却行之有效的解决办法，使用cookie会有问题，那么我就不用cookie。比如在使用认证的时候原来是通过HTTP头Set-Cookie的方式保存认证信息到客户端，现在直接不用cookie，将原来要放入cookie的信息直接在请求（一般为跨域请求）中返回。这样我们就拿到认证信息了，再接下来的请求中直接以参数传递的形式带上，怎么着都不会存在这个第三方cookie的问题了。我们可以在dom或者本地存储等任何地方放起来，每次需要这个信息的时候再取出来放入参数中就行，避免了cookie的使用和频繁调用认证请求。 1.3.2 直面惨淡人生一切根源都是在浏览器中，浏览器的问题就是大家都要面对的问题，这样就会有很多成型的解决方案。传言早在IE6 横行霸道以前，聪明的先驱就已经提出了成熟的解决方案P3P（Platform for Privacy Preference），并且IE6是最早支持这个W3C标准的。这个自然了，既然IE6都支持了，那咱们现代浏览器还说啥。 P3P标准要求站点明确声明需要搜集哪些隐私信息和这些被搜集的隐私信息的用途，一般浏览器在解析时看到这个声明，就不会出现类似上面的问题了，浏览器就是好骗哈。 2 相关知识2.1 XMPPXMPP(Extensible Messaging and Prensence Protocal是一个网络即时通讯协议，它是基于TCP/IP来传输XML格式的文本。消息的XML内容中用一些特定的标志表示了消息的属性（从哪儿来，发哪儿去，谁发的，内容是什么等）。 2.2 浏览器安全模型IE 的安全模型（IE内容分区模型）会将内容区分对待，并可能根据内容的可信度（IE的不同安全等级）区分对待其中的Cookie，并且在没有明确指定P3P信息的时候，默认阻止第三方cookie的发送（第三方Cookie的限制）。 2.3 P3PP3P（Platform for Privacy Preference）是一个在线隐身保护的一个W3C标准，大致内容是对互联网访问时涉及到的隐私的一些约定： 2.3.1 隐私信息的收集 收集哪些信息， 为什么收集这些信息 收集的这些信息会给谁用， 收集的这些信息会被保留多久 2.3.2 隐私信息的使用 对信息进行了十几个分类，比如个人指纹信息，计算机的操作系统和版本信息，地理位置信息等 对信息的用途进行十来个分类，比如当前应用，管理，开发等 对信息的使用者进行了分类，比如站点本身，公共使用，物流等。 对信息保留的时限进行了分类，如会话期间，无限期保留等。 有了上面的约定，我们就可以在客户端（浏览器端）和站点（服务端）对隐私信息的收集和使用做一个限制。将哪些信息可以被用来做什么做一个明确的限制。当然这是建立在服务端受信的基础上的，服务端声明它可以遵守这些声明和约定，客户端用户相信这个声明，但具体服务端怎么做，就要看情况了。 2.3.3 P3P策略配置策略配置有两种方法，一种是通过配置文件的方法，这种方法会多两次请求。另外一种是直接添加HTTP Header的方式，这个简单高效，更适合我们的实验。 3 实例演练（使用P3P）3.1 环境配置修改本机host（屌丝必备技能哈）127.0.0.1 auth.test.com127.0.0.1 app.test.com 3.2 场景说明两台机子，一台认证中心（auth.test.com），一台应用中心（app.test.com），访问应用中心的时候需要先向认证中心进行认证获取认证信息Cookie后，再拿这个认证信息去访问应用中心。我们就看看Cookie能不能带过去。 认证中心上有一个认证接口，做认证并设置响应的认证信息Cookie。 应用中心就一个页面，看看访问页面的时候能不能带Cookie过去。 3.3 其他说明这个发不出Cookie的场景在我这难以直接重现，于是通过修改浏览器隐私设置的方式进行重现。将IE浏览器的隐私策略级别设为“高”，这时能够获取到auth.test.com中的cookie，可以直接用fiddler等工具抓包，或者在浏览器的开发工具中的网络标签中查看。但在访问app.test.com的时候却无法把Cookie带过去。 如果将IE浏览器的隐私策略级别设为“中高”及以下，可以在本地存在cookie的情况下，访问app.test.com时中带过去。 3.4 上代码3.4.1 auth.test.com起一个认证的服务，由于80被app.test.com 占用，这里使用9000端口。 直接使用node auth-server.js 运行。 //auth-server.js var http = require(&#39;http&#39;); var server = http.createServer(function(request,response)&#123; console.log(request.url) if(/^\\/login.action.*/.test(request.url))&#123; console.log(&#39;setting cookie...&#39;) //response.setHeader(&#39;Set-Cookie&#39;,[&#39;logined=true;path=/;domain=.test.com;HttpOnly;&#39;,&#39;sessionid=session_123456;path=/;domain=.test.com;HttpOnly;&#39;]) response.setHeader(&#39;Set-Cookie&#39;,[&#39;logined=true;path=/;domain=.test.com;&#39;,&#39;sessionid=session_123456;path=/;domain=.test.com;&#39;]) &#125; //response.setHeader(&#39;P3P&#39;,&#39;CP=CAO PSA OUR&#39;) response.writeHead(200,&#123;&#125;); response.end(); &#125;).listen(9000); 3.4.2 app.test.com放置一个页面，进行认证和访问。 &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery.cookie.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var authUrl = &quot;http://auth.test.com:9000/login.action?callback=?&quot; if(!$.cookie(&#39;logined&#39;))&#123; $.ajax(&#123; url:authUrl, dataType:&#39;jsonp&#39; &#125;).done(function()&#123; window.console &amp;&amp; console.log(&#39;login.action successed&#39;) &#125;).fail(function()&#123; window.console &amp;&amp; console.log(&#39;login.action failed&#39;) &#125;).always(function()&#123; window.location.reload(); &#125;) &#125;else&#123; window.console &amp;&amp; console.log(&#39;using the exists info&#39;); &#125; window.console &amp;&amp; console.log(&quot;login status:&quot;,$.cookie(&#39;logined&#39;)) window.console &amp;&amp; console.log(&quot;session info:&quot;,$.cookie(&#39;sessionid&#39;)) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3.5 玩起来将上面的代码部署起来，浏览器访问类似这样的地址http://app.test.com/tests/cross-origin-cookie/app.html 3.5.1 可以获取认证的cookie，却无法将cookie传递到app.test.com。 将浏览器的隐私策略设置为“高” 直接将上面的代码部署 这样在IE8-11中再访问app.test.com 的这几个资源的时候，请求头中都不会存在认证cookie信息。 3.5.2 可以获取认证的cookie，同时可以将cookie传递到app.test.com 将浏览器的隐私策略设置为“高” 直接将上面的代码部署 去掉认证中心中关于P3P header的注释 这样在IE8-11中再访问app.test.com 的这几个资源的时候，请求头中都会存在认证cookie信息。 3.5.3 一般怎么都能行 将浏览器的隐私策略设置为“中高”及以下 不管是否有P3P的Header 这样在IE8-11中再访问app.test.com 的这几个资源的时候，请求头中都会存在认证cookie信息。 4 总结 我们可以通过编程的方式，使用P3P规范，满足浏览器的隐私策略要求，从而解决第三方cookie共享的问题。 推荐使用P3P的方式，设置HttpOnly的cookie来共享认证信息，这样更加规范。 不推荐使用传递信息的方式，这样有些反人类，每次开发都会写一段处理信息的代码，而不是简单地发一个请求。 5 引申如果是完全不同的域，比如是auth.testauth.com,和app.testapp.com，这样主域不相同的话。需要在认证成功之后，同时调用app.testapp.com下的一个请求，并将cookie信息传过去。这样就可以通过app.testapp.com域下的请求设置本域的cookie，然后再请求app.testapp.com下的页面就ok。 这里也是需要设置P3P头的，这里的原则是，谁设置第三方的cookie，谁就设置这个P3P头就行了。 P3P的内容远比这里看到的丰富的多，详情参考W3C P3P 5.1 参考资料 XMPP 官网 XMPP Wiki XMPP WikiPedia XMPP协议实现原理介绍 XMPP协议分析-原理篇 RFC 6120 XMPP Core RFC 3920 XMPP Core XMPP协议及实践 XMPP协议原理介绍 使用XMPP构建一个Web通知工具 实现可扩展消息传递和到场协议（XMPP） Solved: browser cookies vanish in IE8 when opening a new window to a different sub-domain Beware Cookie Sharing in Cross-Zone Scenarios IE8 losing session cookies in popup windows Seven Things You Should Known About IE 8 IE8 and Reliability IE8 and Loosely-Coupled IE (LCIE) How to get Internet Explorer to use cookies inside a frame to a third party site. Session lost in Iframe Cookie blocked/not saved in IFRAME in Internet Explorer W3C P3P W3C P3P Web Privacy with P3P The P3P Implementation Guide 第三方cookie丢失解决方案-P3P 通过P3P头实现跨域设置cookie PHP - 利用P3P实现跨域 关于p3p 简洁策略,以及浏览器的支持情况. Cookie, iframe 与 P3P 的那点事儿 实现跨域cookie共享(转载) 淘宝如何跨域获取Cookie分析 关于跨域获取cookie问题的解决 使用 P3P 规范让 IE 跨域接受第三方 cookie 用P3P header解决iframe跨域访问cookie cookie完全跨域 - 注意事项（header: P3P…） 关于PHP的header(“P3P: CP=CURa……”) Browser Security Handbook Same-origin policy limitations 《Web Site Privacy With P3P》","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"XMPP","slug":"XMPP","permalink":"http://rawbin-.github.io/tags/XMPP/"},{"name":"HTTP-BIND","slug":"HTTP-BIND","permalink":"http://rawbin-.github.io/tags/HTTP-BIND/"},{"name":"IE8","slug":"IE8","permalink":"http://rawbin-.github.io/tags/IE8/"},{"name":"Cookie","slug":"Cookie","permalink":"http://rawbin-.github.io/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"http://rawbin-.github.io/tags/Session/"},{"name":"P3P","slug":"P3P","permalink":"http://rawbin-.github.io/tags/P3P/"}]},{"title":"JavaScript跨域方法实例详解","slug":"dev-app/cors/2015-07-16-javascript-cross-origin","date":"2021-12-31T02:37:59.898Z","updated":"2021-12-31T02:37:59.898Z","comments":true,"path":"dev-app/cors/2015-07-16-javascript-cross-origin/","link":"","permalink":"http://rawbin-.github.io/dev-app/cors/2015-07-16-javascript-cross-origin/","excerpt":"","text":"1 同源与跨域1.1 基调一般情况下，禁止一个域从另一个域读取数据，却可以使用某些从其他域拿到的资源。比如说，允许一个域执行、渲染、应用从其他域获取到的脚本、图片、样式；同样，一个域可以展示从其他域获取的内容，比如在frame中显示html文档。网络资源也可以选择性的让其他域来读取自己的信息，比如使用Cross-Origin Resource Sharing，这种情况下访问权是针对单个域授权的。 同源策略限制消息从一个域发送到另一个域。比如说同源策略允许域间的GET和POST方式的HTTP请求，却禁止域间的PUT和DELETE方式的请求。同时，域在发送请求到自己时可以自定义HTTP请求头，发送请求到其他域不能自定义请求头。 同源策略的控制者是浏览器，浏览器可以控制不同域之间的资源的访问或相互操作，但不控制自己对不同域之间的资源的操作和访问。 1.2 什么是源RFC6454 规定一个资源的源由资源的URI中的（协议，主机，端口）这一个三元组来确定（IE中没有把端口纳入源的属性）。比如 https://www.test.com/test-script.js, 这个资源的源为（https, www.test.com, 443）。 对于一个被执行的脚本来说，他的源属性是执行这个脚本的资源的源属性。比如一个页面加载了来自另一个域的脚本，这个脚本执行的时候向页面所在域发送请求被视为同源。 相对路径和无法明确源属性的协议（javascript:,data:,about:blank）的资源的源，取将这些资源载入的页面的源。 IE没有将端口作为同源的组成部分，原因是IE历史垄断的市场占有率导致的历史遗留问题，IE8尝试在原生的XMLHTTPRequest中使用端口作为同源的一部分（标准化），但效果不好，一些依照老IE特性开发的站点，为了保持兼容性，继续使用了原有的MSXML 方式的XMLHTTPRequest。所以在IE8-11的版本都没有考虑端口作为同源的判断条件。 1.3 怎样算同源两个资源的组成源的属性（协议，主机，端口），完全一致，这两个资源才同源。这里如果两个资源的协议分别为http 和 https 被认为不同源。同时，即使两个资源的所属同一台服务器，但给出的域名分别为www.testA.com和www.testB.com，这两个资源也被认为是不同源。 1.4 同源策略同源策略是浏览器的核心安全策略，目的是将来自不同源的资源进行隔离，并控制不同源资源间的通信，从而减少安全威胁，增强安全性。 1.4.1 同源策略的规则1.4.1.1 不限制互联网的核心思想是资源共享，资源的相互访问应该被允许。 执行来自其他域的脚本（如使用&lt;script&gt;标签引用CDN的脚本,JSONP请求等） 渲染来自其他域的图片（如使用&lt;img&gt;标签引用图片服务器的图片资源） 应用来自其他域的样式（如使用&lt;link&gt;标签引用来自静态资源服务器的样式文件） 嵌入来自其他域的资源（使用&lt;iframe&gt;,&lt;frame&gt;加载来自其他域的资源） 重定向页面地址（Location对象地址的改变，使用&lt;a&gt;链接到其他资源） 数据发送（使用&lt;form&gt;向其他域提交数据） 多个子域的资源可以设置document.domain来改变所属域属性，来实现子域同域 window.name 属性是可写的，脚本可以随意设置，iframe的name属性，会作为iframe内部window对象的name属性初始值 窗体层级嵌套 可以通过parent.parent…的方式来访问祖先窗口，不受跨域限制 postMessage接口跨域通信 &lt;video&gt;,&lt;audio&gt;,&lt;object&gt;,&lt;embed&gt;,&lt;applet&gt;,@font-face可以加载其他域的资源 1.4.1.2 部分限制 跨域发送请求不能自定义HTTP Header 跨域发送请求不能使用PUT和DELETE方式，只能使用GET和POST 脚本可以访问一个不同源窗口的整体，而不能访问窗口的内部信息 CORS可以改变跨域的情形Access-Control-Allow-Origin,同源策略不放宽，跨域请求正常工作（设置为例外），不包含用户名和密码，不包含cookie和token，，响应的cookie会被丢弃，如果需要这些信息，需要设置XMLHttpRequest的withCredentials=true 1.4.1.3 完全限制 限制本地文件系统读写 限制cookie的访问 限制FileUpload元素的value属性，不能修改，甚至不能读取路径。 限制脚本对来自不同服务器的文档的读写（同源策略） 限制本地存储localStorage和sessionStorage和IndexedDB 限制XMLHTTPRequest请求的发送对象 1.5 跨域同源策略将来自不同源的资源进行了隔离，略在阻止安全威胁的同时，也对正常的访问带来了不便，我们也需要在安全策略下根据应用的需要进行不同源资源间的通信。 比如和iframe或frame中的资源的通信，与新窗口的资源的通信，与不同域的服务器之间的通信等。 比如同源策略限制了不同源的资源之间的互操作，当页面在iframe中加载不同源的内容的时候，想要根据页面内容动态调整iframe的高度的时候，就需要特殊的跨域操作。 在应用系统中做单点登录的时候，在进行当前应用的认证的时候需要向认证中心进行认证，这个时候也需要特殊的操作。 2 跨域方法汇总跨域的方法和浏览器安全问题都围绕着同源策略来展开，我们可以避开浏览器端的参与，从而规避同源策略带来的不便；同时我们也可以利用同源策略及其辅助接口开放的功能特性来实现跨越通信。 2.1 惹不起躲得起如果可以的话，可以将Web应用部署在同一个域下，这样可以很好的回避跨域的问题，我们常用的通过本域的后端接口包装，避免跨域的问题。 2.2 使用反向代理直接使用Web服务器apache，nginx等的反向代理的方式，将需要跨域的请求发送到当前域，在Web容器配置中做请求转发，像nginx这样的反向代理很擅长做这样的事情。 2.3 直面惨淡的人生2.3.1 动态不受限标签使用脚本动态创建&lt;script&gt;,&lt;img&gt;,&lt;link&gt;,&lt;iframe&gt;,&lt;frame&gt;等标签，在加入文档DOM后，浏览器会自动加载并解析渲染响应的资源。 2.3.2 JSONPJSONP原理其实是对&lt;script&gt;标签的一个利用，首先&lt;script&gt;标签加载资源是不受域限制的，然后浏览器会将&lt;script&gt;加载的内容当做脚本来执行。如果服务端返回的是类似于callback(&#123;&quot;data&quot;:[&#123;&quot;aa&quot;:1&#125;]&#125;)这样的内容，那么浏览器会将&#123;&quot;data&quot;:[&#123;&quot;aa&quot;:1&#125;]&#125;作为函数参数调用callback这个方法。这样就实现了从不同域加载数据。 2.3.3 Form提交Form提交不受限制，客户端可以以GET和POST的方式向服务端提交数据。 2.3.4 document.domain每一个窗体可以对当前窗体所属域进行微调，比如当前与名为app.test.com,则可以设置document.domain为test.com,也可以设置为app.test.com。通过将子域的document.domain属性均改为主域test.com,可以实现test.com下的任意子域app.test.com,auth.test.com,img.test.com等之间的通信。 修改为主域之后，子域的访问会带上父域的cookie，反之则不然 .test.com 和 test.com 效果一样,写成test.com 浏览器会理解为.test.com 2.3.5 window.namewindow.name 在加载不同的页面后还会存在，可以通过使用同一个window来加载需要通信的页面，通过共享window.name来进行数据通信。 2.3.6 CORS（Cross Origin Resource Sharing）通过协商的的HTTP Header让浏览器和服务端进行通信，来决定请求或者响应是否有效。 默认情况下，浏览器发送跨域请求不带认证信息（比如cookie,证书,代理认证信息等），withCredentials属性值为false 跨域需要withCredentials=true，同时服务端允许Access-Control-Allow-Credentials:true，同时Access-Control-Allow-Origin 值不能为* 2.3.7 postMessage这个是HTML5新增的页面间通信的接口，能够很好的解决iframe之间通信的问题。 2.4 Fetch2.4.1 带认证信息信息跨域 请求设置 credentials:true 响应设置Access-Control-Allow-Origin:http://origin.to.cross,Access-Control-Allow-Credentials:true 2.4.2 请求对象 mode值为same-origin,cors,no-cors(默认),navigate,websocket credentials mode 值为omit(默认),same-origin,include 2.4.3 响应对象 同域响应type值为 basic,cors，default（默认）,error 跨域响应type值为opaque,opaqueredirect,error 2.4.4 P3PP3P是处理Web应用中隐私数据的W3C标准,他可以通过添加HTTP 相应头的方式来通过浏览器对cookie的限制，解决第三方cookie传递的问题。 2.4.5 WebSocket这也是HTML5新增的浏览器和服务端通信的非HTTP通信的机制，它不受同源策略的限制，是解决跨域数据传输的解决方案。 在https的页面，无法发送ws://的请求，同http 3 不同角度看问题3.1 本地页面间通信 VS Browser-Server通信3.1.1 本地页面间通信 动态标签 postMessage window.name document.domain 3.1.2 Browser-Server通信3.1.2.1 GET 动态标签 JSONP Form提交 CORS P3P WebSocket fetch 3.1.2.2 POST Form提交 CORS P3P WebSocket fetch 3.2 单向通信 VS 双向通信3.2.1 单向通信 动态标签 JSONP Form提交 CORS P3P fetch 3.2.2 双向通信 window.name document.domain postMessage WebSocket 3.3 前端单独处理 VS 需要后端配合3.3.1 前端单独处理 动态标签 window.name document.domain postMessage fetch 3.3.2 需要后端配合 JSONP Form提交 CORS P3P WebSocket 3.4 全版本浏览器 VS 现代浏览器3.4.1 全版本浏览器 动态标签 JSONP Form提交 window.name document.domain P3P 3.4.2 现代浏览器 动态标签 JSONP Form提交 window.name document.domain P3P CORS postMessage WebSocket fetch 4 实例详解在本地玩起来，修改hosts文件增加如下的几个域名绑定作为测试: 127.0.0.1 source.test.com 127.0.0.1 target.test.com 127.0.0.1 source.test.org 127.0.0.1 target.test.org 本文所有实例都可以在 这里 下载 4.1 动态不受限标签4.2 JSONP4.2.1 源域 source.test.com/source-client.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jsonp Test&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // function JSONPCallback()&#123; // console.log(arguments[0]) // &#125; // function loadScript(url)&#123; // var script = document.createElement(&#39;script&#39;); // script.src = url; // document.head.appendChild(script); // &#125; // loadScript(&quot;http://target.test.org:9000/getData.do?callback=JSONPCallback&quot;) ​​​ //下面这个是jQuery风格的JSONP,更容易理解 function getJSON(url,callback)&#123; var script = document.createElement(&#39;script&#39;); var callbackName = &quot;ProxyFunc_&quot; + (new Date().getTime()) window[callbackName] = function()&#123; callback(arguments[0]); &#125;; script.onload = script.onratechange = function()&#123; if(this.readyState == &#39;complete&#39;)&#123; window[callbackName] = null; &#125; &#125; script.src = url.replace(&quot;JSONPCallback&quot;,callbackName); document.head.appendChild(script); &#125; getJSON(&quot;http://target.test.org:9000/getData.do?callback=JSONPCallback&quot;,function(data)&#123; console.log(data) &#125;) ​​ ​ ​ ​​ ​ 4.2.2 目标域 target.test.org:9000var http = require(&quot;http&quot;); var url = require(&quot;url&quot;); var server = new http.Server(); server.listen(9000); server.on(&quot;request&quot;,function(request,response)&#123; var paramDict = url.parse(request.url,true).query; var callback = paramDict.callback var retData = callback + &#39;(&#39; +&#39;&#123;&quot;status&quot;:&quot;success&quot;,data:&#123;&quot;name&quot;:&quot;test JSONP&quot;&#125;&#125;&#39; + &#39;)&#39;; response.end(retData); &#125;); 4.2.3 操作方法打开源域页面，在控制台查看拿到的数据 4.3 Form提交这个我不会写~ 4.4 window.name4.4.1 源域 source.test.com/source.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt; window.name test&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.name = &quot;source shared windowname&quot; alert(window.name) window.location.href = &quot;http://target.test.org/target.html&quot; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 4.4.2 目标域 target.test.org/target.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;window.name test&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; alert(window.name) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 4.4.3 操作打开源域页面看 即使跳转到目标域 数据依然存在 4.5 document.domain4.5.1 源域 source.test.com/source.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;document.domain test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://target.test.com/target.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.domain = &quot;test.com&quot;; window.onload = function()&#123; var doc = window.frames[0].document; console.log(doc.getElementById(&#39;tid&#39;).outerHTML); console.log(doc.body.innerHTML) setTimeout(function()&#123; doc.body.innerHTML = &quot;data from source.test.com&quot; &#125;,3000) &#125; &lt;/script&gt; &lt;/html&gt; 4.5.2 目标域 target.test.com/target.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;document.domain test&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.domain = &quot;test.com&quot; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;tid&quot;&gt;data of target.test.com&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 4.5.3 操作打开源域页面 查看源域操作目标域dom情况 4.6 CORS4.6.1 源域 source.test.com/client.html 源代码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;cross doamin resource sharing test&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText) &#125; &#125; xhr.open(&#39;POST&#39;,&#39;http://target.test.org:9000/getInfo.json&#39;,true) xhr.send(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 4.6.2 目标域 target.test.org:9000var http = require(&quot;http&quot;); var server = new http.Server(); server.listen(9000); server.on(&quot;request&quot;,function(request,response)&#123; //不加这个相应头，客户端会报错，无法跨越发请求 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;http://source.test.com&quot;) response.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/html;charset=UTF-8&quot;&#125;); response.write(&#39;msg: &quot;cross origin by cors&quot;&#39;); response.end(); &#125;); 4.6.3 操作方法4.6.3 操作方法 将两个文件部署上 浏览器打开源域的页面 在控制台和网络请求中查看交互数据 4.7 P3P这个用的相对较少，直接参考前面一篇 4.8 postMessage源域的页面嵌入加载了目标域的页面，并在两个域之间进行通信。 4.8.1 源域 source.test.com/source.html 源代码：&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;postMessage Test Source&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&#39;message&#39;,function(evt)&#123; console.log(&#39;source getmessage:&#39;,evt.data); evt.source.postMessage(&#39;##source message##&#39;,evt.origin); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://target.test.org/target.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 4.8.2 目标域 target.test.org/target.html 源代码:&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;postMessage Test Source&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&#39;message&#39;,function(evt)&#123; console.log(&#39;target getmessage:&#39;,evt.data); &#125;); window.parent.postMessage(&#39;##target message##&#39;,&#39;http://source.test.com&#39;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 4.8.3 操作方法 将两个文件部署上 浏览器打开源域的页面 在控制台可以看到两个页面交互的信息 4.9 WebSocket源域的页面中的脚本在页面加载时向目标域的服务发送信息，并接受服务返回的信息。 4.9.1 目标域 target.test.org:9000 源代码：var WebSocketServer = require(&#39;ws&#39;).Server; var socketServer = new WebSocketServer(&#123;port:9000&#125;); socketServer.on(&#39;connection&#39;,function(websocket)&#123; websocket.on(&#39;message&#39;,function(message)&#123; console.log(new Date().getTime(),&#39; received &#39;,message) websocket.send(&#39;###&#39; + message + &quot;###&quot;) &#125;); &#125;) 4.9.2 源域 source.test.com/index.html 源代码：&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;WebSocket Cross Origin Test&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var websocket = new WebSocket(&quot;ws://target.test.org:9000&quot;); websocket.onopen = function()&#123; console.log(&#39;websocket opened&#39;); websocket.send(&#39;I am opened&#39;); &#125; websocket.onmessage = function(evt)&#123; console.log(&#39;recevie message&#39;) console.log(evt.data) &#125; websocket.onclose = function()&#123; console.log(&#39;websocket closed&#39;) &#125; websocket.onerror = function()&#123; console.log(&#39;websocket meets error&#39;) &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 4.9.3 操作方式 npm install ws node 启动目标域的socket server 浏览器打开源域的页面 在控制台可以看到客户端和服务端交互的消息 5 安全相关6 参考资料 九种 “姿势” 让你彻底解决跨域问题 九种跨域方式实现原理（完整版） 前端跨域问题解决方案(基于node与nginx) 不同页面通信与跨域 RFC 6454 The Web Origin Concept 同源策略和跨域访问 W3C 同源策略 你真的会使用XMLHttpRequest吗？ 跨域资源共享 CORS 详解 JavaScript的同源策略 Same Origin Policy Part 0: Origins Same Origin Policy Part 1: No Peeking Same Origin Policy Part 2: Limited Write 我知道的跨域与安全 同源策略 同源策略理解 [CORS：跨域资源共享] W3C的CORS Specification JavaScript最全的10中跨域共享的方法 前端解决跨域问题的8种方案 JSONP原理详解 跨域方法汇总 跨域方法汇总 父子页面跨域通信的方法 父子页面跨域解决办法 优雅绝妙的Javascript跨域问题解决方案 JavaScript跨域访问解决方案 JS几种实用的跨域方法原理详解 JavaScript跨域总结与解决办法 JavaScript跨域解决方法大全 近乎完美的简单JS跨域解决方法 Post方式跨域上传文件 AJAX机制详解及跨域通信 跨域数据传输方法 异步上传文件并获得返回值（完全跨域） 异步上传文件并获得返回值（完全跨域） 同源策略以及cookie安全策略 Google浏览器安全策略 同源策略详解及绕过 理解 CORS (Cross-Origin Resource Sharing)","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"开发技术/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://rawbin-.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"前端","slug":"前端","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"window open ajax 弹窗 阻止 广告","slug":"dev-app/javascript/2015-07-10-window-open-ad","date":"2021-12-31T02:37:59.898Z","updated":"2021-12-31T02:37:59.898Z","comments":true,"path":"dev-app/javascript/2015-07-10-window-open-ad/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2015-07-10-window-open-ad/","excerpt":"","text":"1 浏览器阻止弹窗浏览器阻止恶意的弹窗（一般是广告弹窗），同时也将我们程序中想要的弹窗也干掉了。 现有阻止的规则是非用户操作的弹窗，包括程序自动弹窗和用户操作长时间后的弹窗（不同的浏览器表现不一样）。参考 2 解决办法 直接绑定用户操作事件打开窗口 在AJAX请求之前打开空窗口，在返回后再用返回的URL刷新窗口 使用同步AJAX请求并在回调中打开窗口（可能逃不出时间限制） 如果只想弹广告，直接监听页面点击，滚动事件，弹窗无惧 3 参考资料 window.open() 与浏览器阻止弹出窗口 window.open() 与浏览器阻止弹出窗口 弹窗解决最终奥义，人类再再也无法阻止弹窗了！ 如何绕过浏览器的弹窗拦截机制 你还敢使用window.open弹广告吗? 解决window.open() 详解 window.open被浏览器拦截的解决方案 解决弹出的窗口window.open会被浏览器阻止的问题（自定义open方法）","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"开发技术/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Ajax","slug":"Ajax","permalink":"http://rawbin-.github.io/tags/Ajax/"},{"name":"广告","slug":"广告","permalink":"http://rawbin-.github.io/tags/%E5%B9%BF%E5%91%8A/"}]},{"title":"反向AJAX 服务器推送技术","slug":"async/2015-07-10-reverse-ajax-push","date":"2021-12-31T02:37:59.897Z","updated":"2021-12-31T02:37:59.898Z","comments":true,"path":"async/2015-07-10-reverse-ajax-push/","link":"","permalink":"http://rawbin-.github.io/async/2015-07-10-reverse-ajax-push/","excerpt":"","text":"1 参考资料 HTTP的长连接和短连接 Web 通信 之 长连接、长轮询（long polling） HTTP keep-alive HTTP keep-alive 模式 Comet：基于 HTTP 长连接的“服务器推”技术 Node.js原理——Reverse Ajax（反向Ajax） Web端服务器推送技术原理分析及dwr框架简单的使用 反向 Ajax，第 1 部分: Comet 简介 Web实时通信参考 反向 Ajax，第 2 部分: WebSockets 反向 Ajax，第 3 部分: Web 服务器和 Socket.IO 反向 Ajax，第 4 部分: Atmosphere 和 CometD 反向 Ajax，第 5 部分: 事件驱动的 Web 开发 Comet实现的新选择 Java 反向AJAX DWR HTTP协议及其POST与GET操作差异 &amp; C#中如何使用POST、GET等 TCP、UDP、IP 协议分析 Linux Socket编程（不限Linux）","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"开发技术/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"AJAX","slug":"AJAX","permalink":"http://rawbin-.github.io/tags/AJAX/"},{"name":"服务器推","slug":"服务器推","permalink":"http://rawbin-.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8/"}]},{"title":"HTTP cookie session详解和对比","slug":"protocol/2015-07-09-http-cookie-session","date":"2021-12-31T02:37:59.897Z","updated":"2021-12-31T02:37:59.897Z","comments":true,"path":"protocol/2015-07-09-http-cookie-session/","link":"","permalink":"http://rawbin-.github.io/protocol/2015-07-09-http-cookie-session/","excerpt":"","text":"Web服务器对应的客户端（浏览器）与服务器之间的数据交换的间歇性较大（即数据传输具有突发性，瞬时性），并且网络访问之间是相对独立的（关联性较低）。请求时建连接、请求完释放连接，以尽快将资源释放出来。Keep-Alive解决每次访问同一资源都建立TCP连接的问题。无状态是指服务器不知道客户端是什么状态。HTTP无状态的特性严重阻碍了这些交互式应用程序的实现。两种用于保持HTTP状态的技术就应运而生了，一个是Cookie，而另一个则是Session。 1 事出有因1.1 HTTP无状态最初的互联网上只有带有超链接的文本文件，没有图片、视频、音频、动画等媒体。一次请求就返回一个文件的内容，再次请求要么还是这个文件的内容（刷新），要么返回新的文件的内容（点击超链接）。在这种情况下，一次请求，建立TCP（HTTP的低层协议）连接后，一次交互，获取内容，自然而然。客户端和服务器端的交互都是一次性的，不需要知道双方是否交互过。 这种情况就叫做HTTP的无状态，每次请求是独立的，不知道双方交互的状态。 1.2 HTTP得有状态随着互联网的发展，多媒体也出现在了网页中。这时候打开一个页面，除了需要获取原本的文本内容（HTML源码）外，还需要解析并加载页面中的多媒体元素，如图片，音视频等。这样一次请求之后，还会发送加载页内其他内容的请求，还会有很多次交互。举一个例子，我们需要从某个地方拿东西，以前的东西呢，一趟一次性可以拿完，每次去打暗号，过安检等一系列操作完成之后拿东西走人。现在不一样了，东西一次性可能拿不完了，第一趟去拿出来一个清单和轻的东西，同样打暗号过安检（TCP三次握手），拿完走人（TCP四次挥手）。然后按照这个清单里面的列表，在一次一次的来拿清单中还没拿的东西。比如拿一个图片还好，大不了再来一次暗号，安检。然而拿重的东西就比较麻烦了，比如加载一个视频，一次拿一点，暗号安检,，再一次拿一点，暗号安检。。。。。如此往复。拿东西的人就疯了。 搬东西的例子估计还好，毕竟都是后台自动完成交互的过程，如果涉及到用户操作，那么全世界都会疯了。比如，你打开淘宝，需要登陆；登入之后，点击个人中心，又需要登陆；点击地址管理，还需要登陆。。。。；就这样，你继续，不管你疯没疯，我反正快疯了。 一次暗号安检就是TCP的三次握手的过程，需要三次网络传输（Client-去-回-去-Server），HTTP的Keep-Alive(HTTP长连接)请求头就是解决拿同一个东西多次暗号安检的问题。 2 时代的要求上面我们知道了HTTP必须知道当前情况才行，所以就出现了两个帮助HTTP记录状态的东东，一个工作在服务端（Session），一个工作在客户端（Cookie）。 2.1 SessionSession是服务端用来保存客户端状态信息的对象，是一个动态的概念，数据放在内存里，按需不持久化，也有放数据库的。 2.1.1 第一次客户端向服务器端发送一个请求（打开并登陆淘宝）（会自动带上Cookie，这时候什么都没有）,服务端先检查请求Cookie中是否带有标志信息（一般为SESSION_ID），如果没有就把当前Session的ID（全局唯一标志）放入响应头，让客户端把这个放到Cookie里面。这个标志只是说明请求过。跟是否登陆并没有直接关系。还需要登录后，再记录这个SESSION_ID对应的客户端已经登陆，这样就能在已经登陆的情况下，不需要烦人的登陆了。 2.1.2 非第一次如果请求中Cookie中带有标志信息，则检查带来的是否与当前Session的ID一致，不一致自然是无效的。如果一致，再看看请求Cookie是否过期，是否是当前域等等。一系列的检查都通过后，就可以开开心心的返回内容了。要啥给啥，老熟人了。这会如果是已经登陆的状态，以后点击个人中心，地址管理等就不需要一次次的登陆了。 这样服务端就能记录客户端的状态了。 2.2 CookieCookie是客户端用户记录和存储与服务器的交互状态的机制，以前的存储方式基本是一个小的文本文件，放在每个浏览器各自的目录。现在Chrome用SQLite。各个版本的浏览器存储方式和存储路径页不一定一样，这里就不贴了。不管怎样，只要客户端能将这些交互信息存起来，并在我们需要用的时候能拿得到就行。 2.2.1 第一次第一次请求的时候空手套白狼，请求Cookie中什么都没有，请求回来服务器响应中就带了信息了（Set-Cookie），客户端只能知道这个SESSION_ID，不记录登陆状态。以后每次请求就带上这些Cookie信息。 2.2.2 非第一次客户端每次请求带上Cookie信息，服务端会根据这个SESSION_ID，来判断当前客户端的交互状态，是否是合法的ID，是否已经登陆等等。 2.3 其他用法上面说服务端可以在响应中向客户端存入信息到Cookie，Cookie的信息也会在请求中把Cookie带给服务端。 所以Cookie可以作为服务端和客户端数据传输的一种方式。 2.4 一些限制2.4.1 客户端限制上面我们说到了可以使用Cookie做数据传输。但是，但是，浏览器（客户端）对Cookie是有限制的，一方面是Cookie个数的限制（曾经有收IE6 20个，现代浏览器基本是50个），另一方面是单个Cookie内容大小的限制（一般为4K）。一方面可能回存在兼容性的问题，另一方面每次网络请求都会把这些信息带去带回，流量和性能也会受到影响。所以不建议使用较多的Cookie和使用Cookie传输较多的数据，具体可以按需权衡。 2.4.2 安全限制浏览器安全限制有一个同源策略，简单的说一个站点的资源URL的（协议，域名，端口）这个三元组组成的属性跟另一个站点的资源要完全一样，才认为这两个资源同源。同源的资源才被允许直接相互访问（不包括跨域方式）。 没有会怎样？如果没有同源策略，不如你登陆了淘宝，登陆了工商银行等等。当你无意间打开一个恶意站点或者是被恶意代码注入的站点（比如被挂了网页木马），这段代码假设就是简单的加载一个JavaScript文件（当然是自动执行），然后读取你机子上的（你所有访问过的站点）Cookie，简单的通过隐藏Iframe表单提交的方式发送到指定的远程主机。这样拿到这些信息的人都可以像你一样用你的认证信息，看你的东西（你已经登陆）。 限制了是什么样？简单的说，不同浏览器同时访问同一站点，Cookie不共享（废话，放的都不是同一个地方，用的不是同一个Cookie，可能内容相同）。统一浏览器的多个Tab对于同一站点来说是共享的，比如一个Tab登陆了，同时打开另一个Tab，查看其它的信息，同样是登陆状态。即使同一个浏览器，两个Tab不同站点，Cookie是不一样的（这也是废话）。 3 参考资料 http协议无状态含义 http 之Session 和 Cookie 浅析http协议、cookies和session机制、浏览器缓存 Session/Cookie机制详解 对Session和Cookie的理解 Cookie和Session的区别 Cookie和Session的比较 Cookie/Session机制详解 理解Cookie和Session机制 RFC 2109 RFC 2965","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机体系结构","slug":"计算机基础/计算机体系结构","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"计算机网络","slug":"计算机基础/计算机体系结构/计算机网络","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机基础/计算机体系结构/计算机网络/HTTP","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://rawbin-.github.io/tags/HTTP/"},{"name":"cookie","slug":"cookie","permalink":"http://rawbin-.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://rawbin-.github.io/tags/session/"}]},{"title":"","slug":"protocol/2015-07-09-http-get-post-compare","date":"2021-12-31T02:37:59.897Z","updated":"2021-12-31T02:37:59.897Z","comments":true,"path":"protocol/2015-07-09-http-get-post-compare/","link":"","permalink":"http://rawbin-.github.io/protocol/2015-07-09-http-get-post-compare/","excerpt":"","text":"layout: posttitle: “HTTP GET POST 对比 区别”categories: [计算机基础,计算机体系结构,计算机网络,HTTP]tags: [HTTP,GET,POST] 1 GET和POST对比1.1 相同点 都是HTTP的请求方法，都能携带数据 1.2 不同点 职责在HTTP的定义中，GET被用来做只读信息请求，POST用来写数据（这是HTTP协议对协议实现的建议），后来的REST风格也是基于这样的建议来表达的。但这样的建议不是一个强制的要求，所以现有HTTP的使用也是各式各样，使用GET同时做读写数据也行，完全是协议使用者的习惯。 表现形式GET方式的请求会将参数拼接在URL中，所以能很容易的在浏览器地址栏中看到请求的数据。而POST数据则完全是放在HTTP的请求体中，无法直观的看到。有说法是因为如此，两者存在安全性的差别，其实不然；同样的请求，只要数据不加密，他们的安全性是一样的，都是不安全的。随便用一个浏览器调试工具，或者网络抓包工具都可以看到完整的请求数据；差别在于多一步操作而已，所以无关乎安全，仅仅是一个能直接看到，一个直接看不到，表现形式不同而已。 可重现性如上，GET请求的参数会被拼接在URL中，所以你可以直接将这样的请求拷贝到任何其他地方，比如给小伙伴测试，或者将这个地址收藏起来。POST请求则不行，你需要专门的工具或者写专门的代码来做这事，才能复现相同的请求。 传输数据大小还是如上，由于GET参数会被拼接到URL中，对于浏览器来说，解析这个URL会有压力，所以会有长度限制（隐含的数据大小限制）；同时，服务器也有这样的麻烦。这不是HTTP协议本身对GET方法的限制，而是具体的应用的限制，如浏览器，服务端软件等。 浏览器缓存和历史记录再次如上，由于GET参数会被拼接到URL中，浏览器会把这整个被拼接的URL当做是一个页面，并对请求结果做缓存，以减少重复解析的开销。顺势，如果浏览器请求一个页面，自然会放到历史记录里面，所以缓存和历史记录在POST请求中都没有。 2 参考资料 HTTP 方法：GET 对比 POST 浅谈HTTP中Get与Post的区别 GET和POST有什么区别？ 也谈 GET 和 POST 的区别 详解HTTP中GET和POST的区别 GET和POST有什么区别？及为什么网上的多数答案都是错的。 HTTP POST GET 本质区别详解 不再以讹传讹，GET和POST的真正区别 关于GET和POST请求 HTTP协议及其POST与GET操作差异 &amp; C#中如何使用POST、GET等","categories":[],"tags":[]},{"title":"JavaScript prototype 原型 继承 理解","slug":"language/ecma-javascript/2015-07-07-javascript-object-prototype","date":"2021-12-31T02:37:59.897Z","updated":"2021-12-31T02:37:59.897Z","comments":true,"path":"language/ecma-javascript/2015-07-07-javascript-object-prototype/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2015-07-07-javascript-object-prototype/","excerpt":"","text":"1 一些相关概念理解1.1 相关概念 对象 哲学上万物皆对象，具体指人们要研究的客观事物及对其进行的主观抽象； 计算机理论思想中的对象是包含属性和相关行为的封装结构，是类的实例，类是对对象的抽象； 计算机程序的对象是一块具体的内存区域，可以是变量、函数、数据结构以及他们的组合。 JavaScript 中的对象指Object类型的实例，是属性的集合； 属性属性是对象，原始值、函数的容器。 原始值原始值是Undefined，Null,Boolean,Number,String中的任意一个类型的成员，他们是直接代表语言实现的最底层的数据；这是编译器使用的数据。 字面量顾名思义，就是在程序代码中看到的表示固定含义的特定的字符序列，如{}表示空对象,’2’表示字符串2，这是编码时使用的数据。 函数 函数是可调用的对象，是对象类型的成员 通过属性与对象关联的函数，或者说是作为对象属性的函数，称做对象的方法； 创建和初始化对象的函数（与new一起使用）称做构造函数或构造器； 原型 广义上来讲，原型是指事物的初始形态，是一种模型或样板； JavasScript中的原型 可以指函数的prototype属性名，函数的prototype属性值（原型对象） 可以指对象的原型属性__proto__(这个属性在JavaScript引擎中使用，在ES6之前作为内部属性存在，在ES6中被标准化和显式的使用) __proto__作为对象的属性指向他的原型，prototype作为函数的属性指向他的原型。函数也是对象，所以函数可能同时拥有这两个属性。 1.2 概念理解1.2.1 一切皆为对象 JavaScript是弱类型的语言，会自动进行相应的类型转换（隐式类型转换）在JavaScript中，原始值没有对应的方法，原始值在执行的过程中会被自动转换成对应类型的对象再进行运算和执行。比如字符串原始值”abcde”没有任何方法，会被转换成String对象，然后拥有String.prototype这个对象上定义的方法。 函数也是对象（上面不是说了么，函数是可调用的对象）看看构造器的定义，创建和初始化对象的函数。首先构造器是函数，构造器创建的是对象，那么Function构造器所创建的实例也是对象。 typeof (new Function()) === &#39;function&#39; // true (new Function()) instanceof Function // true (new Function()) instanceof Object // true Function instanceof Object // true JavaScript对象继承树所有对象都继承自Object.prototype Object.prototype.__proto__ // null Function.prototype.__proto__ === Object.prototype // true 1.2.2 函数是第一级对象 函数是基本数据类型使用typeof运算符进行求值，可得到undefined,null,string,boolean,number,object,function这几种类型，这里函数和object作为并列的类型出现，同时对象又是由构造器（函数）创建的，虽然函数也是object类型的成员，但它同时拥有自己的typeof值。 函数可以跟作为参数值传递（回调函数） 1.2.3 对象构造过程 一般对象创建过程构造函数创建对象时，新建一个空对象，并将当前this值设置为这个对象的引用；同时将这个对象的__proto__属性设置为构造函数（构造器）的prototype 属性;设置对象的constructor属性为构造函数的原型的prototype属性; var proto = &#123;name: &#39;first proto&#39;&#125;; function Foo()&#123; this.val = &#39;test val&#39; &#125; Foo.prototype = proto; var obj = new Foo(); obj.__proto__ === proto; // true obj.__proto__ === Foo.prototype // true obj.constructor === Foo.prototype.constructor // true 1.2.4 原型继承 对象属性的访问还是用上面的例子 var proto = &#123;name: &#39;first proto&#39;&#125;; function Foo()&#123; this.val = &#39;test val&#39; &#125; Foo.prototype = proto; var obj = new Foo(); obj.val // &#39;test val&#39; obj.name // &#39;first proto&#39; 对象的属性，一部分来自于本身构造函数中构建的属性，另一部分来自于构造函数的原型proto，这样我们通过构造函数的prototype属性实现了数据（proto）的复用。 JavaScript对象属性和方法的查找过程是先在对象本身的属性中查找，如果没找到就在对象原型（__proto__）中查找，直到找到属性或者找不下去（找到原型链末端__proto__ === null）为止。 原型式继承 function Creature()&#123; this.tag = &#39;creature&#39; &#125; function Animal()&#123; this.type = &#39;Animal&#39; this.say = function()&#123; throw Error(&#39;this must be implemented&#39;) &#125; &#125; Animal.prototype = new Creature(); function Cat()&#123; this.legs = 4; this.say = function()&#123; console.log(&#39;miao miao&#39;) &#125; &#125; Cat.prototype = new Animal(); function Dog()&#123; this.type = &#39;Dog&#39;; this.legs = 4; this.say = function()&#123; console.log(&#39;wang wang&#39;) &#125; &#125; Dog.prototype = new Animal(); var cat = new Cat(); console.log(cat.type) // Animal cat.say(); // miao miao var dog = new Dog(); console.log(dog.type); // Dog dog.say(); //wang wang dog.tag // creature 原型链在上例中存在一条访问路径dog.__proto__.__proto__.__proto__.__proto__.__proto__查找dog.type 的时候 直接在对象中找到了自有属性 dog.type，返回的是dog.type查找dog.tag 的时候访问的就是dog.__proto__.__proto__,返回的是Animal.prototype.tag查找dog.no 的时候访问的是dog.__proto__.__proto__.__proto__.__proto__.__proto__，返回的是undefined这条查找属性和方法的访问路径，就叫原型链。从上面可以看出，原型链长了不太合适，查找效率太低（尤其是对于那些根本不存在的属性，他们会遍历整条原型链而最终返回的还是undefined）。 2 参考资料 理解JavaScript系列 深入理解JavaScript系列 What is Object? 什么是对象，为什么要面向对象，怎么才能面向对象？ You Don’t Know JS: this &amp; Object Prototypes JavaScript Types ECMAScript 5.1 中文版 ECMAScript标准 JavaScript原型和继承 JavaScript原型继承工作原理 深入理解JavaScript系列（5）：强大的原型和原型链 W3School ECMAScript继承机制实现 理解JavaScript Function与Object","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"开发技术/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"http://rawbin-.github.io/tags/Web%E5%89%8D%E7%AB%AF/"},{"name":"前端基础","slug":"前端基础","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"原型","slug":"原型","permalink":"http://rawbin-.github.io/tags/%E5%8E%9F%E5%9E%8B/"}]},{"title":"JavaScript作用域 闭包 理解","slug":"language/ecma-javascript/2015-07-08-javascript-scope-closure","date":"2021-12-31T02:37:59.897Z","updated":"2021-12-31T02:37:59.897Z","comments":true,"path":"language/ecma-javascript/2015-07-08-javascript-scope-closure/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2015-07-08-javascript-scope-closure/","excerpt":"","text":"1 相关概念理解1.1 作用域顾名思义，作用域就是起作用的范围，可访问的范围，有效的范围。 1.2 词法作用域词法就是单词的形式和用法，词法作用域就是由词法确定的作用域。JavaScript的作用域是词法作用域，可以等同于静态作用域，意指只需要读取源代码进行静态分析（不需要代码执行）就能确定的作用域。 1.3 变量作用域一提到变量作用域，很快能想到的两个词“全局变量”和“局部变量”，是根据变量的作用域属性来对作用域进行限制和描述。 1.4 JavaScript作用域PS：JavaScript有关执行作用域相关的信息在ECMAScript标准中目前都会有相应的说明，在标准1，2，3版总在第十章，前三版差别不是很大，可以直接看第三版。第五版可以直接看2011年的版本，然后就是2015版（第六版）。变量对象，活动对象这些概念在前三版中有提及，现在的资料里面提到的也是这些。 1.4.1 局部作用域（地方）JavaScript中的局部代码就是函数内部的代码，现在包括函数内部的函数，函数内部的表达式，早期的JavaScript不支持内部函数，所以只有函数代码是局部代码。局部代码确定的作用域就是局部作用域。 1.4.2 全局作用域（中央）JavaScript的全局代码是除函数内部代码之外的代码。他们确定的作用域就是全局作用域。全局作用域由JavaScript内置全局对象来表达，比如我们常说的浏览器端的window宿主对象，window对象是全局对象的一个属性，他的值是全局对象的一个引用，是暴露出来的全局对象。 1.5 执行上下文这里要多废话一段，看了好些资料，说的都是执行上下文堆栈。这里需要做一些解释。 堆是堆（Heap），是栈（Stack）。栈是操作系统自动进行维护的一个保存临时状态的逻辑结构，堆一般是程序代码来维护的结构。 栈比堆有更高的优先级使用更低级别的缓存（越低级别的缓存速度越快，有更高的命中率，如CPU的一级缓存比二级缓存快，二级比三级快，缓存比物理内存块）。栈有更小的内存限制，一般为几M（可配置），而堆的限制最大可以达到物理内存的可用大小，现在一般为N个G吧。 这里说的堆栈是说，执行上下文的数据，一部分在栈中，一部分在堆上。比如定义一个数组，一万个元素。都是单独申请一块内存来存放，同时把这个内存的首地址（指针）放入栈中。而其他简单的数据比如一个简单的循环变量，那就直接放入栈中。 1.5.1 变量对象变量对象，是全局执行上下文对象的一个属性，记录当前作用域的所有变量和函数的定义。 1.5.2 活动对象活动对象，是局部执行上下文的一个属性（地方特色），用来记录当前作用域的所有变量和函数的定义，函数的参数信息和其他内部的函数执行相关的信息。 1.5.3 全局执行上下文全局上下文初始化在代码执行之前（废话），最可能是预编译阶段，初始化全局对象，包含JavaScript的全局对象的属性，各种内置构造函数，String，Boolean，Number，以及各种全局函数，parseInt, parseFloat, 记忆各种全局属性undefined,Infinite等。 全局上下文包含几个特别的属性，window，this，都分别指向全局执行上下文本身（引用）；变量对象是全局上下文中所有的变量和函数声明的集合（也是一个对象）。在JavaScript中对象是一个key：value的集合，所以会出现变量和同名函数相互覆盖的情况。 全局上下文初始化的时候，会带上变量的声明和函数的声明，也就是说在变量对象里面有跟所有全局变量名一样的属性，以及跟全局函数名一致的属性，全局变量名的属性没有赋值（为默认的undefined）,全局函数名对应的属性值就是函数的引用。 所以这里是在代码执行前将所有要定义的变量做了一次统一声明，这就是JavaScript作用域里面经典的“声明提前”的原因。 可以用如下JavaScript示意，以帮助理解,有如下代码： var a = 10; function globalFunc(a,b)&#123; var inner1Var = 10; function inner1Func()&#123; var inner2Var = 20; &#125; &#125; globalFunct(100,200); var GLOBAL_CONTEXT = &#123; parseInt：PARSEINT_REF, ......//其他全局函数 String：STRING_REF, ......//其他全局构造器 undefined:undefined, ......//其他全局属性 this: GLOBAL_CONTEXT, window: GLOBAL_CONTEXT, VariablesObject:&#123; a: &#123; value: undefined // 预编译时不赋值，执行到具体代码时赋值。 attributes:&#123; writable:true, configurable:true, enumerable:true &#125; &#125;, f:&#123; value:globalFunc_REF, attributes:&#123; writable:true, configurable:true, enumerable:true &#125; &#125; &#125;, OutterScope:null &#125; 1.5.4 局部执行上下文还是上面的代码， 除了全局上下文之外，还有局部的上下文对象。每次进入一个局部上下文之前，类似于下面的一个对象就会被创建，this值，变量对象的值被初始化。 var INNER1_CONTEXT = &#123; this: GLOBAL_CONTEXT, VariablesObject: &#123; a:&#123; value:undefined, //定义的时候不会初始化，在调用的时候由调用者在进入执行上下文之前初始化为200 attributes:&#123; writable:true, configurable:false, enumerable:true &#125; &#125;， b:&#123; value:undefined, //定义的时候不会初始化，在调用的时候由调用者在进入执行上下文之前初始化为200 attributes:&#123; writable:true, configurable:false, enumerable:true &#125; &#125;， arguments:&#123; &#39;0&#39;:&#123; value:undefined, attributes:&#123; writable:false, configurable:false, enumerable:true &#125; &#125;， &#39;1&#39;:&#123; value:undefined, attributes:&#123; writable:false, configurable:false, enumerable:true &#125; &#125;， length: 2, callee: globalFunc_REF &#125; &#125;, OutterScope:GLOBAL_CONTEXT &#125; ​​ var INNER2_CONTEXT = { this: GLOBAL_CONTEXT, VariablesObject: { ……//同 INNER1_CONTEXT }, OutterScope:INNER1_CONTEXT } 1.5.5 作用域链INNER2_CONTEXT.OutterScope.OutterScope === GLOBAL_CONTEXT INNER2_CONTEXT.OutterScope.OutterScope.OutterScope === null 像上面这种以OutterScope来访问外部作用域的访问路径，叫做作用域链。 1.6 闭包1.6.1 相关的说法： 闭包，是指语法域位于某个特定的区域，具有持续参照（读写）位于该区域内自身范围之外的执行域上的非持久型变量值能力的段落。这些外部执行域的非持久型变量神奇地保留它们在闭包最初定义（或创建）时的值（深连结） 闭包是在其词法上下文中引用了自由变量的函数。 在实现深约束时，需要创建一个能显式表示引用环境的东西，并将它与相关的子程序捆绑在一起，这样捆绑起来的整体被称为闭包。 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中成为“闭包” This combination of a function objectand a scope (a set of variable bindings) in which the function’s variables are resolvedis called a closure in the computer science literature 1.6.2 什么是闭包上面看了这么多的概念，其实我们想要的是一个关键词，这里面有的关键词有:段落，函数，程序和环境，特性。还是很难区分哪。 我们先来看看闭包产生的原因： 首先是内部的作用域能引用外部作用域的数据，这是JavaScript词法作用域特性。 其次是被引用的数据不能被回收，这是JavaScript的垃圾回收机制。 再次函数作为数据传递，这里是一个数据保持的概念，闭包需要能保持本该被回收的数据，比如函数内部的变量。 如上可以看出，闭包是一个在运行期的一个概念，是一个动态的概念。 于是我们可以给闭包下一个定义：闭包是执行时具有独立上下文的词法结构及其持有的内部和外部数据组成的结构。 1.6.3 闭包的使用陷阱需求：循环创建一组输出序号值的函数。 实现代码： var funcs = [],i = 0; for(i = 0; i &lt; 5; i++){ funcs[i] = function(){ console.log(i) } } funcs[2](); // 5 出现这种情况的原因是，匿名函数内引用的是同一个变量i，在执行的时候i的值是循环后的最终值5 如何解决上面的问题，根据闭包的特性，这里的想要将各个循环状态的值保留下来，就需要创建一个执行上下文才能利用闭包的特性 var funcs = [],i = 0; for(i = 0; i &lt; 5; i++)&#123; funcs[i] = (function(i)&#123; return function()&#123; console.log(i) &#125; &#125;)(i); &#125; funcs[2](); // 2 或者可以使用下面的方式 var funcs = [],i = 0; for(i = 0; i &lt; 5; i++)&#123; funcs[i] = (function()&#123; var j = i; return function()&#123; console.log(j) &#125; &#125;)(); &#125; funcs[2](); // 2 在ES6中，我们可以用let来避免多层闭包（这种方式还是比较low） &quot;use strict&quot;; var funcs = [],i = 0; for(i = 0; i &lt; 5; i++)&#123; let j = i; funcs[i] = function()&#123; console.log(j) &#125; &#125; funcs[2](); // 2 当然，既然有ES6，我们就可以有更优雅的方式（注意看区别哈）。 &quot;use strict&quot;; var funcs = []; for(let i = 0; i &lt; 5; i++)&#123; funcs[i] = function()&#123; console.log(i) &#125; &#125; funcs[2](); // 2 这应该就是我们最初的代码想实现的效果，然而在ES6之前基本都是词法作用域（除了try-catch算块作用域），所以无法达到我们想要的效果。在ES6中let 引入了块作用域，使得i本身是for循环块中的一个局部变量，在闭包中被保持。 2 参考资料 了解JavaScript执行上下文 从JS垃圾回收机制和词源来透视闭包 深入理解JavaScript系列：JavaScript核心 深入理解JavaScript系列（11）：执行上下文（Execution Contexts） 深入理解JavaScript系列（12）：变量对象（Variable Object） 深入理解JavaScript系列（14）：作用域链(Scope Chain) 深入理解JavaScript系列（16）：闭包（Closures） JavaScript核心 You Don’t Know JS: Scope &amp; Closures 理解JavaScript系列 深入理解JavaScript系列 JavaScript 变量作用域(续) JavaScript 作用域链解析 JavaScript变量作用域之殇 javascript 执行环境，变量对象，作用域链 理解Javascript_15_作用域分配与变量访问规则,再送个闭包 Closure 闭包的概念、形式与应用 学习JavaScript闭包 JavaScript 闭包 概念实例 详解js闭包 编程语言中的闭包 什么是闭包，我的理解 什么是闭包 JavaScript执行过程","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"开发技术/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"http://rawbin-.github.io/tags/Web%E5%89%8D%E7%AB%AF/"},{"name":"前端基础","slug":"前端基础","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"作用域","slug":"作用域","permalink":"http://rawbin-.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"闭包","slug":"闭包","permalink":"http://rawbin-.github.io/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"HTML script defer async 区别 对比","slug":"async/2015-07-05-javascript-async-defer","date":"2021-12-31T02:37:59.896Z","updated":"2021-12-31T02:37:59.896Z","comments":true,"path":"async/2015-07-05-javascript-async-defer/","link":"","permalink":"http://rawbin-.github.io/async/2015-07-05-javascript-async-defer/","excerpt":"","text":"1 I. 外引用 script脚本加载过程1.1 A. 普通script 引用（不带defer，async）浏览器从头到尾按顺序解析，并占用式(阻塞解析)下载脚本，并执行，完成之后继续往下进行。 1.2 B. 只带defer的script引用浏览器启用新的线程或进程异步下载（不阻塞解析），并在下载完成后不立即执行，等页面解析完成后再按解析的顺序执行。这样浏览器解析的脚本的顺序跟脚本最终执行的顺序是一致的。 时间点：(firefox chrome) inline脚本&gt;defer脚本-&gt;DOMContentloaded-&gt;onload 1.3 C. 只带async的script引用浏览器启用新的线程或进程异步下载（不阻塞解析），下载完成后立即执行。这意味着文件的执行和代码的先后不是强关系，可能因为网络的原因或者文件大小等因素导致代码执行顺序跟浏览器解析到的代码的顺序不一致。 时间点:(firefox chrome) inline脚本-&gt;DOMContentloaded-&gt;async脚本-&gt;-&gt;onload 1.4 D. 同时带defer和async的script 引用 defer 是html4.x就存在的属性，浏览器支持广泛 async 是html5.x才存在的属性，较老旧的浏览器可能不支持（ie8） 同时存在时，优先考虑async模式，如果不支持再考虑defer 2 II. 行内script加载过程分块解析块，在一个块内，先进行变量声明和函数声明的预解析，然后再按顺序解析。 2.1 参考资料 script的defer和async defer和async的区别 script的defer和async 引用JavaScript文件时的两个属性defer和async script的defer和async Asynchronous and deferred JavaScript execution explained Asynchronous script execution and GPU Acceleration by default w3c html 4.01 script w3c html 5.01 script 一个defer async的测试","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"开发技术/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"http://rawbin-.github.io/tags/Web%E5%89%8D%E7%AB%AF/"},{"name":"前端基础","slug":"前端基础","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"async","slug":"async","permalink":"http://rawbin-.github.io/tags/async/"},{"name":"defer","slug":"defer","permalink":"http://rawbin-.github.io/tags/defer/"}]},{"title":"avalon 原理 源码分析","slug":"framework/2015-07-01-avalon-source","date":"2021-12-31T02:37:59.896Z","updated":"2021-12-31T02:37:59.896Z","comments":true,"path":"framework/2015-07-01-avalon-source/","link":"","permalink":"http://rawbin-.github.io/framework/2015-07-01-avalon-source/","excerpt":"","text":"1 参考资料 前端MVC框架源码分析Backbone,Avalon 前端MVVM框架avalon揭秘 avalonJS-源码阅读（一） avalonJS-源码阅读（二） avalonJS-源码阅读（三） ​","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"avalon","slug":"avalon","permalink":"http://rawbin-.github.io/tags/avalon/"}]},{"title":"JavaScript this 理解","slug":"language/ecma-javascript/2015-07-06-javascript-this","date":"2021-12-31T02:37:59.896Z","updated":"2021-12-31T02:37:59.896Z","comments":true,"path":"language/ecma-javascript/2015-07-06-javascript-this/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2015-07-06-javascript-this/","excerpt":"","text":"1 thisJavascript中的this是当前执行上下文对象的一个属性，在创建执行上下文时生成，在执行上下文中不可改变。但会随着不同执行上下文的不对变化而改变。 这也是问题所在。 2 严格模式以 “use strict”; 指定的JavaScript解析模式在非严格模式下，this在没有具体的指向的时候会指向全局对象，即浏览器运行时的window对象。严格模式下，不会进行这样的转换，在this没有指向的时候，就赋值为undefined。 3 非严格模式目前是默认的模式，即不加任何限制的模式。非严格模式会因为JavaScript的作用域的和执行上下文的变化导致一些难以排查的问题，因此目前JavaScript从5.1开始逐渐向严格模式倾斜。 4 有没有银弹？JavaScript中的this取决于函数的调用环境和调用方式，后者比前者更重要。 4.1 JavaScript this 确定规则（从前到后优先级逐渐降低） 如果使用了new 关键字，this 就是新创建的这个对象； 如果使用了函数的abc方法（apply，bind，call），this即为这个明确指定的对象。 如果函数使用了明确对象来调用（对象方法），this为这个调用对象。 默认，严格模式this为undefined，非严格模式为全局对象（ES6的箭头函数会默认使用外层作用域的this） 4.2 如何理解？（测试的结果） new关键字调用构造函数时，优先级最高，及时函数被明确绑定到对象上，也是会指向新创建的对象。 function foo(something) &#123; this.a = something; &#125; var obj1 = &#123;&#125;; var bar = foo.bind( obj1 ); bar( 2 ); console.log( obj1.a ); // 2 var baz = new bar( 3 ); console.log( obj1.a ); // 2 console.log( baz.a ); // 3 明确绑定了对象的方法，使用的this就是该对象 function foo() &#123; console.log( this.a ); &#125; var obj = &#123; a: 2 &#125;; var bar = function() &#123; foo.call( obj ); &#125;; bar(); // 2 setTimeout( bar, 100 ); // 2 // hard-bound `bar` can no longer have its `this` overridden bar.call( window ); // 2 对象方法调用，this指向，该对象，纯函数调用 function foo() &#123; console.log( this.a ); &#125; var obj2 = &#123; a: 42, foo: foo &#125;; var obj1 = &#123; a: 2, obj2: obj2 &#125;; obj1.obj2.foo(); // 42 默认的纯函数调用，回调调用等可认为是window在进行方法调用 function foo() &#123; console.log( this.a ); &#125; function doFoo(fn) &#123; // `fn` is just another reference to `foo` fn(); // &#125; var obj = &#123; a: 2, foo: foo &#125;; var a = &quot;oops, global&quot;; // `a` also property on global object doFoo( obj.foo ); // &quot;oops, global&quot; ES6 箭头函数调用，默认会使用当前环境中的局部this值，而不是全局this默认值 var count = 100; function foo()&#123; this.count++; console.log(this.count) &#125; var obj = &#123; count: 0, cool: function coolFn() &#123; setTimeout(function()&#123; this.count++; console.log(this.count) //window.count &#125;,1000) var self = this; setTimeout(function()&#123; self.count++; console.log(self.count) //obj.count &#125;,1000) setTimeout( () =&gt; &#123; this.count++; console.log(this.count) //obj.count &#125;,1000) &#125; &#125;; obj.cool(); 5 参考资料 理解JavaScript系列 深入理解JavaScript系列 深入理解JavaScript系列(13): This?Yes,this! You Don’t Know JS: this &amp; Object Prototypes JavaScript严格模式详解 JavaScript this工作原理及注意事项 深入浅出JavaScript中的this JavaScript的this用法 MDN this JavaScript this关键字详解 理解JavaScript Function Object JavaScript 的Function与Object浅析 Javascript中Function,Object,Prototypes,__proto__等概念详解 Js中Prototype、__proto__、Constructor、Object、Function关系介绍","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"开发技术/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"http://rawbin-.github.io/tags/Web%E5%89%8D%E7%AB%AF/"},{"name":"前端基础","slug":"前端基础","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"this","slug":"this","permalink":"http://rawbin-.github.io/tags/this/"}]},{"title":"设计模式","slug":"architecture/2015-06-20-gof-design-pattern","date":"2021-12-31T02:37:59.895Z","updated":"2021-12-31T02:37:59.895Z","comments":true,"path":"architecture/2015-06-20-gof-design-pattern/","link":"","permalink":"http://rawbin-.github.io/architecture/2015-06-20-gof-design-pattern/","excerpt":"","text":"1 UML用例图表示方式 扩展 实线和箭头指向被扩展方 包含 实线和箭头指向被包含方 2 UML类图表示方式 继承、泛化 用实线和空心三角表示，指向父类 接口实现 用虚线和空心三角表示，指向接口 基本聚合 空心棱形指向父类，实线和箭头指向子类 组合聚合 实心棱形指向父类，实线和箭头指向子类 依赖 虚线和箭头指向被依赖方 单向关联 实线和箭头指向被关联方 双向关联 实线连接 3 设计模式比较总结 模式类型 中文名称 英文名称 本质 意图（定义） 实现方式 创建型 单例模式 Singleton 控制实例数量 保证一个类只有一个实例，并提供一个访问它的全局访问点 利用缓存和延迟加载的思想来实现实例数量的控制，需要注意线程安全性 创建型 工厂方法 Factory Method 延迟到子类来选择实现 定义一个用于创建对象的接口，让子类决定实例化哪一个类，它使一个类的实例化延迟到子类 工厂方法的判断逻辑在客户端里面，选择用什么样的工厂生产产品，修改是修改客户端 创建型 简单工厂 Simple Factory 选择实现 提供一个创建对象实例的功能，而无须关心其具体实现，被创建实例的类型可以是接口，抽象类也可以是具体的类 简单工厂方法的判断逻辑在工厂里面，只需要传入需要生成的产品类型，修改是修改工厂类 创建型 抽象工厂模式 Abstract Factory 选择产品簇的实现 提供一个创建一系列相关或者相互依赖对象的接口，而无需指定具体的类 抽象工厂中创建一系列的抽象产品，这些产品是有关联的 创建型 构建器模式 Builder 分离整体构建算法和部件构造 将一个复杂对象的构建和他的表示分离，是的同样的构建过程可以创建不同的表示 构建器负责构建产品部件和装配，指导者扶着产品构建 创建型 原型模式 Prototype 克隆生成对象 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象 通过克隆已知对象来生成新的对象 结构型 外观模式 Facade 封装交互，简化调用 为子系统的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 单向调用的封装和复杂度屏蔽 结构型 适配器模式 Adapter 转换匹配，复用功能 将一个类的接口转换为客户希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 复用已有的功能的基础上实现接口适配 结构型 装饰者模式 Decorator 动态组合 动态透明地给一个对象添加一些额外的职责，比生成子类更灵活 装饰者对象与被装饰着实现了相同的接口，使用对象组合的方式沿用被组合对象的功能并进行增强和改造 结构型 桥接模式 Bridge 分离抽象和实现 将抽象部分与实现部分分离，是他们可以独立变化 将两个同时变化的维度独立出来，让抽象部分用用实现部分的接口对象，维护桥接关系，并用组合的方式把两个维度连接起来 结构型 组合模式 Composite 统一叶子对象和组合对象 将对象组合成树形结构便是“部分-整体”的层次结构，尊组合模式使得用户对单个对象和组合对象的使用具有一致性 使用抽象的组件类，让他可以代表尊对象和叶子对象，这样在客户端就不需要区分对象组合对象和叶子对象 结构型 代理模式 Proxy 控制对象访问 为其他对象提供一种代理以控制对这个对象的访问 创建一个代理对象，去代表真实的对象，对客户端使用没有影响 行为型 中介者模式 Mediator 封装交互 用一个中介对象来封装一系列的对象交互，中介者使得个对象不需要显式的相互引用，从而使其耦合松散，而且可以独立的改变他们之间的交互 将各个交互对象之间的交互逻辑封装到中介者中，需要交互时向中介者发送请求 行为型 观察者模式 Observer 触发联动 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于他的对象得到通知并被自动更新 观察者管理被观察者对象，并区分群体进行消息通知 行为型 命令对象 Command 封装请求 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志以及支持可撤销的操作 封装命令对象，实现统一的操作接口 行为型 迭代器模式 Iterator 控制访问聚合对象中的元素 提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露该对象的内部表示 把对聚合对象的遍历和访问从聚合对象中分离出来放入单独的迭代器中 行为型 解释器模式 Interpreter 分离实现，解释执行 给定一个语言，定义他的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子 客户端创建多个解释器对象组成抽象语法树，对语言进行解释操作，粒度细化到了一条语法规则对应一个解释器，应对语法的变化 行为型 模板方法模式 Template Method 固定算法骨架 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤 用抽象类来定义模板，使得可以部分重写模板的功能，这也是不用接口的原因 行为型 状态模式 State 根据状态来分离和选择行为 允许一个对象在其内部状态改变时改变他的行为 分离状态的行为，通过维护状态的变化来调用不同状态对应的功能，状态和行为是绑定的 行为型 策略模式 Strategy 分离算法，选择实现 定义一系列的算法，把它们一个个封装起来，并使他们可以相互替换，使算法可以独立于他的客户而变化 策略类实现相同的接口，使得他们之间可以相互替换 行为型 备忘录模式 Memento 保存和恢复内部状态 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先保存的状态 通过保存的方式实现恢复的目的 行为型 享元模式 Flyweight 分离与共享 利用共享技术有效地支持大量细粒度对象 将对象的状态分为内部和外部两部分，内部为不变的状态，外部为变化的状态，将不变的部分进行共享，达到减少对象数量和减少存储的目的 行为型 责任链模式 Chain of Responsibility 分离职责，动态组合 使多个对象都有机会处理请求，避免发送者和接受者之间的耦合关系，将处理请求的对象形成一条链，并沿着链传递请求，直到有一个对象处理了请求 把职责分开，每个处理对象只需要判断是否符合自己的职责范围，一旦被处理就返回不继续传递 行为型 访问者模式 Visitor 预留通路，回调实现 在不改变现有类的前提下，添加新的功能或操作 在抽象类中添加接受访问者的方法，把自身传给访问者，不改变具体的类；访问者类中实现访问具体类的方法，调用传入对象的方法 4 参考资料 精简版设计模式，设计模式类图 GOF23种设计模式精简版描述 设计模式的总结 设计模式总结，设计原则，精简，详细 设计模式大杂烩 23种设计模式对比与总结 总结23种设计模式应用场景 设计模式之总结和回顾","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://rawbin-.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"命令行命令错误解决","slug":"dev-env/2015-06-20-cmd-error-resolve","date":"2021-12-31T02:37:59.895Z","updated":"2021-12-31T02:37:59.895Z","comments":true,"path":"dev-env/2015-06-20-cmd-error-resolve/","link":"","permalink":"http://rawbin-.github.io/dev-env/2015-06-20-cmd-error-resolve/","excerpt":"","text":"1 SSH 无法认证，找不到认证文件windows中默认ssh 认证文件路径在C:/users/USERNAME/.ssh/中，而默认的路径是/home/username/.ssh，所以找不着，这时需要手动指定ssh认证文件路径 ssh -i c:/users/USERNAME/.ssh/id_rsa 私钥文件路径 2 rsync 远程sudo权限rsync 需要远程rsync进程做同步功能，远程的进程需要相关的权限，比如创建文件夹的权限。在rsync中添加相关的授权信息， rsync –rsync-path=’sudo rsync’ src dst 这样远程的rsync进程就有相关的权限。 参考资料 Linux Man rsync rsync documentation rsync use sudo rsync and sudo over ssh rsync add sudo rsync permission visia sssh rsync permission denied rsync remote over ssh rsync root and sudo rsync with root permission on remote machine","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"命令行","slug":"命令行","permalink":"http://rawbin-.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"rsync","slug":"rsync","permalink":"http://rawbin-.github.io/tags/rsync/"},{"name":"ssh","slug":"ssh","permalink":"http://rawbin-.github.io/tags/ssh/"}]},{"title":"Internet Explorer HTML 标准实现","slug":"web-standard/2015-06-20-ie-html-standard","date":"2021-12-31T02:37:59.895Z","updated":"2021-12-31T02:37:59.895Z","comments":true,"path":"web-standard/2015-06-20-ie-html-standard/","link":"","permalink":"http://rawbin-.github.io/web-standard/2015-06-20-ie-html-standard/","excerpt":"","text":"1 参考资料 W3C HTML Link W3C HTML Style Help! My CSS Isn’t Working! Linking Style Sheets to HTML IE CSS Stylesheet Limit Test Suite Stylesheets Not Loading? Site Compatibility and IE8 IE9 Standards Mode Accepts only text/css for stylesheets MIME-Handling Changes in Internet Explorer","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"W3C","slug":"W3C","permalink":"http://rawbin-.github.io/tags/W3C/"},{"name":"IE","slug":"IE","permalink":"http://rawbin-.github.io/tags/IE/"},{"name":"Internet Explorer","slug":"Internet-Explorer","permalink":"http://rawbin-.github.io/tags/Internet-Explorer/"},{"name":"HTML4","slug":"HTML4","permalink":"http://rawbin-.github.io/tags/HTML4/"}]},{"title":"XMLHTTPRequest AJAX对象参考","slug":"async/2015-06-13-ajax-xmlhttprequest","date":"2021-12-31T02:37:59.894Z","updated":"2021-12-31T02:37:59.894Z","comments":true,"path":"async/2015-06-13-ajax-xmlhttprequest/","link":"","permalink":"http://rawbin-.github.io/async/2015-06-13-ajax-xmlhttprequest/","excerpt":"","text":"1 参考资料 XMLHttpRequest Living Standard XMLHttpRequest Level 1 XMLHttpRequest Level 1 XMLHttpRequest Level 2 使用指南 XMLHttpRequest Level 2 使用指南 《JavaScript权威指南》学习笔记之二十—XMLHttpRequest和AJAX解决方案 XML DOM - XMLHttpRequest 对象 XMLHttpRequest Snapshot JavaScript Ajax","categories":[],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://rawbin-.github.io/tags/AJAX/"},{"name":"异步","slug":"异步","permalink":"http://rawbin-.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"XMLHTTPRequest","slug":"XMLHTTPRequest","permalink":"http://rawbin-.github.io/tags/XMLHTTPRequest/"}]},{"title":"浏览器禁用缓存配置","slug":"dev-app/2015-06-15-disable-browser-cache","date":"2021-12-31T02:37:59.894Z","updated":"2021-12-31T02:37:59.895Z","comments":true,"path":"dev-app/2015-06-15-disable-browser-cache/","link":"","permalink":"http://rawbin-.github.io/dev-app/2015-06-15-disable-browser-cache/","excerpt":"","text":"1 绕过浏览器缓存强制更新，可按Ctrl+F5刷新页面。参考绕过浏览器缓存 2 Chrome2.1 HTTP缓存F12 打开开发者工具，点开小齿轮，有一个”Disable Cache” 2.2 DNS缓存在地址栏输入: chrome://net-internals/#dns 点击Clear 3 Firefox3.1 开发者工具按F12 打开Firebug，切换到“网络”标签，打开旁边的小三角，选中“禁用浏览器缓存” 3.2 Web开发者在Firefox的“工具”菜单，找到“Web开发者”，然后打开“Web控制台”，点开小齿轮，将设置中的“禁用缓存”选中。 3.3 Firefox配置在浏览器地址栏中输入: about:config 3.3.1 HTTP缓存 搜索 browser.cache.disk.enable 将值设为false （双击即可） 搜索 network.http.use-cache 将值设为false 搜索 browser.cache.check_doc_frequency 将值改为 1，参考 3.3.2 DNS缓存 搜索 network.dnsCacheExpiration 将值设为0 搜索 network.dnsCacheEntries 将值设为0 3.4 清除缓存在工具-&gt;选项-&gt;隐私中进行设置和操作。 参考 3.5 查看缓存在地址栏中输入: about:cache 4 Opera点击网络标签清除缓存，选择“网络选项”-&gt; “禁用所有缓存” 5 Internet Explorer在Internet 选项中，找浏览历史记录中的设置，将检查存储的页面的较新版本选项改为“每次访问网页时” 6 参考 Chrome 禁用缓存图文 浏览器开发工具的秘密 在Firefox中关闭缓存 13种方法来清除浏览器缓存 Firefox每次检查网页更新的设置 Setting your Browser Cache 禁用Firefox DNS缓存 Firefox删除DNS缓存","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"禁用缓存","slug":"禁用缓存","permalink":"http://rawbin-.github.io/tags/%E7%A6%81%E7%94%A8%E7%BC%93%E5%AD%98/"}]},{"title":"Web前端开发参考","slug":"dev-general/2015-06-12-web-dev-ref","date":"2021-12-31T02:37:59.894Z","updated":"2021-12-31T02:37:59.894Z","comments":true,"path":"dev-general/2015-06-12-web-dev-ref/","link":"","permalink":"http://rawbin-.github.io/dev-general/2015-06-12-web-dev-ref/","excerpt":"","text":"1 综合参考网站 Mozilla开发者网络 MDN Web技术文档 Open-Open开源大全 开源中国开源组件 Web前端开发 前端博客 W3School教程 W3CSchool菜鸟教程 W3C HTML 易百教程 JavaScript Kit 哪本书是对程序员最有影响、每个程序员都该阅读的书？ 我们真的缺前端工程师吗？ 齐全的前端开发项目集锦 2 JavaScript 我们程序员为什么要关注 JavaScript ？ 我们应该如何去了解JavaScript引擎的工作原理 深入理解JavaScript系列 Douglas Crockford’s Javascript JavaScript标准教程 JavaScript对象参考手册 JavaScript Code Style You Donot Know JS 3 jQuery jQuery API参考 jQuery 参考手册 jQuery API中文文档 开源中国jQuery插件 jQuery源码快速查看工具 jQuery1.6.1源码分析系列 jQuery2.0.3源码分析系列 jQuery CDN 4 fekit fekit github fekit wiki fekit 源码结构 fekit 文档 5 avalon avalon入门实例 前端框架MVC/MVVM分析系列 avalonjs 入门教程 avalon学习教程 avalonjs 组件编写指南 avalon github avalon实例 avalon官方文档 avalon沉思录 avalon架构原理 avalon最佳实践 6 node.js node.js官网 node 入门 7天学会NodeJS nodejs详解 Node.js教程 7 ECMAScript 6 ecma.org ECMAScript-262 6th ECMAScript-262 6th ECMAScript-262 5- ECMAScript 6浏览器支持情况 ECMAScript-262 6th Firefox支持 ECMAScript6值得看好的特性 来试试ECMAScript6 ES6将会有的几个新东西 ES6新特性概览 现在开始使用ES6 ECMAScript6入门 Understanding ECMAScript6 理解ES6 Using Babel ES6环境支持 ES6 Fiddle Learn ES2015 ES6 tools traceur-compiler traceur-online typescript","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/tags/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"参考资料","slug":"参考资料","permalink":"http://rawbin-.github.io/tags/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"}]},{"title":"jekyll serve 无法本地预览 中文路径问题 解决","slug":"knowledge-management/2015-06-13-jekyll-serve","date":"2021-12-31T02:37:59.894Z","updated":"2021-12-31T02:37:59.894Z","comments":true,"path":"knowledge-management/2015-06-13-jekyll-serve/","link":"","permalink":"http://rawbin-.github.io/knowledge-management/2015-06-13-jekyll-serve/","excerpt":"","text":"1 问题描述使用bootstrap jekyll 搭建github blog，想使用jekyll serve实现本地预览然而预览过程中在浏览器中输入http://localhost:4000/计算机基础/,得到的结果是Sorry this page does not exist =( ,然而输入 http://localhost:4000/编程语言/,却能得到正确的file index页面。 2 解决过程在ruby 安装目录下 webrick\\httpservlet\\filehandler.rb 这个文件中: 调整整个URL Path部分的编码： def prevent_directory_traversal(req, res) # Preventing directory traversal on Windows platforms; # Backslashes (0x5c) in path_info are not interpreted as special # character in URI notation. So the value of path_info should be # normalize before accessing to the filesystem. # dirty hack for filesystem encoding; in nature, File.expand_path # should not be used for path normalization. [Bug #3345] path = req.path_info.dup.force_encoding(Encoding.find(&quot;filesystem&quot;)) puts &quot;path:#&#123;path&#125;---#&#123;path.encoding&#125;&quot; #change the path encoding interpreter path.force_encoding(&#39;UTF-8&#39;) puts &quot;path:#&#123;path&#125;---#&#123;path.encoding&#125;&quot; if trailing_pathsep?(req.path_info) 有一个查找目录的地方，函数名set_filename中对路径进行遍历拼接，改成下面的样子。 def set_filename(req, res) puts &quot;system encoding: #&#123;Encoding.find(&quot;filesystem&quot;)&#125;&quot; res.filename = @root.dup puts &quot;res.filename encoding:#&#123;res.filename.encoding&#125;&quot; puts &quot;req.path_info.encoding:#&#123;req.path_info.encoding&#125;&quot; path_info = req.path_info.scan(%r|/[^/]*|) path_info.unshift(&quot;&quot;) # dummy for checking @root dir puts &quot;#&#123;path_info&#125;----#&#123;res.filename&#125;&quot; while base = path_info.first break if base == &quot;/&quot; # change the encoding interpreter for each path element base.force_encoding(&quot;UTF-8&quot;) 改上这两行就ok了，先将整个Path的编码解释为UTF-8，再将每个分隔的路径元素解释为UTF-8。 这里面有两个问题还没解决，为什么编程语言的URL是OK的，需要解释清楚。 同时开发环境 和应用技术等还是有些问题，也需要解释清楚。 上面这两个问题，在新版的Ruby和jekyll 中是好使的，可以确定是ruby本身的移植性问题 另外，还有一个因此引出的问题，irb中输入中文，会有问题，比如输入中文变成治。 待续… 3 参考资料 Jekyll编译中文文件名的网页的本地预览问题 在Windows的CMD中如何设置支持UTF8编码? 文件编码转换与中文路径的那些事儿 Ruby中文目录的问题 关于ruby的文件/目录名编码错误问题 UTF-8和GBK等中文字符编码格式介绍及相互转换 Encoding::UndefinedConversionError: “\\xE5” from ASCII-8BIT to UTF-8 Ruby 对多语言的支持 ruby编码说明 Ruby 1.9+ 的字符编码 Ruby：字符集和编码学习总结","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"http://rawbin-.github.io/tags/jekyll/"},{"name":"中文路径","slug":"中文路径","permalink":"http://rawbin-.github.io/tags/%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84/"},{"name":"ruby","slug":"ruby","permalink":"http://rawbin-.github.io/tags/ruby/"},{"name":"webrick","slug":"webrick","permalink":"http://rawbin-.github.io/tags/webrick/"},{"name":"本地预览","slug":"本地预览","permalink":"http://rawbin-.github.io/tags/%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88/"}]},{"title":"JavaScript模块化编程，模块化加载","slug":"modules/2015-06-12-javascript-modular","date":"2021-12-31T02:37:59.894Z","updated":"2021-12-31T02:37:59.894Z","comments":true,"path":"modules/2015-06-12-javascript-modular/","link":"","permalink":"http://rawbin-.github.io/modules/2015-06-12-javascript-modular/","excerpt":"","text":"1 参考资料 回顾：前端模块化和AMD、CMD规范（全） 知乎-JS模块加载器加载原理是怎样的? 前端模块化开发的价值 JavaScript AMD 模块加载器原理与实现 JS模块化编程之加载器原理 Javascript模块化编程（一）：模块的写法 浅谈模块化的JavaScript JavaScript模块化，模块加载器初探 小矮人JavaScript模块加载器 模块化的JavaScript开发的优势在哪 JavaScript模块化开发一瞥 JavaScript模块化编程 浅谈模块化加载的实现原理 JavaScript模块化开发一瞥 拥抱模块化的JavaScript JavaSript模块规范 - AMD规范与CMD规范介绍 知乎-AMD和CMD的区别在哪里 AMD规范与CMD规范的区别 AMD浏览器中的模块规范 AMD Github Javascript模块化编程（二）：AMD规范 CMD Github CommonJS规范 浏览器加载 CommonJS 模块的原理与实现 CMD模块定义规范 CMD模块定义规范 Javascript模块化编程（三）：require.js的用法 require()源码解读 JavaScript模块化开发库之SeaJS requirejs 英文 requirejs 中文 requirejs github seajs github kissy","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"模块加载器","slug":"模块加载器","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8/"}]},{"title":"ECMAScript 2015 ES 6","slug":"language/ecma-javascript/2015-06-13-ecmascript6-es6","date":"2021-12-31T02:37:59.894Z","updated":"2021-12-31T02:37:59.894Z","comments":true,"path":"language/ecma-javascript/2015-06-13-ecmascript6-es6/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2015-06-13-ecmascript6-es6/","excerpt":"","text":"1 特性介绍1.1 语法改进1.1.1 支持模块化语法2 module,import,export2.0.1 支持面向对象语法 类（class），继承（extends），静态方法（static），属性存取（getter,setter） 2.0.2 块级作用域 let 只在声明的代码块中有效 不存在声明提前 不允许重复声明 2.0.3 解构赋值 适合var，let，const 适合字符串、数组、对象（可嵌套）、函数参数 可带默认值 用途 交换变量 函数返回多个值 函数参数定义及参数默认值 提取对象数据，JSON数据 遍历Map解包 模块部分加载 2.0.4 扩展运算符2.0.5 生成器 特性介绍 应用举例 2.1 函数 支持参数解构赋值 参数设置默认值（默认参数），默认参数的作用域是函数作用域,默认参数必须在最后 扩展运算符 rest参数，rest参数必须是最后一个 箭头函数（不能当构造，无arguments，this固定为定义时所在的对象） 尾调用、尾递归优化 2.2 数组 增加from，of原型方法， 增加entries，keys，values，includes实例方法 for of遍历 2.3 对象 属性、方法简写 is，assign，getPrototypeOf，setPrototypeOf原型方法 新增对象Proxy， Reflect，Promise Set，Map,Generator,Iterator,Promise 2.4 字符串 简单模板字符串${JS表达式} 多行字符串 标签模板 新增includes，startsWith，endsWith，repeat方法 2.5 其他 const关键字申明常量 3 使用方法3.1 参考资料 ecma.org ECMAScript-262 6th ECMAScript-262 6th ECMAScript-262 5- ECMAScript 6浏览器支持情况 ECMAScript-262 6th Firefox支持 ECMAScript6值得看好的特性 来试试ECMAScript6 ES6将会有的几个新东西 ES6新特性概览 现在开始使用ES6 ECMAScript6入门 Understanding ECMAScript6 理解ES6 Using Babel ES6环境支持 ES6 Fiddle Learn ES2015 ES6 tools traceur-compiler traceur-online typescript","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://rawbin-.github.io/tags/ES6/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://rawbin-.github.io/tags/ECMAScript/"},{"name":"ECMAScript2015","slug":"ECMAScript2015","permalink":"http://rawbin-.github.io/tags/ECMAScript2015/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"http://rawbin-.github.io/tags/ECMAScript6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://rawbin-.github.io/tags/ES2015/"}]},{"title":"网页中的定位 鼠标定位 页面定位 事件定位","slug":"dev-app/2015-06-11-position-in-page","date":"2021-12-31T02:37:59.893Z","updated":"2021-12-31T02:37:59.893Z","comments":true,"path":"dev-app/2015-06-11-position-in-page/","link":"","permalink":"http://rawbin-.github.io/dev-app/2015-06-11-position-in-page/","excerpt":"","text":"1 事件位置属性支持情况Safari和Chrome这两个Webkit发源的兄弟，将所有见过的属性都支持了。。。 1.1 Event.screenX，Event.screenY W3C+ IE+ Firefox+ Opera+ Safari+ chrome+ W3C标准属性，所有浏览器都支持 1.2 Event.clientX，Event.clientY W3C+ IE+ Firefox+ Opera+ Safari+ chrome+ W3C标准属性，所有浏览器都支持 1.3 Event.pageX，Event.pageY W3C- IE- Firefox+ Opera+ Safari+ chrome+ 非标准属性，IE不支持 1.4 Event.layerX，Event.layerY W3C- IE- Firefox+ Opera- Safari+ chrome+ 非标准属性，IE和Opera不支持 1.5 Event.offsetX，Event.offsetY W3C- IE+ Firefox- Opera+ Safari+ chrome+ 非标准属性，Firefox不支持 1.6 Event.x, Event.y W3C- IE+ Firefox- Opera+ Safari+ chrome+ 非标准属性，Firefox不支持 2 Event对象属性 clientX clientY screenX screenY pageX pageY layerX layerY offsetX offsetY x y 2.1 Event.screenX, Event.screenY发生事件的位置相对于屏幕左上角的坐标，所有浏览器都支持的标准属性。 2.2 Event.clientX, Event.clientY发生事件的位置相对于可视区域左上角的坐标，所有浏览器都支持的标准属性。 2.3 Event.pageX，Event.pageY不是标准的属性，但被广泛的支持,类似于clientX和clientY，它们使用的是文档坐标而不是窗口坐标，表示当前点与页面左上角的距离，包含滚动距离。IE6-8不支持此属性。替代的属性为Event.offsetX，Event.offsetY。 2.4 Event.layerX, Event.layerY最近的绝对定位的父元素位置，以border左上角为原点，如果没有就为document，IE6-8，Opera不支持此属性，替代属性为Event.offsetX，Event.offsetY。 2.5 Event.offsetX，Event.offsetY最近的绝对定位的父元素位置， 如果没有就为document，Firefox不支持此属性。替代属性为Event.layerX,Event.layerY。 2.6 Event.x, Event.y事件发生位置的x坐标和y坐标，它们相对于CSS动态定位的最内层包容元素,仅IE8及更早的版本支持。 3 Element对象属性 clientHeight clientWidth clientLeft clientTop offsetHeight offsetWidth offsetLeft offsetTop scrollHeight scrollWidth scrollLeft scrollTop 3.1 Element.clientHeight,Element.clientWidth元素内部的尺寸（元素内边距和内容的尺寸），除去滚动条和其他包装元素之外的尺寸，如果当前元素是根元素document.documentElement,这个两个属性等于浏览器可视窗口的尺寸。 3.2 Element.clientLeft,Element.clientTop元素边框的宽度加滚动的距离，如果没有滚动，返回的是边框的宽度。 3.3 Element.offsetHeight，Element.offsetWidth当前元素极其所有内容的高度及宽度，单位为像素，包括元素的CSS内边距及边框及滚动条，但不包括外边距,也不包括滚动的部分，仅仅返回可见区域的宽高。 3.4 Element.offsetLeft，Element.offsetTop当前元素菜单CSS边框的左上角相对于他的offsetParent容器元素的坐标。 3.5 Element.scrollHeight,Element.scrollWidth元素的全部宽度和高度，包含滚动的部分（比如div overflow：scroll） 3.6 Element.scrollLeft,Element.scrollTop元素滚动过的距离。 4 Window对象属性 innerHeight innerWidth outerHeight outerWidth screenX screenY pageXOffset pageYOffset scrollX scrollY 4.1 Window.innerHeight,Window.innerWidth当前窗口显示区域的文档的高度和宽度，不包含浏览器的边框，单包含滚动条，单位是像素,IE8及更早的版本不支持。 4.2 Window.outerHeight,Window.outerWidth当前浏览器窗口的总高度和宽度、包含浏览器的边框，单位为像素,IE8及更早的版本不支持。 4.3 Window.screenLeft，Window.screenTop窗口的左上角（浏览器的内边缘）在屏幕上的X坐标和Y坐标；IE、Safari、Opera支持screenLeft和screenTopFirefox和Safari支持screenX和screenY 4.4 Window.screenX，Window.screenY浏览器的外边缘到屏幕边缘的距离。 4.5 Window.pageXOffset，Window.pageYOffset在Firefox中window.pageXOffset == window.scrollX; // always true,这两个是一回事。当前温度向右和向下滚动过的像素数，IE8及更早的版本中不支持这些属性，IE中替代的属性使document.documentElement或者document.body 的scrollLeft和scrollTop属性 4.6 Window.scrollX, Window.scrollY表示浏览器X轴（水平）、Y轴（垂直）滚动条的偏移距离。 5 Screen对象属性5.1 Screen.width，Screen.height屏幕的宽度、高度（指的是屏幕的分辨率，单位为像素） 5.2 Screen.availWidth，Screen.availHeight屏幕的可用宽度、高度（通常与屏幕的宽度、高度一致） 6 兼容方案6.1 获取滚动距离var x = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft; var y = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop; 7 参考资料 前端攻城狮学习笔记九：让你彻底弄清offset) 各个属性测试demo 各浏览器的鼠标位置测试 pageX、clientX、screenX、offsetX、layerX、x pageX,clientX,offsetX,layerX的区别 JavaScript网页定位详解 JavaScript中的一些定位属性图解 pageX,clientX,screenX,offsetX区别 获取浏览器滚动条的偏移距离 MDN-Window.scrollX scrollLeft,scrollTop兼容差异 JavaScript事件对象 坐标说明 原生JS活树鼠标坐标方法详解 javascript的offset、client、scroll使用方法详解 JavaScript获取浏览器的高度和宽度值 JavaScript概念之screen/client/offset/scroll/inner/avail的width/left offsetLeft,Left,clientLeft的区别 用Javascript获取页面元素的位置 JavaScript获取DOM元素位置和尺寸大小 HTML DOM Element javascript中top、clientTop、scrollTop、offsetTop的讲解","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"网页定位","slug":"网页定位","permalink":"http://rawbin-.github.io/tags/%E7%BD%91%E9%A1%B5%E5%AE%9A%E4%BD%8D/"},{"name":"鼠标定位","slug":"鼠标定位","permalink":"http://rawbin-.github.io/tags/%E9%BC%A0%E6%A0%87%E5%AE%9A%E4%BD%8D/"},{"name":"页面位置","slug":"页面位置","permalink":"http://rawbin-.github.io/tags/%E9%A1%B5%E9%9D%A2%E4%BD%8D%E7%BD%AE/"}]},{"title":"JavaScript自动化测试，测试框架","slug":"automatic/2015-06-11-javascript-testing-framework","date":"2021-12-31T02:37:59.893Z","updated":"2021-12-31T02:37:59.893Z","comments":true,"path":"automatic/2015-06-11-javascript-testing-framework/","link":"","permalink":"http://rawbin-.github.io/automatic/2015-06-11-javascript-testing-framework/","excerpt":"","text":"1 常用的列表 Intern QUnit Mocha Jasmine BusterJS DaleJS Selenium PhantomJS 2 参考资料 8个实用的JavaScript测试及校验工具 寻找更好地JavaScript单元测试工具 JavaScript单元测试 JavaScript自动化测试框架Intern Mocha QUnit Jasmine DakeJS JavaScript单元测试框架QUnit VS Jasmine 基于Grunt Mocha的JavaScript自动化测试实践 Intern Github Intern Github Homepage Intern JavaScript自动化测试也可以如此便捷 Tastacular Google开源的JavaScript测试执行过程管理工具 JavaScript自动化测试 Selemium NodeJS + PhantomJS 抓取页面信息以及截图 PhantomJS快速入门教程","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"测试框架","slug":"测试框架","permalink":"http://rawbin-.github.io/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"}]},{"title":"那些高效便捷的系统工具","slug":"dev-env/2015-06-10-system-tools","date":"2021-12-31T02:37:59.893Z","updated":"2021-12-31T02:37:59.893Z","comments":true,"path":"dev-env/2015-06-10-system-tools/","link":"","permalink":"http://rawbin-.github.io/dev-env/2015-06-10-system-tools/","excerpt":"","text":"1 文件搜索工具1.1 Everything全盘文件名索引和搜索利器异次元软件说明，下面有相关软件的说明，如MasterSeeker，光速搜索，Listary Pro等。Everything官网 2 程序启动工具2.1 Launchy异次元软件说明，下面有相关软件的说明，比如Executor，Wox，WinLaunch等Launchy官网 3 桌面管理软件桌面管理软件比较五款很棒的虚拟桌面工具 3.1 Fences异次元软件说明 3.2 柠檬桌面柠檬桌面官网 3.3 WindowTab异次元软件说明WindowTabs官网 3.4 Dexpot异次元软件说明Dexpot官网 4 多显示器管理工具多显示器管理工具,这里提到了几个优秀的工具，用这都还不错，Win8中基本可以实现基本的两个桌面的任务栏和开始菜单的映射。DisplayFusion，UltraMon，MultiMon基本也就有这些功能。 4.1 Actual Window ManagerActual Window Manager官网，在多个显示器的情况下，将两个显示器都显示任务栏，并能增加桌面分区和虚拟桌面的配置，能增加多种窗口拓展功能，比如将正常的窗口最小化为任务栏右下角的窗口。 5 参考资料 善用佳软 小众软件 异次元软件世界","categories":[{"name":"系统工具","slug":"系统工具","permalink":"http://rawbin-.github.io/categories/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"系统工具","slug":"系统工具","permalink":"http://rawbin-.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/"},{"name":"高效","slug":"高效","permalink":"http://rawbin-.github.io/tags/%E9%AB%98%E6%95%88/"},{"name":"便捷","slug":"便捷","permalink":"http://rawbin-.github.io/tags/%E4%BE%BF%E6%8D%B7/"}]},{"title":"使用Hexo搭建静态博客，基于Node","slug":"knowledge-management/2015-06-12-hexo-blog","date":"2021-12-31T02:37:59.893Z","updated":"2021-12-31T02:37:59.893Z","comments":true,"path":"knowledge-management/2015-06-12-hexo-blog/","link":"","permalink":"http://rawbin-.github.io/knowledge-management/2015-06-12-hexo-blog/","excerpt":"","text":"1 参考资料 常用静态博客 基于各种语言的静态博客大总结 Hexo官网–支持中文 Hexo中文文档 Hexo Github Hexo:基于Node.js的静态博客程序 Hexo在github上构建免费的Web应用 使用Hexo搭建个人博客 hexo你的博客 更换博客系统–从jekyll到hexo","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"Hexo","slug":"Hexo","permalink":"http://rawbin-.github.io/tags/Hexo/"},{"name":"静态博客","slug":"静态博客","permalink":"http://rawbin-.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"}]},{"title":"Wiki系统， CMS，知识管理系统","slug":"knowledge-management/2015-06-11-wiki-cms-knowledge-management","date":"2021-12-31T02:37:59.893Z","updated":"2021-12-31T02:37:59.893Z","comments":true,"path":"knowledge-management/2015-06-11-wiki-cms-knowledge-management/","link":"","permalink":"http://rawbin-.github.io/knowledge-management/2015-06-11-wiki-cms-knowledge-management/","excerpt":"","text":"一大群wiki系统比较 一大群cms系统比较 开源中国Wiki系统 11款开源Wiki管理系统 Confluence Open Atrium DokuWiki 个人知识管理系统 文档管理大师 17款非常好用的CMS 一位站长眼中的开源CMS 三个最好的国外开源CMS","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Wiki","slug":"Wiki","permalink":"http://rawbin-.github.io/tags/Wiki/"},{"name":"CMS","slug":"CMS","permalink":"http://rawbin-.github.io/tags/CMS/"},{"name":"知识管理","slug":"知识管理","permalink":"http://rawbin-.github.io/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"}]},{"title":"常见名词缩写","slug":"business/2015-06-10-common-noun-abbreviation","date":"2021-12-31T02:37:59.892Z","updated":"2021-12-31T02:37:59.892Z","comments":true,"path":"business/2015-06-10-common-noun-abbreviation/","link":"","permalink":"http://rawbin-.github.io/business/2015-06-10-common-noun-abbreviation/","excerpt":"","text":"1 OTA Over The AirOTA（Over－the－Air Technology）空中下载技术。是通过移动通信（GSM或CDMA）的空中接口对SIM卡数据及应用进行远程管理的技术。空中接口可以采用WAP、GPRS、CDMA1X及短消息技术。OTA技术的应用，使得移动通信不仅可以提供语音和数据服务，而且还能提供新业务下载。 Oline Travel AgentOTA(Online Travel Agent)是指在线旅游社，是旅游电子商务行业的专业词语。代表为：同程网、去哪儿网、村游网、号码百事通、旅游百事通、驴妈妈旅游网、携程网、百酷网、8264、出游客旅游网、乐途旅游网、欣欣旅游网、芒果网、艺龙网、搜旅网、途牛旅游网和易游天下、快乐e行旅行网、驼羊旅游网等。OTA的出现将原来传统的旅行社销售模式放到网络平台上，更广泛的传递了线路信息，互动式的交流更方便了客人的咨询和订购。 2 OTT Over The TopOTT 是“Over The Top”的缩写，是指通过互联网向用户提供各种应用服务。这种应用和目前运营商所提供的通信业务不同，它仅利用运营商的网络，而服务由运营商之外的第三方提供。目前，典型的OTT业务有互联网电视业务，苹果应用商店等。 3 CXO CEO Chief Executive Officer 首席执行官 COO Chief Operating Officer 首席运营官 CFO Chief Financial Officer 首席财务官 CTO Chief Technology Officer 首席技术官 CIO Chief Information Officer 首席信息官 CSO Chief Security Officer 首席安全官 CKO Chief Knowledge Officer 首席知识官 CMO Chief Marketing Officer 首席市场官/首席营销官 CCO Chief Crisis Official 首席危机官 CHO Chief Human Resources Officer 人力资源总监 CPA Certified Public Accoutant 注册会计师 CPO Chief Privacy Officer 首席隐私官 CBO Chief Brand Officer 首席品牌官 CAO Chief Administrative Officer 首席行政官 CGO Chief Gonverment Officer 首席政府关系官 CRO Chief Research Officer 研究总监 CPO Chief Procurement Officer 首席采购官 CQO Chief Quality Officer 首席质量官 4 X2X5 参考资料 Over The Air Online Travel Agen Over the Top OTT 概念解析 常见CXO解释 O2O、C2C、B2B、B2C区别 P2P、P2C、O2O、B2C、B2B、C2C区别 互联网电子商务名词区别在哪里？","categories":[{"name":"互联网","slug":"互联网","permalink":"http://rawbin-.github.io/categories/%E4%BA%92%E8%81%94%E7%BD%91/"}],"tags":[{"name":"名词解释","slug":"名词解释","permalink":"http://rawbin-.github.io/tags/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"}]},{"title":"JavaScript 文本模板 模板语言","slug":"dev-3rd-libs/2015-06-10-javascript-template","date":"2021-12-31T02:37:59.892Z","updated":"2021-12-31T02:37:59.893Z","comments":true,"path":"dev-3rd-libs/2015-06-10-javascript-template/","link":"","permalink":"http://rawbin-.github.io/dev-3rd-libs/2015-06-10-javascript-template/","excerpt":"","text":"1 Velocity Apache Velocity Velocity User Guide Velocity Developer Guide Velocity Template Language Reference 2 mustache mustache home mustache spec mustache manual mustache.js hogan.js 3 参考","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"文本模板","slug":"文本模板","permalink":"http://rawbin-.github.io/tags/%E6%96%87%E6%9C%AC%E6%A8%A1%E6%9D%BF/"},{"name":"模板引擎","slug":"模板引擎","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"}]},{"title":"前端CSS框架,样式汇总","slug":"dev-3rd-libs/2015-06-10-css-framework","date":"2021-12-31T02:37:59.892Z","updated":"2021-12-31T02:37:59.892Z","comments":true,"path":"dev-3rd-libs/2015-06-10-css-framework/","link":"","permalink":"http://rawbin-.github.io/dev-3rd-libs/2015-06-10-css-framework/","excerpt":"","text":"1 参考资料 10个顶级的CSS UI开源框架 18 个最好的CSS框架用于提高开发效率 10个顶级的CSS UI开源框架 CSS框架开源软件 10个顶级的CSS UI开源框架 2014 年 15 款最棒的 HTML CSS 框架","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CSS框架","slug":"CSS框架","permalink":"http://rawbin-.github.io/tags/CSS%E6%A1%86%E6%9E%B6/"},{"name":"样式框架","slug":"样式框架","permalink":"http://rawbin-.github.io/tags/%E6%A0%B7%E5%BC%8F%E6%A1%86%E6%9E%B6/"}]},{"title":"JavaScript浏览器检测，浏览器分辨","slug":"dev-app/javascript/2015-06-10-javascript-browser-detect","date":"2021-12-31T02:37:59.892Z","updated":"2021-12-31T02:37:59.892Z","comments":true,"path":"dev-app/javascript/2015-06-10-javascript-browser-detect/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2015-06-10-javascript-browser-detect/","excerpt":"","text":"1 参考资料 特性检测而不是浏览器检测 JavaScript判断浏览器类型和版本 使用JavaScript检测浏览器的相关特性 jQuery浏览器检测代码 javascript检测浏览器的代码 javascript 检测浏览器类型和版本的代码 javascript 检测浏览器类型和版本的代码 JavaScript检测IE浏览器（最短代码） IE条件注释用法","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"JavaScript 图片预览，上传预览","slug":"dev-app/javascript/2015-06-10-javascript-image-preview","date":"2021-12-31T02:37:59.892Z","updated":"2021-12-31T02:37:59.892Z","comments":true,"path":"dev-app/javascript/2015-06-10-javascript-image-preview/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2015-06-10-javascript-image-preview/","excerpt":"","text":"1 文件上传预览概述在现在的Web开发中不可避免的会做一个图片预览的功能，比如在上传图片的情况下，一个很简单的办法就是讲图片上传至服务器之后，再将文件的URL返回回来，然后异步通过这个URL加载刚刚上传的图片，实现图片的预览，很明显的在这个过程中两次Web请求，一次发送文件，一次下载文件，到最后这个文件如果在客户端被删除（取消上传，弃用这次的上传），这整个过程都白费了。我们希望能够在图片上传之前就能进行图片的预览，这样就避免了不必要的网络请求和时间等待。下面的内容就围绕这个话题展开。 2 本地图片预览2.1 IE中的本地图片预览（以本地文件的形式访问）在IE中能够很方便的实现本地网页的图片预览，IE中的&lt;input type=&quot;file&quot; id=&quot;file_upload&quot;&gt;中的File对象中的value属性，存储的是要上传的文件的完整路径，在IE中只需要将这个完整路径作为一个Image对象的src属性，就能实现在这个Image对象中对这个上传的图片进行预览。 在IE中有如下方式: var url; var fileobj = document.getElementById(sourceId); fileobj.select(); url = document.selection.createRange().text; 或者 var url = document.getElementById(sourceId).value; 两种方式获取到的路径直接给img src 可以进行本地图片的预览（可以加上file:///协议，效果一样），这两种方式对IE7、8、9、10、11下有效。 2.2 Firefox和Chrome的本地图片预览在Firefox和Chrome中使用如下方式: var url = window.URL.createObjectURL(document.getElementById(sourceId).files[0]) 将得到的值给img src 进行图片预览。可能还会看到如下的方式： var url = obj.files.item(0).getAsDataURL(); 这种使用Firefox File对象的getAsDataURL的方式，已经在Firefox 7.0以后弃用，Firefox DOM File，可能原因是在HTML5标准中有相关的定义。 3 服务端图片预览3.1 IE中的本地图片预览（以服务端URL的形式访问） 上面提到的本地预览的方式，在以服务端URL的形式方式下没有预览的效果，需要使用如下滤镜的形式。 function PreviewImg(imgFile)&#123; var newPreview = document.getElementById(&quot;newPreview&quot;); var imgDiv = document.createElement(&quot;div&quot;); document.body.appendChild(imgDiv); imgDiv.style.width = &quot;118px&quot;; imgDiv.style.height = &quot;127px&quot;; imgDiv.style.filter=&quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod = scale)&quot;; imgDiv.filters.item(&quot;DXImageTransform.Microsoft.AlphaImageLoader&quot;).src = imgFile.value; newPreview.appendChild(imgDiv); &#125; 上面的实现可以在IE7、8、9下运行，在IE10、11下无效。 3.2 Firefox和Chrome的本地图片预览在Firefox和Chrome中使用如下方式: var url = window.URL.createObjectURL(document.getElementById(sourceId).files[0]) 将得到的值给img src 进行图片预览。可能还会看到如下的方式： var url = obj.files.item(0).getAsDataURL(); 这种使用Firefox File对象的getAsDataURL的方式，已经在Firefox 7.0以后弃用，Firefox DOM File，可能原因是在HTML5标准中有相关的定义。 4 一个浏览器兼容的实现方案（兼容IE7、8、9、10、11，Firefox，Chrome）4.1 基础 在Chrome中，window.URL和window.webkitURL都存在 在Firefox中，仅Window.URL存在 在IE11（Edge），10中仅window.URL存在 在IE7、8、9中不存在window.URL 在IE中能通过FileObject 的value 属性获取文件全路径 在Chrome中无法获取FileObject的全路径，得到的是一个假路径 在Firefox中根本获取不到路径，得到的是一个文件名 在IE7、8、9中无法获取到FileObject的files属性 4.2 实现以前我们总是按照userAgent，通过判断IE，还是Chrome，还是Firefox，或者Safari、Opera等来对应支持代码，现在这种方式可能需要有所调整，File API是HTML5的规范特性，因此可以将浏览器大致先分为两个大类，一个是支持HTML5的一类，另一个是不支持的。 &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head id=&quot;Head1&quot;&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;style type=&quot;text/css&quot;&gt; .image_container &#123; width: 48px; height: 48px; position: relative; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt; &lt;script language=&quot;javascript&quot;&gt; $(function() &#123; $(&quot;#file_upload&quot;).change(function() &#123; var $file = $(this); var fileObj = $file[0]; var windowURL = window.URL || window.webkitURL; var dataURL; var $img = $(&quot;#preview&quot;); if(fileObj &amp;&amp; fileObj.files &amp;&amp; fileObj.files[0])&#123; dataURL = windowURL.createObjectURL(fileObj.files[0]); $img.attr(&#39;src&#39;,dataURL); &#125;else&#123; dataURL = $file.val(); // $img.css(&quot;filter&quot;,&#39;progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod = scale,src=&quot;&#39; + dataURL + &#39;&quot;)&#39;); // var imgObj = document.getElementById(&quot;preview&quot;); // imgObj.style.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=scale,src=\\&quot;&quot; + dataURL + &quot;\\&quot;)&quot;; // imgObj.style.width = &quot;48px&quot;; // imgObj.style.height = &quot;48px&quot;; var imgObj = document.getElementById(&quot;preview&quot;); // 两个坑: // 1、在设置filter属性时，元素必须已经存在在DOM树中，动态创建的Node，也需要在设置属性前加入到DOM中，先设置属性在加入，无效； // 2、src属性需要像下面的方式添加，上面的两种方式添加，无效； imgObj.style.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=scale)&quot;; imgObj.filters.item(&quot;DXImageTransform.Microsoft.AlphaImageLoader&quot;).src = dataURL; &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;input id=&quot;file_upload&quot; type=&quot;file&quot; /&gt; &lt;div class=&quot;image_container&quot;&gt; &lt;img id=&quot;preview&quot; width=&quot;60&quot; height=&quot;60&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 4.3 参考资料 JavaScript图片上传预览效果 兼容IE8、火狐的本地图片预览+等比例缩放 图片上传预览（IE使用滤镜） [转]很简单的JS实现上传前预览图片(兼容IE8) 图片上传预览（支持IE，Chrome，Firefox） JS魔法堂之实战：纯前端的图片预览 关于IE中CSS-filter滤镜小知识 BT9011: 只有 IE 支持 CSS Filter css filter详解 精通CSS滤镜（filter）（实例解析） 不得不收藏的——IE中CSS-filter滤镜小知识大全 MSDN Filters and Transitions Visual Filters and Transitions Reference JS魔法堂：Data URI Scheme介绍 Using files from web applications 如何在web应用程序中使用文件 [译]JavaScript文件操作(4)-URL对象 window.url.createobjecturl 兼容多个浏览器（IE,google,360,Safari,firefox） 微软相关产品API参考 Windows Internet Explorer API 参考 Developer Guides (by IE version) window.URL参考 Firefox API参考","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"图片预览","slug":"图片预览","permalink":"http://rawbin-.github.io/tags/%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88/"},{"name":"图片上传","slug":"图片上传","permalink":"http://rawbin-.github.io/tags/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"}]},{"title":"JavaScript前端画图工具","slug":"dev-3rd-libs/2015-05-29-javascript-graphs","date":"2021-12-31T02:37:59.891Z","updated":"2021-12-31T02:37:59.891Z","comments":true,"path":"dev-3rd-libs/2015-05-29-javascript-graphs/","link":"","permalink":"http://rawbin-.github.io/dev-3rd-libs/2015-05-29-javascript-graphs/","excerpt":"","text":"1 参考资料 开源中国jQuery图表插件 JavaScript Charts jqPlot Raphael gRaphael gRaphael——JavaScript 矢量图表库：两行代码实现精美图表 Flot morris Bluff","categories":[],"tags":[{"name":"JavaScript画图","slug":"JavaScript画图","permalink":"http://rawbin-.github.io/tags/JavaScript%E7%94%BB%E5%9B%BE/"},{"name":"前端画图","slug":"前端画图","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E7%94%BB%E5%9B%BE/"},{"name":"JavaScript图表","slug":"JavaScript图表","permalink":"http://rawbin-.github.io/tags/JavaScript%E5%9B%BE%E8%A1%A8/"}]},{"title":"jQuery实战详解","slug":"dev-3rd-libs/2015-05-29-practical-jquery","date":"2021-12-31T02:37:59.891Z","updated":"2021-12-31T02:37:59.891Z","comments":true,"path":"dev-3rd-libs/2015-05-29-practical-jquery/","link":"","permalink":"http://rawbin-.github.io/dev-3rd-libs/2015-05-29-practical-jquery/","excerpt":"","text":"1 事件绑定 bind,live,delegate,on 区别 bind 一直存在，直接绑定元素，不支持动态增加的元素，不支持委托； live jquery1.3新增 支持将事件委托到document元素，支持动态增加的元素的事件绑定； live jquery1.4修改 支持live 方法指定上下文对象，解决事件传播链太长问题； delegate jquery1.4.2新增 支持事件委托，将事件委托到父元素，解决事件传播链太长问题； on jquery1.7新增 支持事件代理，同时将以上几个的内部实现也调整为on调用 1.7+推荐使用 1.1 参考 jQuery 2.0.3 源码分析 事件绑定 - bind/live/delegate/on 浅谈Jquery中的bind(),live(),delegate(),on()绑定事件方式 jQuery的.bind()、.live()和.delegate()之间区别 2 参考资料 jQuery源代码查看工具(jQuery source viewer) [原创] jQuery1.6.1源码分析系列（停止更新） jQuery源码分析系列","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"jQuery源码","slug":"jQuery源码","permalink":"http://rawbin-.github.io/tags/jQuery%E6%BA%90%E7%A0%81/"},{"name":"jQuery","slug":"jQuery","permalink":"http://rawbin-.github.io/tags/jQuery/"}]},{"title":"JavaScript Ajax jQuery 文件上传 异步上传","slug":"dev-app/javascript/2015-05-29-javascript-upload","date":"2021-12-31T02:37:59.891Z","updated":"2021-12-31T02:37:59.891Z","comments":true,"path":"dev-app/javascript/2015-05-29-javascript-upload/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2015-05-29-javascript-upload/","excerpt":"","text":"1 基本原理1.1 定制UIlabel 标签下面嵌套&lt;input type=&quot;file&quot;&gt;点击label会自动打开文件浏览框，这个是W3C的约定，点击标签触发跟标签关联的第一个表单元素，或者标签内嵌的第一个表单元素。参考：W3School,W3C（这个英文更容易看懂，不信试试看，^_^）。 这样我们就可以在Label外面包裹样式元素，然后我们需要把原生的文件上传控件搞掉，最简单的方式是隐藏。但是这个在万恶的低版本IE中（IE8）下是不行的，我们可以将这个控件变透明，然后。。。，参考：IE8 Label for input file 无效;当然也可以使用Flash来解决这个问题，plupload就是这么做的,采用事件传递的形式，给定一个触发元素，然后自动生成一个跟这个触发元素关联的file元素，点击这个触发元素的时候执行file的动作。 要解决的问题如下： 定义自己的btn样式 将file input 变透明；opacity:0;filter:alpha(opacity=0) IE8; 将file input 叠于文字上方 将file input 放大，并将原生的文件上传按钮对准，btn容器，这里放大然后把多的切掉，overflow：hidden； &lt;style type=&quot;text/css&quot;&gt; .btn_container&#123; position:relative; width:120px; height:40px; line-height:40px; color: #563d7c; background-color: transparent; border: 2px solid #563d7c; border-radius: 6px; overflow:hidden; text-align:center; &#125; .file_input&#123; position:absolute; opacity:0; filter:alpha(opacity=0); z-index:1; font-size:300%; left:-550px; &#125; .btn&#123; padding: 10px 16px; font-size: 18px; &#125; &lt;/style&gt; &lt;div class=&quot;btn_container&quot;&gt; &lt;label&gt; &lt;input type=&quot;file&quot; class=&quot;file_input&quot;&gt;&lt;span class=&quot;btn&quot;&gt;点选文件&lt;/span&gt; &lt;/label&gt; &lt;/div&gt; 1.2 自动上传监听&lt;input type=&quot;file&quot;&gt;的change事件，如果改变，则触发文件上传。 1.3 异步HTTP上传使用enctype=&#39;multipart/form-data&#39;的表单提交，传输content-type:text/plain的字节流数据。使用隐藏的iframe来提交表单，实现视区内页面无刷新。 2 组件推荐在这二十来个上传组件或插件中，根据可定制UI，支持度较广（仅支持Flash或HTML5的就pass），网站能打开，有能上手的实例等条件过滤掉了一些像ajaxfileupload，uploadify等还不错的资源，留下下面这些个。 2.1 plupload自动切换多种方式的支持，有国际化的支持，支持自定义容器。 2.1.1 参考资料 plupload 官网 plupload Github 前端上传组件Plupload使用指南 Ajax多文件上传组件plupload（推荐） plupload 实例 2.2 jquery file upload样式不错，引入的库较多，只支持绑定input file。 2.2.1 参考资料 jQuery-File-Upload jQuery File Upload Demo 2.3 jQuery Ajax File Uploader / uploader有进度，有预览，不支持IE8； 2.4 参考资料 JQuery File Uploader 2.5 JSAjaxFileUploader有进度，有预览，不支持IE8； 2.5.1 参考资料 JSAjaxFileUploader JSAjaxFileUploader Demo 3 参考资料： 文件上传的渐进式增强 前端JavaScript上传组件插件 22个很棒的jQuery文件上传插件 15 个最好的 jQuery 文件上传插件 7 款 JavaScript 的 Ajax 文件上传插件 开源中国jQuery文件上传插件","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://rawbin-.github.io/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"http://rawbin-.github.io/tags/Ajax/"},{"name":"文件上传","slug":"文件上传","permalink":"http://rawbin-.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"异步上传","slug":"异步上传","permalink":"http://rawbin-.github.io/tags/%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0/"}]},{"title":"CSS实战详解","slug":"language/css/2015-05-29-practical-css","date":"2021-12-31T02:37:59.891Z","updated":"2021-12-31T02:37:59.891Z","comments":true,"path":"language/css/2015-05-29-practical-css/","link":"","permalink":"http://rawbin-.github.io/language/css/2015-05-29-practical-css/","excerpt":"","text":"1 基本规则 缩写和扩展写法 扩展写法就是属性大类-属性小类的写法，比如background-color,border-top-width,margin-left,font-size等。 缩写就是按照一定的规则将扩展写法写到一起，各个属性之间用空格隔开，比如background，font，margin，border等，由于各个属性之间的值比较容易区分，所以CSS解析器不容易混淆属性,对于不容易区分的需要用单撇号/分隔。 常见的缩写 font font: font-style|font-variant|font-weight|font-size|line-height|font-family margin 或 padding margin: margin-top|margin-right|margin-bottom|margin-leftpadding: padding-top|padding-right|padding-bottom|padding-left这种涉及到四个值的缩写属性有一个规则，写一个值是应用到四方；写两个值分别为上下和左右的值；写三个值为上、左右、下的值；写四个值依次为上、右、下、左的值。 border border:border-width|border-style|border-color list-style list-style:list-style-type|list-style-position|list-style-image background background:background-color|background-image|background-repeat|background-attachment|background-position color 六位十六进制可以缩写为三位，如果每两位都是相同的话。 2 背景2.1 属性详解 background 设置元素的背景色，背景图，背景重复方式，背景滚动方式，背景位置 background-color 设置背景色，可以是颜色名称，十六进制值或者rgb值或者是transparent（默认） background-image 可以给一个url对象或者none（默认） background-repeat repeat（默认）或者repeat-x或者repeat-y或者no-repeat,设置两个方向，单向或者不重复 background-attachment 随着页面滚动而滚动（scroll）或者固定在页面的某一个位置（fixed） background-position 设置背景图片的位置，可以是top left center bottom right这些位置关键词，或者是百分比，也可以是像素值 2.2 应用实例 实现进度条 &lt;div style=&quot;position:relative;width:100px;height:20px;border:solid 1px grey;&quot;&gt; &lt;div style=&quot;width:50px;height:18px;margin:1px;background-color:blue;&quot;&gt;&lt;/div&gt; &lt;span style=&quot;position:absolute;left:40%;top:0;&quot;&gt;50%&lt;/span&gt; &lt;/div&gt; 实现淘宝评价效果 &lt;div style=&quot;position:relative;width:120px;height:19px;background:url(star_both_five.png) 0 -18px no-repeat;&quot;&gt; &lt;div style=&quot;height:20px;float:left;background:url(star_both_five.png) 0 0 no-repeat;width:70%;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;position:absolute;left:0;top:0;height:19px;z-index:1&quot;&gt; &lt;span style=&quot;display:inline-block;width:18px;height:18px;cursor:pointer;&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;position:relative;width:120px;height:19px;background:url(star_both_five.png) 0 -18px no-repeat;&quot;&gt; &lt;div style=&quot;height:19px;float:left;background:url(star_both_five.png) 0 0 no-repeat;width:70%;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;position:absolute;left:0;top:0;height:19px;z-index:1&quot;&gt; &lt;span style=&quot;display:inline-block;width:18px;height:18px;cursor:pointer;&quot;&gt;&lt;/span&gt; &lt;span style=&quot;display:inline-block;width:18px;height:18px;cursor:pointer;&quot;&gt;&lt;/span&gt; &lt;span style=&quot;display:inline-block;width:18px;height:18px;cursor:pointer;&quot;&gt;&lt;/span&gt; &lt;span style=&quot;display:inline-block;width:18px;height:18px;cursor:pointer;&quot;&gt;&lt;/span&gt; &lt;span style=&quot;display:inline-block;width:18px;height:18px;cursor:pointer;&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;position:relative;width:98px;height:19px;background:url(star_both_one.png) 0 -22px repeat-x;&quot;&gt; &lt;div style=&quot;height:20px;float:left;background:url(star_both_one.png) 0 0 repeat-x;width:70%;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;position:absolute;left:0;top:0;height:19px;z-index:1&quot;&gt; &lt;span style=&quot;display:inline-block;width:18px;height:18px;cursor:pointer;&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;position:relative;width:98px;height:19px;background:url(star_dark.png) 0 2px repeat-x;&quot;&gt; &lt;div style=&quot;height:20px;float:left;background:url(star_bright.png) repeat-x;width:70%;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;position:absolute;left:0;top:0;height:19px;z-index:1&quot;&gt; &lt;span style=&quot;display:inline-block;width:18px;height:18px;cursor:pointer;&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; 2.3 参考资料 CSS背景属性background详解 CSS背景属性详解 CSS新属性及多背景 CSS3 background相关介绍 CSS3 background属性介绍 css background简写方式 CSS中背景图片定位方法 background-position 用法详细介绍 3 边距、边框3.1 属性详解3.1.1 margin margin margin-top margin-right margin-bottom margin-left margin 属性可以以上右下左的顺序设定各个方向的外边距值，也可以通过margin-方向来设定单个方向的外边距值，值可以是具体的像素、厘米等单位的值，也可以是百分比。 3.1.2 padding padding padding-top padding-right padding-bottom padding-left padding 属性可以以上右下左的顺序设定各个方向的内边距值，也可以通过padding-方向来设定单个方向的内边距值，值可以是具体的像素、厘米等单位的值，也可以是百分比。 3.1.3 border border border-width border-style border-color border-top-width border-top-style border-top-color border-right-width border-right-style border-right-color border-bottom-width border-bottom-style border-bottom-color border-left-width border-left-style border-left-color border 依次设置宽度，样式和颜色，也可以通过border-width，border-style，border-color单独来以上右下左的顺序设置其中的每一项，同样也可以用border-方向-width,border-方向-style,border-方向-color,来单独设置各个方向的值。 3.2 应用实例 实现Tab页效果 &lt;div style=&quot;background-color:grey;height:28px;width:250px;border-bottom:1px solid white;&quot;&gt; &lt;ul style=&quot;list-style-type:none;&quot;&gt; &lt;li style=&quot;float:left;padding:4px;margin:1px; border-width: 1px;border-style: solid solid none; border-color:darkgrey;&quot;&gt;页签一&lt;/li&gt; &lt;li style=&quot;float:left;padding:4px;margin:1px; border-width: 1px;border-style: solid solid none; border-color:darkgrey; background-color:white;&quot;&gt;页签二&lt;/li&gt; &lt;li style=&quot;float:left;padding:4px;margin:1px; border-width: 1px;border-style: solid solid none; border-color:darkgrey;&quot;&gt;页签三&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 实现选中效果 &lt;div style=&quot;text-align:center;&quot;&gt; &lt;a href=&quot;#&quot; style=&quot;display:inline-block;text-decoration:none;border: 1px solid lightgrey;width:20px;height:20px;background-color:grey;&quot;&gt;1&lt;/a&gt; &lt;a href=&quot;#&quot; style=&quot;display:inline-block;;text-decoration:none;border: 1px solid red;width:20px;height:20px;background-color:transparent;&quot;&gt;2&lt;/a&gt; &lt;a href=&quot;#&quot; style=&quot;display:inline-block;;text-decoration:none;border: 1px solid lightgrey;width:20px;height:20px;background-color:grey;&quot;&gt;3&lt;/a&gt; &lt;/div&gt; 实现各向小三角 &lt;div style=&quot;border-style:solid;border-width: 50px; border-color: red green blue yellow; width:0;height:0;&quot;&gt; &lt;/div&gt; &lt;div style=&quot;border-style:solid;border-width: 50px 50px 0px; border-color: red transparent transparent; width:0;height:0;&quot;&gt; &lt;/div&gt; 3.3 参考资料 [使用css实现全兼容浏览器的三角形][1] [用CSS代码绘制三角形 纯CSS绘制三角形的代码][5] [CSS创建三角形（小三角）的几种方法][6] 4 定位4.1 属性详解4.1.1 float left right float的元素脱离了文档流，不能撑开父元素，同时也会影响文档流布局。浮动元素左右边界为父元素的边界或者是左右浮动元素的边界。浮动元素的块级兄弟元素会显示在浮动元素的下方，文本会被”挤开”形成环绕的效果（包括块级兄弟元素中的文本）可以在float元素的父元素中加overflow属性，使浮动元素撑开父元素，或者同时浮动父子元素。可以在浮动元素的兄弟元素中加clear属性清除浮动元素的布局影响。float 属性可以用来做文字环绕的效果，或者靠在靠右排列的效果，或者将块级元素显示为行内元素的效果。 4.1.2 position static 默认的普通文档流的定位方式，顺序排放。 relative 相对于元素当前位置的定位方式，元素还存在在文档流中，可以用top，left，right，bottom进行偏移定位。可以在元素位置保留（不被其他元素占用）的情况下进行位置调整。 absolute 此种定位方式的元素，脱离了文档流，定位不是完全绝对的；他的定位的相对位置是范围从小扩大的过程中遇到的第一个非static（默认文档流定位）定位的祖先元素，如果没有最后则相对于body元素。这种特性便于设定一个非static的祖先元素来界定其中absolute元素的相对定位。 fixed 这种定位方式的元素也脱离了文档流，他的定位的原点是视窗本身，不随文档的滚动而变动。 4.1.3 z-index通过设置不同大小的数值，来约束元素在z轴上的层叠位置，改变元素的堆叠效果 4.2 应用实例 实现弹窗效果 &lt;div style=&quot;background-color:lightblue;border:1px solid grey;z-index 100;width:100px;height:100px;position:absolute;top:50%;left:50%;&quot;&gt; &lt;/div&gt; 实现进度条 &lt;div style=&quot;position:relative;width:100px;height:20px;border:solid 1px grey;&quot;&gt; &lt;div style=&quot;width:50px;height:18px;margin:1px;background-color:blue;&quot;&gt;&lt;/div&gt; &lt;span style=&quot;position:absolute;left:40%;top:0;&quot;&gt;50%&lt;/span&gt; &lt;/div&gt; 4.3 参考资料 W3School CSS Position CSS Position 博客园 CSS 定位属性 CSS浮动属性 CSS属性float详解 图文详解CSS float CSS float深入剖析 CSS z-index用法 CSS遮罩层的实现 Bootstrap 模态框（Modal）插件 DIV+CSS模拟弹层遮罩效果 奇妙的CSS Shapes 一些有趣的CSS话题汇总 CSS2 属性列表 可继承性 5 参考资料 Flex布局语法 Flex布局实例 W3School在线教程 W3CSchool菜鸟教程 W3CHTMl教程 [20个实用的CSS技巧代码][2] [CSS使用技巧][3] [CSS使用技巧收集，包含CSS2/CSS3][4] [CSS新手整理的CSS技巧][7] [CSS使用技巧20则][8] [十大CSS技巧][9] [10个非常有用的CSS技巧][10] 纯CSS气泡框实现方法探究 CSS布局奇淫巧计之-强大的负边距 负值之美：负margin在页面布局中的应用 认识hasLayout——IE浏览器css bug的一大罪恶根源 认识hasLayout——IE浏览器css bug的一大罪恶根源 CSS:haslayout知多少 hasLayrou综合 hasLayout 介绍，以及其触发条件 关于IE6、IE7、IE8实现盒子阴影shadow的几个注意点 [1]: http://www.bitscn.com/school/HTMLCSS/201410/337133.html&quot;使用css实现全兼容浏览器的三角形&quot;[2]: http://www.w3cplus.com/css/20-incredibly-useful-CSS-snippets-for-developers&quot;20个实用的CSS技巧代码&quot;[3]: http://www.ruanyifeng.com/blog/2010/03/css_cookbook.html&quot;CSS使用技巧&quot;[4]: http://www.shejidaren.com/css%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%94%B6%E9%9B%86-%E5%8C%85%E5%90%ABcss2-css3.html&quot;CSS使用技巧收集，包含CSS2/CSS3&quot;[5]: http://www.jb51.net/css/54994.html&quot;用CSS代码绘制三角形 纯CSS绘制三角形的代码”[6]: http://www.daqianduan.com/4721.html&quot;CSS创建三角形（小三角）的几种方法&quot;[7]: http://www.duote.com/tech/1/1952.html&quot;CSS新手整理的CSS技巧&quot;[8]: http://www.jb51.net/article/1187.htm&quot;CSS使用技巧20则&quot;[9]: http://blog.csdn.net/budinger/article/details/18086543&quot;十大CSS技巧&quot;[10]: http://www.cnblogs.com/hnyei/archive/2011/11/12/hnyei.html&quot;10个非常有用的CSS技巧&quot;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"CSS详解","slug":"CSS详解","permalink":"http://rawbin-.github.io/tags/CSS%E8%AF%A6%E8%A7%A3/"},{"name":"CSS属性","slug":"CSS属性","permalink":"http://rawbin-.github.io/tags/CSS%E5%B1%9E%E6%80%A7/"}]},{"title":"CSS 浏览器兼容","slug":"language/css/2015-05-29-css-hack","date":"2021-12-31T02:37:59.891Z","updated":"2021-12-31T02:37:59.891Z","comments":true,"path":"language/css/2015-05-29-css-hack/","link":"","permalink":"http://rawbin-.github.io/language/css/2015-05-29-css-hack/","excerpt":"","text":"1 参考资料 Can I Use,兼容性查询 兼容性问题及原因汇总 CSS使用技巧 css兼容问题 CSS Hack技巧大全 CSS技巧及常见问题列表 CSS Hack浏览器兼容整理 浏览器兼容-CSS Hack详解 浏览器兼容之旅的第二站:各浏览器的Hack写法 ie6,ie7,ie8 css bug兼容解决方法","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"CSS兼容","slug":"CSS兼容","permalink":"http://rawbin-.github.io/tags/CSS%E5%85%BC%E5%AE%B9/"},{"name":"CSS Hack","slug":"CSS-Hack","permalink":"http://rawbin-.github.io/tags/CSS-Hack/"}]},{"title":"node fekit 环境搭建","slug":"dev-env/2015-05-17-setup-env","date":"2021-12-31T02:37:59.890Z","updated":"2021-12-31T02:37:59.890Z","comments":true,"path":"dev-env/2015-05-17-setup-env/","link":"","permalink":"http://rawbin-.github.io/dev-env/2015-05-17-setup-env/","excerpt":"","text":"1 版本信息 node 0.10.31 下载 fekit 0.2.85 2 环境安装2.1 node 0.10.31下载 node相应的版本，安装 2.2 fekit 0.2.85npm install fekit@0.2.85 -g Tips：如果提示找不到npm路径，手动创建相关路径目录即可 如果安装速度不给力，可以手动指定国内的npm源 npm install fekit@0.2.85 -g --registry=https://registry.npm.taobao.org 2.3 fekit 扩展安装 check 检查项目文件时用 npm install fekit-extension-check -g hf header&amp;footer项目使用 npm install fekit-extension-hf -g svn svn操作 npm install fekit-extension-svn -g 3 切换安装源安装速度不给力，将国外源切换到国内 3.1 一次性指定npm install xxx -g --registry=/url/to/npm/source npm install fekit@0.2.85 -g --registry=https://registry.npm.taobao.org 3.2 直接修改npm config set registry /url/to/npm/source npm config set registry https://registry.npm.taobao.org 3.3 源管理工具 安装管理工具 npm install nrm -g 查看可用源列表 npm ls 切换源 npm use taobao 4 node版本管理linux下好用的工具n，nvm在windows下不好使以下是windows下可用的工具 nvm-windows (在用，推荐) nvm-for-windows 看起来不错 gnvm Tips：切记不是用npm安装，下载下来手动安装，同时注意右键管理员权限运行 4.1 使用使用起来很简单，这里就不多说了， 直接看帮助就行，简单实用的小工具。","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://rawbin-.github.io/tags/npm/"},{"name":"fekit","slug":"fekit","permalink":"http://rawbin-.github.io/tags/fekit/"},{"name":"node","slug":"node","permalink":"http://rawbin-.github.io/tags/node/"},{"name":"nrm","slug":"nrm","permalink":"http://rawbin-.github.io/tags/nrm/"},{"name":"nvm","slug":"nvm","permalink":"http://rawbin-.github.io/tags/nvm/"}]},{"title":"VPN 619 端口关闭问题解决","slug":"os-app/2015-05-10-vpn-problem","date":"2021-12-31T02:37:59.890Z","updated":"2021-12-31T02:37:59.890Z","comments":true,"path":"os-app/2015-05-10-vpn-problem/","link":"","permalink":"http://rawbin-.github.io/os-app/2015-05-10-vpn-problem/","excerpt":"","text":"1 原因总结 VPN连接限制，换一个备用的VPN试试 Windows相关服务没开启 Windows防火墙限制 路由器防火墙限制 2 我的解决办法1、在计算机管理-&gt;服务中开启Windows服务 Telephony Remote Access Connection Manager Remote Access Auto Connection Manager Remote Procedure Call (RPC) Locator Network Connections 2、在路由器管理界面-&gt;安全设置里面关闭SPI防火墙 3 参考文档 VPN错误解决办法一 VPN错误解决办法二 VPN 619解决办法","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"VPN","slug":"VPN","permalink":"http://rawbin-.github.io/tags/VPN/"},{"name":"619","slug":"619","permalink":"http://rawbin-.github.io/tags/619/"},{"name":"VPN错误","slug":"VPN错误","permalink":"http://rawbin-.github.io/tags/VPN%E9%94%99%E8%AF%AF/"}]},{"title":"Sublime Text 使用和配置","slug":"dev-tools/2015-05-22-using-sublime-text","date":"2021-12-31T02:37:59.890Z","updated":"2021-12-31T02:37:59.890Z","comments":true,"path":"dev-tools/2015-05-22-using-sublime-text/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2015-05-22-using-sublime-text/","excerpt":"","text":"1 快捷键1.1 查找 文件名过滤 Ctrl + P 可以@和：符号与Ctrl+P和Ctrl+G配合使用 符号过滤 Ctrl + R 跳到指定行 Ctrl + G 符号查找 Ctrl + F 文件中查找 Ctrl + Shift + F 代码范围查找 Ctrl + Shift + Space, Ctrl + Shift + A, Ctrl + Shift + A,多次按可扩大范围 括号范围 Ctrl + M, Ctrl + Shift + M, 单词选中 Ctrl + D，多次按可以扩大选中范围 行选中 Ctrl + L 1.2 编辑 列编辑 Shift + 鼠标右键，鼠标中键 ，Ctrl+Alt+上下方向键, Ctrl + Shift + L 代码折叠 Ctrl+Shift+[,Ctrl+Shift+] 删除单词 Ctrl + Delete，Ctrl+ Backspace 删除当前行 Ctrl + Shift + K 复制当前行 Ctrl + Shift + D 移动行 Ctrl + Shift + 上下方向键 注释行 Ctrl + / 多行合并 Ctrl + J 缩进 Ctrl + [, Ctrl + ],Tab, Shift + Tab 格式化粘贴 Ctrl + Shift + V 替换 Ctrl + H， Ctrl + Shift + H 2 插件2.1 安装方法参考Package Control, 基本方式是拷贝一段安装的Python 代码,在Sublime Text 的控制台（View-&gt;Console），回车执行。 装好包管理器之后，就有就可以在(Ctrl + Shift + P)中调出相应命令，比如输入 Install Package， 就可以安装插件包了（第一次稍慢，看状态栏的状态）。 2.2 使用方法有些插件是自动加载的，比如代码提示；有些是直接在需要使用的时候调用相关的命令的，比如JSON格式化，在使用的时候，Ctrl + Shift + P 调出控制台，然后输入相应的命令，这个比较保险，可以避免快捷键冲突；当然也可以直接使用快捷键 Ctrl + Alt + J,如果没有快捷键冲突的话。 2.3 插件列表 IMESupport在Sublime中更好地支持中文输入法；在Sublime中输入中文的时候，会出现输入法不跟随光标的情况，出现要么输入法在当前屏幕的左上角，要么在另外一个屏幕上，这个插件很好的解决了这个问题。 ConvertToUTF8中文和UTF8之间的转码，解决乱码问题 sublime-enhanced（for Sublime Text 3）sublime增强工具集合，把sublime向ide打造的好帮手，不过按照官网的说法，在Sublime 2 和Sublime 3 中都装了一遍，Sublime 2中根本跑步起来，全部装完几十个插件，报了将近二十来个错误，醉了；在Sublime 3中还好，就三四个错误，同样是依赖加载失败，做了一个全量的安装，依赖全在里面，还是加载失败，没辙。 2.3.1 格式化插件 CoolFormat支持多种语言的代码格式化插件，相关的有一个叫CodeFormatter的支持的语言较少，关键是还基本不起作用，这个就可以不用尝试了。 Pretty JSONJSON格式化插件 HTML-CSS-JS Prettify看名字就可以知道了，做这三种代码的格式化的插件，直接在Package Setting中使用，快捷键Ctrl + Shift + H JsFormatJS格式化插件 其他在安装列表里面可以搜具体的格式化插件，比如CSS Formatter等，功能都差不多，有一个全功能的基本就OK了 2.3.2 代码自动补全Sublime默认是从当前文件中提取符号作为代码补全提示。 Autocompletion​Fuzzy这个一直在更新，属于sublime-enhanced 的一部分,比All autocomplete实用 Better Completion对默认sublime text自动补全的修正和增强 SublimeCodeIntel这个是从一个IDE里面移植到Sublime中的插件，功能较全面，支持的语言较多。 AllAutoComplete这个是从所有打开的文件中提取符号作为提示信息的，可以作为一个选项，不建议用多个，因为这个是自动启用并执行的，你懂的。 其他你可以安装其他开发库的代码自动补全，不如说jQuery等。 2.3.3 代码自动生成 EmmetZen Coding, Emmet的支持，高效快速的生成静态HTML代码 Sublime Prefixr自动生成兼容各种浏览器的CSS3样式私有属性 Sublime Linter自动代码语法检查 Git、Gitgutter 、ModificGit命令相关工具，支持Sublime中执行Git相关命令 BracketHighlighter匹配的括号，标签，引号等的高亮显示 SublimeREPL提供多种语言的交互式命令行，比如Node，Python等。 DocBlockr在函数附近写注释的时候，自动生成格式良好的返回值，参数等信息。 AutoFileName文件路径中文件名和自动补全，比如在引用静态文件的时候。 Sublime V8在Sublime中显示JavaScript控制台，跟浏览器控制台类似，有JSlint功能 Filter Lines进行行过滤，类似于Linux中的Grep，方便对数据进行处理 FileDiff文件比较结果，跟Git的diff类似 2.3.4 推荐的插件列表 Package Control IME Support ConvertToUTF8 Emmet DocBlockr Sublime Linter BracketHighlighter Pretty JSON Better Completion HTML-CSS-JS-Prettify AutoFileName 2.4 问题上面介绍的插件已经很多了，如果因为装了各种各样的插件，导致Sublime不那么灵活了，还会报类似下面的错误： A plugin (SublimeCodeIntel) may be making Sublime Text unresponsive by taking too long (0.020000s) in its on_modified callback.This message can be disabled via the detect_slow_plugins setting 解决办法为： Preferences &gt; Settings - UserAdd the following: “detect_slow_plugins”: false 添加不检测的配置，不过这个只是隐藏了提示，确实是让Sublime没有那么快了，所以安装插件时需要节制。不过不管怎样，打造一个轻量级的IDE，占用内存一两百兆，总比占用八九百兆要好得多。 2.5 其他Sublime Text和其他IDE都具有一个比较强的功能就死代码片段，闹了大半天了，函数注释有了，IDE中的文件头注释在Sublime Text中还没得到体现,具体做法就是新建一个代码片段，Tools-&gt;New Snippet，然后输入如下内容： &lt;snippet&gt; &lt;content&gt;&lt;![CDATA[ /** * --------------------------------------------------------------------------- * * * @Project: $&#123;3:ProjectName&#125; * @FileName: $&#123;TM_FILENAME&#125; * @Dependence: -- * @Description: $&#123;4:Description&#125; * @CreatedBy: $&#123;5:username&#125; * @CreateDate: $&#123;1:date&#125; * @LastModifiedBy: $&#123;5:username&#125; * @LastModifiedDate: $&#123;1:date&#125; * * --------------------------------------------------------------------------- * */ ]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;tabTrigger&gt;filedoc&lt;/tabTrigger&gt; &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;scope&gt;source.js&lt;/scope&gt; &lt;/snippet&gt; 这样就可以在js文件中输入filedoc时出现文件注释头。TM_FILENAME是Sublime Text的变量，代表当前文件，具体可参考Sublime Text 2 代码片断,功能没有IDE那么强大，不过基本够用了。 2.6 参考文档 Sublime Text 2 快捷键 实用的sublime插件集合 – sublime推荐必备插件 Package Control Package 库 Sublime Text最佳插件列表 一些必不可上的Sublime插件 Sublime Text2 的使用方法和插件推荐 前端开发者需要的10个Sublime插件 Sublime常用插件集锦 20 个强大的 Sublime Text 插件 15个针对开发人员的最好Sublime Text插件 编码神器 Sublime Text 包管理工具及扩展大全","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"快捷键","slug":"快捷键","permalink":"http://rawbin-.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"Sublime Text 2","slug":"Sublime-Text-2","permalink":"http://rawbin-.github.io/tags/Sublime-Text-2/"},{"name":"插件推荐","slug":"插件推荐","permalink":"http://rawbin-.github.io/tags/%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"}]},{"title":"那些编辑器","slug":"dev-tools/2015-05-24-develop-editors","date":"2021-12-31T02:37:59.890Z","updated":"2021-12-31T02:37:59.890Z","comments":true,"path":"dev-tools/2015-05-24-develop-editors/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2015-05-24-develop-editors/","excerpt":"","text":"1 就是一个列表 记事本不用说了，Windows自带，不支持大文件打开 Visual Studio一开始用的VC6，后面再没怎么用过，主要是安装起来太占空间 VIM这个是Linux中必不可少的利器，当然Windows中也可以有，他可以做的很快 Ecmas这个没用过，听说和VIM最大的区别是，他让你做起来更简单 Eclipse， MyEclipse，IDEA这个是Java相关开发的利器，当然可以做各种相关的定制，比如安装一个PHP的插件 Zend Studio, PHPEd， PHPStorm调试起来简单好用 UltraEdit功能强大，就是有点慢 Notepad++开源免费，关键是快 PycharmPython Web开发利器 BracketsAdobe 出品的前端开发IDE，更专注于前端 Sublime Text性感的编辑器，风格好看，轻快 AtomGithub出品的代码编辑器，用过Sublime的你会发现，他就是Sublime失散多年的姐妹，界面很像，操作方式很像，就连快捷键和插件名都极其相似 Visual Studio Code微软出品的跨平台编辑器，更适合于前端，原生支持多种语言的语法高亮，代码格式化，代码智能提示，以及函数参数提示；原生支持Markdown，支持git；这些都是相对于atom和sublime需要安装插件才能实现的优势。","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://rawbin-.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"编辑器","slug":"编辑器","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"}]},{"title":"Web调试、开发工具","slug":"dev-tools/2015-05-28-using-fiddler","date":"2021-12-31T02:37:59.890Z","updated":"2021-12-31T02:37:59.890Z","comments":true,"path":"dev-tools/2015-05-28-using-fiddler/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2015-05-28-using-fiddler/","excerpt":"","text":"1 引子Web开发难免会需要各种监控和调试，现在各大浏览器基本都有了自带的调试工具，比如Firefox的Web开发者，Chrome Inspect，以及IE自带的开发者工具，这些工具都可以很方便的用F12调出。现在已经是不带调试器的浏览器不是好的开发工具的情形了。 2 调试工具列表 首推各大浏览器的F12工具，各大浏览器的插件库 Firefox的Firebug、WebDeveloper Fiddler HTTP Watch Charles HTTP Debugger HTTP Analyzer Wireshark 通用的网络抓包工具基本已经够用了，还是首推的F12，顺手拈来。实在不行可以Fiddler基本能解决你所有的问题。当然后面的工具也是可以尝试的，都是特别好的工具，只是后面的刀比较多，比较疼，当然可以自行想办法。 需要相关的插件的可以在浏览器的插件库中很方便的搜到，比如需要JSON相关的，在插件信息中查JSON，同样的查REST。 3 浏览器兼容测试 Chrome，Firefox兼容性较强，可以不必多费周章 高版本的IE开发者工具（F12），可以对较低版本的IE进行模拟和兼容测试。 需要更高精度的环境测试，到Modern IE下载多种版本的IE环境进行实测。 在线工具http://browsershots.org/ IETester(比较古老) SuperPreview Modern IE 4 参考资料 Node.js调试指南 Fiddler官网 HTTPWatch 官网 Charles 官网 HTTP Debugger 官网 WireShark 官网 Fiddler 教程 Fiddler入门教程 Fiddler使用小结 Web开发又一利器之——Fiddler Web调试利器fiddler介绍 抓包工具Fiddler的使用 浏览器HTTP分析调试工具收集 WEB前端开发中的性能调试工具（简记） 介绍几款浏览器兼容性测试工具 12款浏览器兼容性测试工具推荐 Web浏览器兼容性测试工具如何选择？ 12款很棒的浏览器兼容性测试工具推荐","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://rawbin-.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"HTTP调试","slug":"HTTP调试","permalink":"http://rawbin-.github.io/tags/HTTP%E8%B0%83%E8%AF%95/"},{"name":"Web调试","slug":"Web调试","permalink":"http://rawbin-.github.io/tags/Web%E8%B0%83%E8%AF%95/"}]},{"title":"软件工程中的图","slug":"dev-general/2015-04-23-software-engineering-graph","date":"2021-12-31T02:37:59.888Z","updated":"2021-12-31T02:37:59.888Z","comments":true,"path":"dev-general/2015-04-23-software-engineering-graph/","link":"","permalink":"http://rawbin-.github.io/dev-general/2015-04-23-software-engineering-graph/","excerpt":"","text":"1 参考 软件工程 –软件工程用图 软件工程中的图情结 软件工程中的图 软件工程中的图情结","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://rawbin-.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"设计图","slug":"设计图","permalink":"http://rawbin-.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%9B%BE/"},{"name":"流程图","slug":"流程图","permalink":"http://rawbin-.github.io/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"},{"name":"UML","slug":"UML","permalink":"http://rawbin-.github.io/tags/UML/"}]},{"title":"Web前端框架 类库 工具","slug":"framework/2015-04-23-web-framework-library","date":"2021-12-31T02:37:59.888Z","updated":"2021-12-31T02:37:59.888Z","comments":true,"path":"framework/2015-04-23-web-framework-library/","link":"","permalink":"http://rawbin-.github.io/framework/2015-04-23-web-framework-library/","excerpt":"","text":"1 参考 推荐几款Web前端框架 十个开源的Javascript框架 20个优秀的前端框架 值得收藏的14款响应式前端开发框架 回顾：2014年最流行前端开发框架对比评测 2014年5个最流行前端框架对比 前端开发框架对比 开源前端框架纵横谈 JX - Javascript eXtension tools 前端自动化开发工具 Web 技术文档 网站优化必备的9个Firefox插件 W3C Technical Report Development Process部分翻译 Automated cross browser testing with JavaScript!Exterminate all the bugs! 功能自动化测试工具 Selenium JavaScript框架比较","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Web框架","slug":"Web框架","permalink":"http://rawbin-.github.io/tags/Web%E6%A1%86%E6%9E%B6/"}]},{"title":"Web安全相关资料","slug":"security/2015-04-23-web-security","date":"2021-12-31T02:37:59.888Z","updated":"2021-12-31T02:37:59.888Z","comments":true,"path":"security/2015-04-23-web-security/","link":"","permalink":"http://rawbin-.github.io/security/2015-04-23-web-security/","excerpt":"","text":"1 参考 十大工具及应用策略搞定OWASP十大热门威胁 OWASP Top 10 2013 [TOP10]十大渗透测试演练系统 如何打造一款可靠的WAF（Web应用防火墙） 关于渗透的一些资料分享 返璞归真——流量中提取文件的五种方法 数字签名是什么？","categories":[{"name":"计算机安全","slug":"计算机安全","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://rawbin-.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"OWASP","slug":"OWASP","permalink":"http://rawbin-.github.io/tags/OWASP/"}]},{"title":"网站架构设计","slug":"architecture/2015-04-23-site-architecture","date":"2021-12-31T02:37:59.887Z","updated":"2021-12-31T02:37:59.887Z","comments":true,"path":"architecture/2015-04-23-site-architecture/","link":"","permalink":"http://rawbin-.github.io/architecture/2015-04-23-site-architecture/","excerpt":"","text":"1 参考 大型网站技术架构 如何构建大型网站架构 网站架构 大型网站系统架构的演化 平台网站架构设计之我所见 分享MQ（Message Queue）即消息队列系列博文 互联网系统架构的演进","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Web架构","slug":"Web架构","permalink":"http://rawbin-.github.io/tags/Web%E6%9E%B6%E6%9E%84/"},{"name":"网站架构","slug":"网站架构","permalink":"http://rawbin-.github.io/tags/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"}]},{"title":"PHP 相关资料","slug":"language/2015-04-23-php-related","date":"2021-12-31T02:37:59.887Z","updated":"2021-12-31T02:37:59.887Z","comments":true,"path":"language/2015-04-23-php-related/","link":"","permalink":"http://rawbin-.github.io/language/2015-04-23-php-related/","excerpt":"","text":"1 参考 TIPI深入理解ＰＨＰ内核 PHP内核探索：从SAPI接口开始 Zend Framework手册 中文版 PHP 类型比较表 PHP Cheat Sheet windows php","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://rawbin-.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://rawbin-.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://rawbin-.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"Python 相关资料","slug":"language/2015-04-23-python-regular","date":"2021-12-31T02:37:59.887Z","updated":"2021-12-31T02:37:59.887Z","comments":true,"path":"language/2015-04-23-python-regular/","link":"","permalink":"http://rawbin-.github.io/language/2015-04-23-python-regular/","excerpt":"","text":"1 Python基础 PEP8 Python编码规范 Python 编码风格指南中译版（Google SOC） Python程序设计 Python编程入门篇 Python面向对象特征总结 Python Web部署篇 Python与Tornado Python Unicode与中文处理 python 文件编码 字符串编码 文件读写 文件编码控制 编码转换 Python 程序员应该知道的 10 个库 2 环境配置 用pyenv和virtualenv搭建单机多 python pyenv 多版本管理（自动安装脚本） 使用pyenv管理不同版本的python Linux 下的 Python 多版本管理（pyenv） 3 网络应用 Python爬虫入门教程 Python爬虫框架Scrapy实战之定向批量获取职位招聘信息 python 爬虫实现前需要注意的地方 python登陆网站,python urllib2 登陆网站 Python使用cookielib和urllib2模拟登陆新浪微博并抓取数据 python利用requests库模拟登录和抓取数据，超简单 4 正则表达式 Python正则表达式指南 比较详细Python正则表达式操作指南(re使用) Python正则表达式操作指南","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://rawbin-.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://rawbin-.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"编码","slug":"编码","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"Python","slug":"Python","permalink":"http://rawbin-.github.io/tags/Python/"},{"name":"VirtualEnv","slug":"VirtualEnv","permalink":"http://rawbin-.github.io/tags/VirtualEnv/"}]},{"title":"内存占用相关术语 VSS RSS PSS USS","slug":"os-app/2015-04-23-memory-tems","date":"2021-12-31T02:37:59.887Z","updated":"2021-12-31T02:37:59.887Z","comments":true,"path":"os-app/2015-04-23-memory-tems/","link":"","permalink":"http://rawbin-.github.io/os-app/2015-04-23-memory-tems/","excerpt":"","text":"1 参考 内存耗用：VSS/RSS/PSS/USS 进程实际内存占用: 私有驻留内存数(Private RSS)介绍 内存耗用：VSS/RSS/PSS/USS","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"VSS","slug":"VSS","permalink":"http://rawbin-.github.io/tags/VSS/"},{"name":"RSS","slug":"RSS","permalink":"http://rawbin-.github.io/tags/RSS/"},{"name":"PSS","slug":"PSS","permalink":"http://rawbin-.github.io/tags/PSS/"},{"name":"USS","slug":"USS","permalink":"http://rawbin-.github.io/tags/USS/"},{"name":"内存占用参数","slug":"内存占用参数","permalink":"http://rawbin-.github.io/tags/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%8F%82%E6%95%B0/"}]},{"title":"网络分层模型 OSI TCP/IP","slug":"protocol/2015-04-23-osi-sevens-model","date":"2021-12-31T02:37:59.887Z","updated":"2021-12-31T02:37:59.887Z","comments":true,"path":"protocol/2015-04-23-osi-sevens-model/","link":"","permalink":"http://rawbin-.github.io/protocol/2015-04-23-osi-sevens-model/","excerpt":"","text":"1 需要总结的点 每一层的功能分工 每一层的协议 每一层的设备 每一层的数据结构 OSI和TCP/IP怎么个对应法 2 参考 OSI七层模式简单通俗理解 ISO-OSI的七层协议经典架构 OSI七层模型详解 不再困惑 互联网OSI七层模型全解析 OSI七层模型详解 ISO/ OSI七层模型结构体系 计算机网络基础之OSI七层参考模型 TCP/IP协议（七层、四层协议） TCP/IP数据包结构详解 HTTP头信息解读 OSI七层与TCP/IP五层网络架构详解 以太网，IP,TCP,UDP数据包分析 网络分层模型 网络分层模型","categories":[{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://rawbin-.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"OSI","slug":"OSI","permalink":"http://rawbin-.github.io/tags/OSI/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://rawbin-.github.io/tags/TCP-IP/"}]},{"title":"PhotoShop 教程","slug":"dev-tools/2015-04-23-photoshop","date":"2021-12-31T02:37:59.887Z","updated":"2021-12-31T02:37:59.887Z","comments":true,"path":"dev-tools/2015-04-23-photoshop/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2015-04-23-photoshop/","excerpt":"","text":"1 参考 Photoshop CS6中文版入门 Photoshop技巧教程：深度解析蒙版应用 四色黑变单色黑之Photoshop技巧 PS软件cmyk四色黑如何变成单色黑","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"PhotoShop","slug":"PhotoShop","permalink":"http://rawbin-.github.io/tags/PhotoShop/"},{"name":"四色黑","slug":"四色黑","permalink":"http://rawbin-.github.io/tags/%E5%9B%9B%E8%89%B2%E9%BB%91/"},{"name":"单色黑","slug":"单色黑","permalink":"http://rawbin-.github.io/tags/%E5%8D%95%E8%89%B2%E9%BB%91/"}]},{"title":"JavaScript内存管理","slug":"browser/2015-04-23-javascript-memory","date":"2021-12-31T02:37:59.886Z","updated":"2021-12-31T02:37:59.886Z","comments":true,"path":"browser/2015-04-23-javascript-memory/","link":"","permalink":"http://rawbin-.github.io/browser/2015-04-23-javascript-memory/","excerpt":"","text":"1 参考 理解JavaScript 内存分配 JavaScript对象模型-执行模型 JavaScript内存分析 JavaScript内存管理 内存管理 JavaScript内存优化 分析内存使用情况 (JavaScript) JavaScript内存优化 我们应该如何去了解JavaScript引擎的工作原理","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://rawbin-.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"内存管理","slug":"内存管理","permalink":"http://rawbin-.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"Linux 系统性能监控","slug":"os-app/2015-04-23-linux-performance-monitor","date":"2021-12-31T02:37:59.886Z","updated":"2021-12-31T02:37:59.886Z","comments":true,"path":"os-app/2015-04-23-linux-performance-monitor/","link":"","permalink":"http://rawbin-.github.io/os-app/2015-04-23-linux-performance-monitor/","excerpt":"","text":"1 参考 13个超实用的Linux性能监测命令行工具 监控 Linux 性能的 18 个命令行工具 Linux服务器性能追踪以及服务器监控常用命令 关于linux服务器进程监控及自动重启的简单方案 使用 shell 脚本对 Linux 系统和进程资源进行监控 Linux 运行进程实时监控pidstat命令详解 linux 进程监控 linux监控指定进程 linux下进程的监控 使用Shell脚本对Linux系统和进程资源进行监控 pidstat - 监控并统计Linux进程的数据 使用Shell脚本对Linux系统和进程资源进行监控 系统管理员必备工具 Linux系统性能监控之6个vmstat和6个iostat命令 Linux Performance Monitoring with Vmstat and Iostat Commands","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux性能检测","slug":"Linux性能检测","permalink":"http://rawbin-.github.io/tags/Linux%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B/"},{"name":"iostat","slug":"iostat","permalink":"http://rawbin-.github.io/tags/iostat/"},{"name":"vmstat","slug":"vmstat","permalink":"http://rawbin-.github.io/tags/vmstat/"},{"name":"服务器监控","slug":"服务器监控","permalink":"http://rawbin-.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7/"}]},{"title":"Linux文本处理 日志分析","slug":"os-app/2015-04-23-linux-text-processing","date":"2021-12-31T02:37:59.886Z","updated":"2021-12-31T02:37:59.886Z","comments":true,"path":"os-app/2015-04-23-linux-text-processing/","link":"","permalink":"http://rawbin-.github.io/os-app/2015-04-23-linux-text-processing/","excerpt":"","text":"1 参考 学习 Linux，101: 文本流和过滤器 Linux中常用命令之一——文本处理 日志分析查看——grep,sed,sort,awk运用 三大文本处理工具grep、sed及awk的简单介绍 LINUX sed grep awk之间比较整理 Linux—文本处理（正则表达式，grep,awk,sed） Linux grep sed awk Linux下文本的高效处理 Linux Shell 文本处理工具集锦 Linux Shell 文本处理工具集锦 linux下的文本处理命令sed&amp;&amp;awk&amp;&amp;grep Linux下文本处理命令的使用 文本过滤工具之AWK Linux文本处理利器 – sed 正则表达式和文本过滤工具grep Linux下常用文本处理命令 学习 Linux，101: 文本流和过滤器 linux 文本处理工具之一grep命令详解 文本过滤之grep，egreo及fgrep 以及正则表达式 Linux Shell 文本处理工具集锦 linux笔记3(过滤器、管道、常用文件管理操作指令) Linux下常用文本处理命令 Linux下常用文本处理命令 Linux下文本的高效处理 awk 正则匹配后分组问题 linux正则获得分组","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://rawbin-.github.io/tags/Linux/"},{"name":"文本处理","slug":"文本处理","permalink":"http://rawbin-.github.io/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"},{"name":"日志分析","slug":"日志分析","permalink":"http://rawbin-.github.io/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"name":"grep","slug":"grep","permalink":"http://rawbin-.github.io/tags/grep/"},{"name":"awk","slug":"awk","permalink":"http://rawbin-.github.io/tags/awk/"}]},{"title":"LDAP相关资料","slug":"protocol/2015-04-23-ldap","date":"2021-12-31T02:37:59.886Z","updated":"2021-12-31T02:37:59.886Z","comments":true,"path":"protocol/2015-04-23-ldap/","link":"","permalink":"http://rawbin-.github.io/protocol/2015-04-23-ldap/","excerpt":"","text":"1 参考 LDAP快速入门 LDAP服务原理详解(原创) LDAP详解 LDAP概念和原理 LDAP目录树的结构（转） OpenLDAP快速指南 LDAP基础概念 LDAP基础知识整理 OpenLDAP构建统一认证之基础概念 LDAP协议基础概念","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"LDAP","slug":"LDAP","permalink":"http://rawbin-.github.io/tags/LDAP/"},{"name":"OpenLDAP","slug":"OpenLDAP","permalink":"http://rawbin-.github.io/tags/OpenLDAP/"}]},{"title":"Linux 系统命令 系统管理","slug":"os-app/2015-04-23-linux-cmd","date":"2021-12-31T02:37:59.886Z","updated":"2021-12-31T02:37:59.886Z","comments":true,"path":"os-app/2015-04-23-linux-cmd/","link":"","permalink":"http://rawbin-.github.io/os-app/2015-04-23-linux-cmd/","excerpt":"","text":"1 参考 Linux 命令手册 Linux 常用命令全集 Linux 常用命令集 Linux命令大全中文详解 Linux系统信息查看命令大全 常用查看Linux系统信息命令 LAMP Web","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux系统命令","slug":"Linux系统命令","permalink":"http://rawbin-.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"},{"name":"Linux系统管理","slug":"Linux系统管理","permalink":"http://rawbin-.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"}]},{"title":"数据库 数据存储比较","slug":"database/2015-04-23-databases-storage-compare","date":"2021-12-31T02:37:59.885Z","updated":"2021-12-31T02:37:59.885Z","comments":true,"path":"database/2015-04-23-databases-storage-compare/","link":"","permalink":"http://rawbin-.github.io/database/2015-04-23-databases-storage-compare/","excerpt":"","text":"1 内存数据库，实时数据库1.1 参考 主流内存数据库比较 关系数据库、内存数据库、实时数据库的简单比较 内存数据库 主流内存数据库对比报告 主流内存数据库功能特性和性能比较 基于内存数据库的分布式数据库架构 开源嵌入式数据库Berkeley DB和SQLite的比较 浅析DB（BDB）与SQLite对比 2 关系型数据库管理系统比较2.1 参考 关系型数据库管理系统比较 SQLite vs MySQL vs PostgreSQL：关系型数据库比较 三款开源关系型数据库对比：MySQL、PostgreSQL、SQLite 3 NoSQL数据库3.1 参考 NoSQL数据库面面观 HBase技术介绍 NoSQL非关系型数据库综述 8种Nosql数据库系统对比 NoSQL数据库对比：MongoDB vs.Cassandra 28 个 MongoDB NoSQL 数据库的面试问答 现在最成熟的开源nosql是什么？分别有什么优缺点？ 4 海量大文件，小文件存储系统 分布式文件系统 海量小文件问题综述 云存储文件系统对比 小文件存储的方案对比：nginx、Redis、Moosefs 分布式存储系统（GlusterFS，Swift，Cassandra）设计对比 九大主流横向扩展文件系统存储对比评测 分布式文件系统试用比较 分布式文件系统元数据分布方案对比 主流分布式文件系统比较 分布式文件系统FastDFS的神秘面纱 各种分布式文件系统简介 TFS（Taobao File System）-淘宝文件系统 海量小文件存储利器Mogilefs HDFS小文件处理解决方案总结+facebook(HayStack) + 淘宝（TFS）","categories":[{"name":"数据库","slug":"数据库","permalink":"http://rawbin-.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库比较","slug":"数据库比较","permalink":"http://rawbin-.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E8%BE%83/"},{"name":"关系型数据库","slug":"关系型数据库","permalink":"http://rawbin-.github.io/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://rawbin-.github.io/tags/NoSQL/"},{"name":"分布式文件系统","slug":"分布式文件系统","permalink":"http://rawbin-.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"程序员学习成长","slug":"dev-general/2015-04-23-for-programmer","date":"2021-12-31T02:37:59.885Z","updated":"2021-12-31T02:37:59.885Z","comments":true,"path":"dev-general/2015-04-23-for-programmer/","link":"","permalink":"http://rawbin-.github.io/dev-general/2015-04-23-for-programmer/","excerpt":"","text":"1 参考 不是技术牛人，如何拿到国内IT巨头的Offer 程序员技术练级攻略 What is a Full Stack developer? 5天学会一种 web 开发框架 让创业公司事半功倍的15款应用 盘点 Github 所用到的开源项目","categories":[{"name":"知识积累","slug":"知识积累","permalink":"http://rawbin-.github.io/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"}],"tags":[{"name":"学习经验","slug":"学习经验","permalink":"http://rawbin-.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/"}]},{"title":"大数据分析架构及相关工具","slug":"structure-algorithm/2015-04-23-bigdata-analysis","date":"2021-12-31T02:37:59.885Z","updated":"2021-12-31T02:37:59.885Z","comments":true,"path":"structure-algorithm/2015-04-23-bigdata-analysis/","link":"","permalink":"http://rawbin-.github.io/structure-algorithm/2015-04-23-bigdata-analysis/","excerpt":"","text":"1 参考 后Hadoop时代的大数据架构 多图技术贴：深入浅出解析大数据平台架构 大数据下的数据分析平台架构 大数据分析平台架构 大数据架构及行业大数据应用 Bigtable探秘 Google分布式数据存储系统 大数据处理分析的六大最好工具 十八款Hadoop工具帮你驯服大数据 大数据工具 玩转大数据：需要知晓的12种工具 强烈推荐！大数据领域的顶级开源工具大集合 Hadoop生态上几个技术的关系与区别：hive、pig、hbase 关系与区别 后Hadoop时代的大数据架构","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://rawbin-.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"数据分析","slug":"数据分析","permalink":"http://rawbin-.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://rawbin-.github.io/tags/Hadoop/"}]},{"title":"算法相关资料","slug":"structure-algorithm/2015-04-23-algorithm-related","date":"2021-12-31T02:37:59.885Z","updated":"2021-12-31T02:37:59.885Z","comments":true,"path":"structure-algorithm/2015-04-23-algorithm-related/","link":"","permalink":"http://rawbin-.github.io/structure-algorithm/2015-04-23-algorithm-related/","excerpt":"","text":"1 参考 实际项目中的常见算法 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集 可视化的排序过程 可视化的数据结构和算法 排序算法对比比较 Dictionary of Algorithms and Data Structures 一些重要的算法 数据挖掘十大经典算法 主宰全球的10大算法","categories":[{"name":"算法结构","slug":"算法结构","permalink":"http://rawbin-.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://rawbin-.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rawbin-.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"源代码阅读工具 代码审查工具","slug":"dev-tools/2015-04-18-read-source-code","date":"2021-12-31T02:37:59.885Z","updated":"2021-12-31T02:37:59.885Z","comments":true,"path":"dev-tools/2015-04-18-read-source-code/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2015-04-18-read-source-code/","excerpt":"","text":"1 工具推荐： Understand 效率高 连接性好 爽 Source Inside 还不错 看起来有点老 Source Navigator NG 可以试试 代码链接不太直观 2 参考 List of tools for static code analysis Static analysis tools for all programming languages 你用过的最好的代码阅读或编辑工具是什么？ 代码分析工具推荐Understand 代码分析工具推荐Understand 代码阅读工具：Source Navigator和Source Insight Windows下阅读linux源码的强大软件Source Insight linux源代码分析和阅读工具比较 Source Insight3.0: Linux源代码阅读的利器 阅读源代码的工具！","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"代码审查","slug":"代码审查","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/"}]},{"title":"IEEE 745 浮点数介绍 浮点数比较","slug":"dev-general/2015-03-31-ieee-745","date":"2021-12-31T02:37:59.884Z","updated":"2021-12-31T02:37:59.884Z","comments":true,"path":"dev-general/2015-03-31-ieee-745/","link":"","permalink":"http://rawbin-.github.io/dev-general/2015-03-31-ieee-745/","excerpt":"","text":"问题的由来JavaScript代码： //JavaScript console.log(0.3 - 0.2 == 0.2 - 0.1) //false Python代码： #！/usr/bin/env python # -*- coding:utf8 -*- print 0.3 - 0.2 == 0.2 - 0.1 #False 同样的原因：浮点数在数字计算机中表示不精确的问题。 JavaScript代码： //JavaScript console.log(0.3 - 0.2) //0.09999999999999998 console.log(0.2 - 0.1) //0.1 Python代码： #！/usr/bin/env python # -*- coding:utf8 -*- print 0.3 - 0.2 #0.09999999999999998 print 0.2 - 0.1 #0.1 都知道在数字计算机中用二进制位来表示数据，数字当然也不例外。 1 定点表示法二进制小数的表示方式为:bmbm-1…b3b2b1.b1b2b3…b-n+1b-n上式表示的数值为b = sum（bi * 2i）,其中-n &lt;= i &lt;= m这样就能很自然的表示我们的小数，这种小数点固定的表示方法叫做定点表示法（见名知意哦！） 然而，我们很快看出他的问题了，假设计算机字长为64位，我们要表示一个264的数字就已经把数位占完了，再大一丁点的数就没法表示了，比如说再大0.1，总得要一位表示小数吧？搞不定~~ 于是就有了下面的表示方法，有定点，自然就会有不定点，这种小数点不固定的方法（望文生义哦！）叫做浮点表示法（小数点浮动，^_^），这是计算机中普遍使用的表示方法。 2 浮点表示法浮点表示法就数位分为符号（sign）、指数（exponent）、有效位数（significant）（尾数）三部分：32位浮点数（单精度浮点数）表示：1位符号位，8位指数，23位尾数 31———————————-0 +-+——–+———————–+ 64位浮点数（双精度浮点数）表示：1位符号位，11位指数，52位尾数，能进一步提高精度。 63—————————————————————–0 +-+———–+—————————————————-+ 于是对于一个数b = （-1）s * M * 2E 综上可以看出浮点数的表示本身就不是精确值，精确的是2-i的和所以0.3 = 2-2+2-5+2-6+2-9…..0.2 = 2-3+2-4+2-7+2-8…..0.1 = 2-4+2-6+2-7+2-8…..省略号表示凑够尾数的有效位数为止。 由此可以看出，确实是很难用等于来判断浮点数的取值。 解决办法：A-B &lt;= 误差范围，差不多就行了比如说：(0.3-0.2) - (0.2-0.1) &lt;= 0.0000000001或者(0.3-0.2) - (0.2-0.1) &lt;= 1.0e-10 未完待续。。。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"IEEE 745","slug":"IEEE-745","permalink":"http://rawbin-.github.io/tags/IEEE-745/"},{"name":"浮点数","slug":"浮点数","permalink":"http://rawbin-.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"}]},{"title":"JSON XML 简要比较","slug":"dev-general/2015-03-30-json-xml-cmp","date":"2021-12-31T02:37:59.884Z","updated":"2021-12-31T02:37:59.884Z","comments":true,"path":"dev-general/2015-03-30-json-xml-cmp/","link":"","permalink":"http://rawbin-.github.io/dev-general/2015-03-30-json-xml-cmp/","excerpt":"","text":"1 一个实例:表示行政区数据 XML格式表示 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;country&gt; &lt;name&gt;中国&lt;/name&gt; &lt;provinces&gt; &lt;province&gt; &lt;name&gt;北京&lt;/name&gt; &lt;/province&gt; &lt;/provinces&gt; &lt;provinces&gt; &lt;province&gt; &lt;name&gt;河北&lt;/name&gt; &lt;cities&gt; &lt;city&gt; &lt;name&gt;石家庄&lt;/name&gt; &lt;/city&gt; &lt;city&gt; &lt;name&gt;保定&lt;/name&gt; &lt;/city&gt; &lt;/cities&gt; &lt;/province&gt; &lt;/provinces&gt; &lt;/country&gt; JSON格式表示 &#123; &quot;name&quot;:&quot;中国&quot;， &quot;provinces&quot;:[ &#123; &quot;name&quot;:&quot;北京&quot; &#125;, &#123; &quot;name&quot;:&quot;河北&quot;, &quot;provinces&quot;:[ &#123; &quot;name&quot;:&quot;石家庄&quot; &#125;， &#123; &quot;name&quot;:&quot;保定&quot; &#125; ] &#125; ] &#125; 2 最大的区别：JSON: JSON更轻量，解析效率更高，更省带宽和存储空间； 大文件没法分片解析，只能整体解析； 难以做规范性校验； 可读性要差些，在片面的数据下，不一定知道这个对象表示什么； XML XML能进行分片解析，再大的文件也能搞定解析的问题 XML可以通过Schema或者DTD等来做数据规范性校验； 可读性要好些； 3 参考文档： W3School JSON教程 JSON 官网 W3School XML教程 JSON与XML的区别比较","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://rawbin-.github.io/tags/JSON/"},{"name":"XML","slug":"XML","permalink":"http://rawbin-.github.io/tags/XML/"}]},{"title":"nginx 源码阅读 merge_slashes问题解决","slug":"nginx/2015-04-18-nginx-source-code","date":"2021-12-31T02:37:59.884Z","updated":"2021-12-31T02:37:59.884Z","comments":true,"path":"nginx/2015-04-18-nginx-source-code/","link":"","permalink":"http://rawbin-.github.io/nginx/2015-04-18-nginx-source-code/","excerpt":"","text":"1 问题描述使用nginx uWSGI django 做REST API开发。在URL中传入http://host/test/http://aa.com/,但在Django中收到的URI始终是http:/aa.com，嗯，就是少了斜杠，后来尝试发现多少个连续的斜杠都会被干掉只留下一个。 2 解决途径 查看nginx和uWSGI的日志，请求的路径都是正确的，即都为没有去掉斜杠的 查看Django源码，发现在django.core.handlers.base.BaseHandler中，处理URL匹配的时候使用的是path_info对应的值 于是找到处理类在django.core.handlers.wsgi.WSGIHandler,在这里打印请求获取到的path_info参数，发现已经是被去掉斜线的了。 怀疑是Nginx传过来的时候已经被处理过了 于是查看Nginx配置目录下，Nginx向uWSGI传的参数 uwsgi_param REQUEST_URI $request_uri; uwsgi_param PATH_INFO $document_uri; 于是把$document_url打印到Nginx的日志中，发现确实是处理过的 想看看在哪处理的，下了一份Nginx源码，翻到src/http/ngx_http_parse.c 果然有相关的逻辑（意思是配了这个值的话就不把重复的写进去了^_^废话） if (!merge_slashes) &#123; *u++ = ch; &#125; 能不能改改？翻了翻Nginx的模块配置文档发现可以，就用这个关键字搜 当然最后的解决办法不是直接修改这个配置，而是将要放在URL中的那一串串作为base64编码的结果再传递 3 参考 nginx源码分析（7）——请求处理 Nginx开发从入门到精通 运维与架构手册 linux下安装nginx、pcre、zlib、openssl nginx编译选项详解 Module ngx_http_core_module Nginx merge_slashes redirect","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://rawbin-.github.io/tags/Nginx/"},{"name":"Web服务器","slug":"Web服务器","permalink":"http://rawbin-.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"反向代理","slug":"反向代理","permalink":"http://rawbin-.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"}]},{"title":"JavaScript 模块加载工具 JSLoader","slug":"modules/2015-03-29-jsload-module","date":"2021-12-31T02:37:59.884Z","updated":"2021-12-31T02:37:59.884Z","comments":true,"path":"modules/2015-03-29-jsload-module/","link":"","permalink":"http://rawbin-.github.io/modules/2015-03-29-jsload-module/","excerpt":"","text":"随着Web应用的内容不断扩充，Web开发工作的不断细分，前端的模块化的呼声也越来越高。了解前端模块化可以看前端模块化–高效重构,以及前端模块化思路。 总的来说还是高内聚，低耦合，减少依赖和耦合，提高合作效率。 模块化在发展的过程中产出了一些规范，如AMD，CMD等，可以看看JavaScript模块规范,以及区别1和区别2. 也有一些关于AMD和CMD及其相关实现requirejs和seajs的讨论为什么我推荐requirejs 而不是seajs? JavaScript模块加载工具，解决我们在页面一次性加载所有需要用到的库文件，导致的性能和体验问题；做到按需加载。 不管怎样，抓到老鼠就是好猫，能有明显的优化效果就行。 1 其他参考资料 seajs 官网 seajs 文档 使用SeaJS实现模块化JavaScript开发 SeaJS所为何 为什么 SeaJS 模块的合并这么麻烦 requirejs 英文 requirejs 中文 [利用browserify or requirejs 来构建angularjs](“http://www.tuicool.com/articles/UNrq22&quot;,&quot;利用browserify or requirejs 来构建angularjs”)","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"seajs","slug":"seajs","permalink":"http://rawbin-.github.io/tags/seajs/"},{"name":"requirejs","slug":"requirejs","permalink":"http://rawbin-.github.io/tags/requirejs/"},{"name":"AMD","slug":"AMD","permalink":"http://rawbin-.github.io/tags/AMD/"},{"name":"CMD","slug":"CMD","permalink":"http://rawbin-.github.io/tags/CMD/"}]},{"title":"Selenium 浏览器截图，网页截图，浏览器操作","slug":"dev-tools/2015-03-30-using-selenium","date":"2021-12-31T02:37:59.884Z","updated":"2021-12-31T02:37:59.884Z","comments":true,"path":"dev-tools/2015-03-30-using-selenium/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2015-03-30-using-selenium/","excerpt":"","text":"Selenium 是一个Web自动化测试的套件使用前需要安装selenium包: #! /usr/bin/env python # -*- coding: UTF-8 -*- from selenium import webdriver browser = webdriver.Firefox() browser.set_window_size(1024,768) browser.get(&#39;http://www.baidu.com/s?wd=selenium&#39;) browser.save_screenshot(&#39;page.png&#39;) browser.quit() 需要注意的是，使用chrome需要安装相应的驱动，叫chromedriver的可执行文件，放入$PATH 截图是针对浏览器页面，即使浏览器窗口被其他应用程序窗口覆盖也没有关系。 1 参考资料 [ReadTheDoc文档][1] [selenium官网][2] [selenium官方文档][3] [selinium pypi文档说明][4] [selinium on GitHup][5] [1]: https://selenium-python.readthedocs.org/ ReadTheDoc文档 [2]: http://www.seleniumhq.org/ 官网 [3]: http://www.seleniumhq.org/docs/ 官方文档 [4]: https://pypi.python.org/pypi/selenium pipy实例 [5]: https://github.com/SeleniumHQ/selenium/tree/master/py GitHub","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Selenium","slug":"Selenium","permalink":"http://rawbin-.github.io/tags/Selenium/"},{"name":"Python 网页截图","slug":"Python-网页截图","permalink":"http://rawbin-.github.io/tags/Python-%E7%BD%91%E9%A1%B5%E6%88%AA%E5%9B%BE/"},{"name":"自动截图","slug":"自动截图","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E6%88%AA%E5%9B%BE/"}]},{"title":"Markdown 语法简要说明","slug":"language/2015-03-18-using-markdown","date":"2021-12-31T02:37:59.883Z","updated":"2021-12-31T02:37:59.883Z","comments":true,"path":"language/2015-03-18-using-markdown/","link":"","permalink":"http://rawbin-.github.io/language/2015-03-18-using-markdown/","excerpt":"","text":"1 Markdown简介Markdown是一种纯文本的标记方式，的目标是实现易读易写的纯文本编辑，使作者能更专注于文档写作，弱化文档排版。 Markdown兼容HTML，适合于Web发布，能解决PDF，Word等文档需要特定的阅读工具才能阅读的问题，只需要手边的浏览器和简单的文本编辑器就可以进行阅读和编辑。 每个关键符号之后需要有空格或者空行才能进行正确的解析，比如&gt; , + 等；当然这些内容基本都是可以嵌套的，嵌套的时候增加相应的缩进即可。 1.1 标题标题通过在行首输入#来表示，#的个数（1-6）表示1级至6级标题，字号从1级到6级依次缩小（分别对应HTML的H1至H6标签），如 #一级标题 ######六级标题 显示为 #一级标题######六级标题 1.2 列表无序列表使用*，+，-来表示（别忘了其后跟空格），对应HTML的li，如 + 项目一 + 项目二 + 项目三 显示为 项目一 项目二 项目三 有序列表只需要把上面的符号换成数字即可 1.3 粗体和斜体Markdown 用*和_表示,左右两个星号或者两个下划线表示加粗，左右一个星号或者一个下划线表示斜体,如： **加粗** *斜体* __加粗__ _斜体_ 显示为 加粗 斜体 加粗 斜体 1.4 区块引用Markdown用&gt;来表示信息的引用,如： &gt; 这是引用块 &gt; 这也是引用块 显示为 这是引用块 这也是引用块 1.5 代码块使用反引号 `(ESC下边的符号)，来标记代码块，代码块中的&amp;, &lt;, &gt;等符号都会被转换成HTML的信息&amp; &lt; &gt; 这是代码段信息, &amp;, &lt;, &gt;等特殊字符 如果要输出格式化好的代码，则需要每行缩进4个空格，或者一个Tab如： def func_demo: print &#39;Hello world&#39; 显示为 def func_demo: print &#39;Hello world&#39; 1.6 超链接Markdown行内方式为**[链接文字](链接URL，&quot;链接标题&quot;)**,链接标题在鼠标放上去时显示，如 [显示的文字](http://github.com &quot;URL标题&quot;) 显示为 显示的文字 Markdown作为参考链接的书写方式为 [链接文字][参考链接ID], 可以在任何地方定义参考的链接;链接的定义方式为： [lind_id]: link_url &quot;link_title&quot;如： [github主站][github] [github]: http://github.com &quot;github title“ 显示为 [github主站][github][github]: http://github.com “github title” 还可以隐式链接的方式来写**[隐式链接显示文字][]，然后同样定义一个链接，如**[隐式链接显示的文字]: http://github.com如: [懒人链接][] [懒人链接]: http://github.com 显示为 [懒人链接][][懒人链接]: http://github.com 1.7 图片Markdown行内图片的定义方式为：**![图片描述](图片路径, &quot;图片标题&quot;)**如: ![演示图片](/abspath/for/image, &quot;图片标题&quot;) 显示为 当然也可以像超链接那样写成参考材料的方式,如 ![演示图片][demo_img] [demo_img]: /abspath/for/image &quot;图片标题&quot; 显示为 ![演示图片][demo_img][demo_img]: /abspath/for/image “图片标题” 1.8 转义上面我们看到比如说. * _ + - !等，如果需要原样显示的话，需要用反斜杠()进行相应的转义。 1.9 分割线三个以上的星号或者减号一起就能表示分割线，星号之间可以用空格，但行内不能有其他内容,如： * * * - -- 显示为 1.10 相关的编辑器大致可以参考：小众软件，segmentdefault，open-oen等对相关工具的介绍。 1.11 参考文档: Markdown快速入门 Markdown完整语法 Markdown语法说明","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://rawbin-.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://rawbin-.github.io/tags/Markdown/"}]},{"title":"使用Github 搭建自己的博客","slug":"knowledge-management/2015-03-18-using-github-pages-as-blog","date":"2021-12-31T02:37:59.883Z","updated":"2021-12-31T02:37:59.883Z","comments":true,"path":"knowledge-management/2015-03-18-using-github-pages-as-blog/","link":"","permalink":"http://rawbin-.github.io/knowledge-management/2015-03-18-using-github-pages-as-blog/","excerpt":"","text":"利用github pages 搭建自己的博客，搭建完成之后，可以直接用markdown来写博客，之后直接push到github就可以在网页上看到自己的博客了。 我喜欢这一点的一个很大的原因是，不需要一张一张的向网页上插图了，直接放入目录，一次提交就完成。 1 大致原理是： github pages 用来给用户或者项目建主页的 github pages 是用jekyll 这个引擎来解析的 我们可以利用这个来解析我们自己的markdown 通过jekyll 可以配置一些自动生成的样式和模板 2 基本部署过程2.1 普通的过程： 安装Ruby，Devkit，Jekyll 参考 用jekyll 自动生成一个目录结构 (jekyll new xxx) 将你的md 文件按照_post下的文件命名方式重命名 将整个目录一并提交到github 通过github pages访问你的博客 2.2 定制页面分隔（带归档分类） 安装Ruby，Devkit，Jekyll 参考 切换国内淘宝源 部署 Jekyll Bootstrap,参考Jekyll BootstrapJekyll Bootstrap 附带了几个实用的命令，可以用rake来构建，具体可参考主目录下的Rakefile这样就可以得到一个，能加标签和分类并能分类展示的博客。 同样是提交到username.github.io这个代码库中 3 参考文档： github pages jekyll github pages help github pages wizard 使用 GitHub, Jekyll 打造自己的独立博客 Github+Jekyll构建个人博客 通过GitHub Pages建立个人站点（详细步骤） 使用 GitHub, Jekyll 打造自己的免费独立博客 在 Windows 上安装 Jekyll 如何将你的github仓库部署到github pages jekyllrb 官方网站 jekyll安装 搭建一个免费的无流量的博客 Jekyll-Bootstrap Github Jekyll-Bootstrap","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://rawbin-.github.io/tags/GitHub/"},{"name":"Jekyll","slug":"Jekyll","permalink":"http://rawbin-.github.io/tags/Jekyll/"},{"name":"博客","slug":"博客","permalink":"http://rawbin-.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"站点","slug":"站点","permalink":"http://rawbin-.github.io/tags/%E7%AB%99%E7%82%B9/"},{"name":"Jekyll Bootstrap","slug":"Jekyll-Bootstrap","permalink":"http://rawbin-.github.io/tags/Jekyll-Bootstrap/"}]},{"title":"VIM常用操作命令梳理","slug":"dev-tools/2015-03-18-using-vim","date":"2021-12-31T02:37:59.883Z","updated":"2021-12-31T02:37:59.884Z","comments":true,"path":"dev-tools/2015-03-18-using-vim/","link":"","permalink":"http://rawbin-.github.io/dev-tools/2015-03-18-using-vim/","excerpt":"","text":"1 打开关闭 vim xxx，vim +num xxx 命令行打开文件 vim + filename 启动跳到文件结尾 vim +143 filename 打开跳到143行 调试代码有用 vim +/search-term filename 跳到第一个匹配 vim +/search-term filename 跳到最后一个匹配 vim -t tag vim –cmd command filename 加载文件前执行命令 vim -c “:50” filename 加载文件后执行命令 :e xxx vim中打开文件 :w[rite],:up[date],:w!,up!，:wall保存文件 :x,:q,:qa,:q!,退出文件 gf 普通模式下打开文件名为光标处文字的文件 Ctrl+W f 新窗口打开匹配的文件 Ctrl+W fg 新tab页打开匹配的文件 2 代码相关 &lt;,&gt;对代码进行缩进 &lt;&lt;,&gt;&gt;用于调整源代码缩进格式 = 用户自动格式化代码缩进，gg=G 即为全文格式化 zf,zo,zc,za,zR,zM对代码进行折叠打开折叠 Ctrl+],Ctrl+T查找函数的定义和返回 大写K，看光标所指标识符的man帮助 3 移动光标 h,j,k,l ←↓↑→ 移动光标，相当于四个方向键 w,b,e,ge 以单词的方式移动，可以nw，nb，ne，nge的方式移动n个单词的距离 W，B，E，gE会以连续字符串的方式移动 0,^,g_,$，n$移动到行首，行尾以及后面第n行的行尾 gg,G,nG，ngg 移动到文件头和文件尾，以及移动到文件的第n行，‘可以回到上一次的地方 H,M,L n%定位光标到当前屏幕的某个地方 {,},[[,]],(,) 段落，区块，语句导航 z回车，z-,zz.当前行置顶，置底，置中 Ctrl+G显示当前位置信息 Ctrl+F，Ctrl+B，Ctrl+U,Ctrl+D,Ctrl+E,Ctrl+Y,向前后滚动一屏，半屏，一行 Ctrl+I,Ctrl+O 光标移到下一次和上一次的地方，Ctrl+I 和Tab功能一样 ‘,”,[,]为跳转前的位置，最后编辑的光标位置，最后修改的开始位置，最后修改的结束位置 Ctrl+^ 在两个文件之间轮换 ‘“,’.，`.上一次光标的地方，上一次修改的地方 4 编辑 i,a,o,I,A,O分别进入插入模式 o 在当前光标所在行下方插入一行，O在当前光标所在行上方插入一行 J 删除换行符，合并两行 Ctrl-R 重做 u，nu撤销上一次更改，撤销n次更改 U 撤销整行的更改 Ctrl+R 重做更改 Ctrl+L 重新加载屏幕内容 y,d,p 表示拷贝，删除，粘贴，配置位置描述使用 yw，dw，y0,d0,y$,d$,yfa,dfa,yy,dd,D,dG,dgg等，前面可以加数字，表示重复如，3dd,3yy等，也可以加范围，如4,8yy %y+.y+,N,My+ 拷贝指定的数据 :[range] g[lobal[!]] /{pattern}/ [cmd] :[range] v[global[!]] /{pattern}/ [cmd] n,p,next,previous,Ctrl+^在编辑的文件中切换 :ls 查看打开的文件 :e #n 打开标号为ls结果中的文件 :changes 查看文件变化 ga查看ASCII,十进制，十六进制 5 查找 /pattern-回车 在文件内向后查找pattern的匹配，n重复，N回退，n前面可以带数字 ?pattern-回车 在文件内向前查找pattern的匹配，n重复，N回退，n前面可以带数字 f{char}/t{char} 在行内查找下一指定字符， ;重复， ,回退 F{char}/T{char} 在行内查找上一指定字符， ;重复， ,回退 *，#高亮所有匹配光标所在单词，相当于输入了/word,如果想单独匹配单词/&amp;lt;word&amp;gt;,则需要g*,g# ，gd提留在非注释段的第一个匹配 &lt;,\\&gt;表示匹配单词的开头和结尾 .,^,$在查找的过程中作为正则策略，如果需要完全匹配需要转义 % 查找匹配的括号() [] {} 6 替换 . 重复上次的修改（一定要是修改） 比如说上次删除一个字符，点就是删除一个字符的意思；如果上次是删除一行，点就是删除一行的意思了。 &gt;G 当前行缩进一个单位（Tab） :[range]s[ubstitute]/{pattern}/{string}/[flags] 将范围内的from 改为to，替换当前行 :[range]%s[ubstitute]/{pattern}/{string}/[flags] 将范围内的from 改为to,替换所有行 范围可以指定为m,n的数字形式，当个的数字表示特定的行，.表示当前行，如果字符串中本身包含/,则可用+，=替换原来的/ :[range]s[ubstitute]/{pattern}/{string}/[flags] [count] 7 外部&amp;&amp;内部命令 :shell 交互式shell :!cmd 执行cmd并输出结果 :! 执行上一次的命令 :r[ead] !cmd当前光标写入命令结果 :上下方向键 查找命令 :[range]co[py] {address} 复制指定范围的行到指定地址，简写为t 理解为copyto :[range]m[ove] {address} 移动命令 :@:重复VIM命令，.重复普通命令 Ctrl+D补全命令 :[range] delete [x] :[range] yank [x] :[range] put [x] :[range] copy {address} :[range] move {address} :[range] normal {commands} :[range] join :[range] substitute/{pattern}/{string}/[flags] :[range] global/{pattern}/[cmd] 8 选项设置 set xxx 设置某项 set noxxx 取消某项设置 set xxx! 反置某项值 set xxx&amp; 恢复默认值 set xxx? 查询当前状态+ setlocal 局部有效，set全局有效+ :set expandtab 将tab转换为space :set tabstop=4 制表符宽度 tabstop=4或ts=4 :retab 按照设定值重新缩进 :set shiftwidth=4 行缩进时宽度 :set ai 自动缩进 8.1 代码格式化 = 全文格式化 gg=G，比如粘贴的内容 当前行格式化缩进 == 当前光标所在行的后N行格式化 N== 选中行格式化，= 9 参考资料 VIM手册 VIM FAQ 《Vim 101 Hacks》 技巧：快速提高 Vi/Vim 使用效率的原则与途径 两篇很牛的vim使用技巧 无插件Vim编程技巧 最全的vim快捷键 普通人的编辑利器——Vim VIM FAQ VIM显示utf-8文档乱码解决方法 强大的vim配置文件，让编程更随意 UTF-8、GBK、GBK2312等字符编码的区别和vim乱码等相关问题研究 Vim/gVim 中文显示为乱码的解决办法","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"开发工具","slug":"开发环境/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"VIM","slug":"开发环境/开发工具/VIM","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VIM/"}],"tags":[{"name":"VIM","slug":"VIM","permalink":"http://rawbin-.github.io/tags/VIM/"},{"name":"快捷键","slug":"快捷键","permalink":"http://rawbin-.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}]},{"title":"Bash Shell 命令行操作快捷键","slug":"language/shell/2015-03-18-shell-cheats-shortcuts","date":"2021-12-31T02:37:59.883Z","updated":"2021-12-31T02:37:59.883Z","comments":true,"path":"language/shell/2015-03-18-shell-cheats-shortcuts/","link":"","permalink":"http://rawbin-.github.io/language/shell/2015-03-18-shell-cheats-shortcuts/","excerpt":"","text":"快速、高效 ^_^ 1 方向移动 Ctrl+A 光标移动到行首，相当于Home键 Ctrl+E 光标移动到行尾，相当于End键 Ctrl+B 光标左移一个字符，相当于←方向键 Ctrl+F 光标右移一个字符，相当于→方向键 Ctrl/Alt+← 光标移动到前一个单词的开头 Ctrl/Alt+→ 光标移动到后一个单词的结尾 ESC+B 光标移动到前一个单词的开头 ESC+F 光标移动到后一个单词的结尾 Ctrl+X+X 光标在光标所在字符和光标上一次所在字符之间切换 2 字符删除/恢复（删除为剪切） Ctrl+D 删除光标所在处的字符，并向右删除，相当于Del键；最后一次可退出当前Shell Ctrl+H 删除光标左侧的字符，相当于Backspace Ctrl+K 删除从光标所在处字符及其后的所有字符，相当于长按Del键 Ctrl+U 删除从光标所在处字符前面（到行首）的所有字符，相当于长按Backspace键 Ctrl+L 清屏，删除屏幕的所有输出，相当于Linux clear命令 或Windows cls命令 Ctrl+W 删除光标左侧的一个单词 ESC+D 删除光标右侧的一个单词 Ctrl+? 撤销前一次操作 Ctrl+Y 粘贴上一次剪切的内容 3 交换 Ctrl+T 交换光标前两个字符位置 ESC+T 交换光标前两个单词位置 4 命令相关快捷键 Ctrl+C 结束当前命令 Ctrl+R 在历史命令中查找,输入关键字过滤，重复命令进行滚动查找 Ctrl+Z 挂起/停止命令，前后台切换，可用fg，bg命令恢复 Ctrl+P 上一条命令，相当于↑方向键 Ctrl+N 下一条命令，相当于↓方向键 5 命令相关快捷操作 !! 执行上一条命令 12apt-get install xxxsudo !! #equals &#x27;sudo apt-get install xxx&#x27; !xxx 执行最近的以xxx开头的命令 !xxx:p 打印最近的以xxx开头的命令 !$ 上一条命令的最后一个参数 12cat /etc/passwdvim !$ #equals &#x27;vim /etc/passwd&#x27; !$:p 打印上一条命令的最后一个参数 !* 上一条命令的所有参数 !*:p 打印上一条命令的所有参数 ^xxx 删除上一条命令中的第一个xxx并执行 12cat /etc/password^or #equals &#x27;cat /etc/passwd&#x27; ^xxx^yyy 将上一条命令中的第一个xxx替换为yyy并执行 ^xxx^yyy^ 将上一条命令中的所有xxx替换为yyy并执行 6 其他 Ctrl+S 锁定终端 Ctrl+Q 解锁终端 Ctrl+I 自动补全，相当于Tab键 Ctrl+J 相当于Enter Ctrl+O 相当于Enter explainshell.com shell命令文档解释 7 参考文档： 高级Bash编程指南 《Linux与Unix Shell编程指南》 《Linux 命令行和Shell脚本编程宝典》 [Linux Shell 快捷键1][1] [Linux Shell 快捷键2][2] [1]: http://blog.chinaunix.net/uid-361890-id-342066.html Linux Shell 快捷键[2]: http://blog.sina.com.cn/s/blog_7556be720100ryp2.html linux下的shell 快捷键","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"开发工具","slug":"开发环境/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"编程语言","slug":"开发环境/开发工具/编程语言","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://rawbin-.github.io/tags/Linux/"},{"name":"快捷键","slug":"快捷键","permalink":"http://rawbin-.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"Shell","slug":"Shell","permalink":"http://rawbin-.github.io/tags/Shell/"}]},{"title":"Git使用教程及相关问题解决","slug":"dev-tools/git/2015-03-18-using-git","date":"2021-12-31T02:37:59.883Z","updated":"2021-12-31T02:37:59.883Z","comments":true,"path":"dev-tools/git/2015-03-18-using-git/","link":"","permalink":"http://rawbin-.github.io/dev-tools/git/2015-03-18-using-git/","excerpt":"","text":"1 一些概念 工作副本（Working Copy）：你的代码相关的一切，你自己弄得文件和目录。 暂存区(Stage,Index): 对工作副本需要提交的信息的一个跟踪,存储在工作副本目录下.git/index的文件里面，记录通过git add 结果的文件信息。 本地仓库（Repository）： 本地的代码版本库，为git commit的目标区。 远程仓库（Remote Repository）： 远程的代码版本库，为git push 的目标区HEAD: 记录当前工作副本，最后一次提交的版本。origin: 默认的远程库主机名，与hosts类似。master: 默认的名称为master的分支（或者可以叫主分支，trunk）。 1—-git add—-&gt;2—-git commit—-&gt;3————–git push————&gt;4 1————-git commit -a———&gt;3 1&lt;————git checkout———–3&lt;——–git fetch/clone———–4 1&lt;————————–git pull————————————-4 2 配置SSH Key认证，配置多个账户2.1 配置 SSH-Key 认证 生成ssh key ssh-keygen -t rsa &quot;youemail&quot; Tips： 存储的路径是绝对路径，在非bash环境下，windows中的路径需要改一改，phrase有没有都没有关系 配置多个账户如果你需要向不同的git中提交内容，可能还使用不同的ssh认证，比如说公司git和个人git你需要为不同的主机配置多个不同的ssh key认证，步骤如下： 切换到~/.sshwindows下的路径为 c:\\username.sshLinux路径为/home/username/.ssh/ 编辑配置文件 config输入以下内容： Host host1 HostName host1.test.com User test1 IdentityFile ~/.ssh/test1_id_rsa Host host2 HostName host2.test.com User test2 IdentityFile ~/.ssh/test2_id_rsa Tips：以上写法在git bash环境下可以支持，否则，ssh查找key的路径为 /home/username/.ssh这样在windows 环境下是无效的。 3 问题解决3.1 Permission Denied（publickey）在cmd,powershell,xshell中执行git 操作会有这样的权限不足的提示原因是，在没有bash环境的命令行下， 执行git会找/home/username/.ssh/而这个路径在windows下是不存在的，而且也不会做C:\\uername.ssh\\到 /c/username/.ssh/的转换所以根本就找不到ssh key，自然无法认证，导致认证失败 解决办法：windows 下给git增加 bash环境在windows中安装git中，会选择git的环境的PATH，在命令行使用git，三个选项： Use Git from Git Bash only Use Git from the Windows Commond Prompt Use Git and opotional Unix tools from the Windows Command Prompt 在第一个选项中，只有在git bash中使用git的时候，才会正确找到~/.ssh的路径，会做c:\\username.ssh\\ 到/c/username/.ssh/的转换,所以即使你把所有的git bin目录加入到PATH中，在非git bash的命令行下，同样也会得到Permission Denied（publickey）的结果 在第二个选项中，在git bash 和 windows 命令行中对git相关的命令做相应的转换，这样在Windows命令行和Git bash下都能正确的进行ssh key 认证。 第三个选项，会将所有git安装的所有的命令都做相应的转换。包括ssh等命令。 测试方法使用ssh 命令测试对github的连接，分别git bash和windows命令行中测试如下命令，在调试信息中可以看到输出结果。 ssh -v github.com ssh -vv github.com 3.2 git 每次输入都需要输入用户名和密码 存储用户名和密码在使用HTTPS协议的情况下，是需要输入用户名和密码的，可以存储在配置文件中，或存储在URL中，不过这样的安全性会降低 使用SSH协议的URLgit支持多种协议的，选择ssh连接的url，替换本地工作副本下的文件中的https协议的url路径为WorkingCopy/.git/config这样就可以使用ssh认证，而不需要每次都输入用户名密码，甚至连密码都不需要输入（如果你的ssh key没有设置密码的话） 4 参考资料 Git教程和基本原理 Git Book中文 Git Book English Git Reference 图解Git中文版 手把手教你使用git Git常用命令 Git常用命令整理 Git Community Book中文 Git Manual Git简明指南 Git简易指南 Git远程操作详解 看日记学Git 易百Git教程 Git工作区，暂存区和版本库 Git工作区和暂存区讲解 Git SSH key本地多个SSH key Git多账号登陆 多个git账户生成多份rsa秘钥实现多个账户同时使用配置 Git ssh多账户管理 git初体验（七）多账户的使用 Git Push 避免用户名和密码的方法","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://rawbin-.github.io/tags/Git/"},{"name":"Git SSH 配置","slug":"Git-SSH-配置","permalink":"http://rawbin-.github.io/tags/Git-SSH-%E9%85%8D%E7%BD%AE/"}]},{"title":"Web开发中的编码解码乱码问题深入解析","slug":"encoding-decoding/2015-03-17-encoding-decoding-discoding","date":"2021-12-31T02:37:59.882Z","updated":"2021-12-31T02:37:59.882Z","comments":true,"path":"encoding-decoding/2015-03-17-encoding-decoding-discoding/","link":"","permalink":"http://rawbin-.github.io/encoding-decoding/2015-03-17-encoding-decoding-discoding/","excerpt":"","text":"1 基本概念 字符：各种文字和符号的统称，包括各国各族各地的文字，标点符号，图形符号，数字等。 字符集： 字符的集合，比如汉字字符集，ASCII字符集，简体中文字符集，罗马字母等。字符集关心的是这个集合需要包含哪些东西，怎么唯一表示这个集合中的每一个元素。 字符编码： 将字符集处理为计算机能够识别和处理的规则。字符编码关注一个字符如何用二进制表示，如何让计算机精确识别。 内码: 内码是指计算机汉字系统中使用的二进制字符编码，是沟通输入、输出与系统平台之间的交换码，通过内码可以达到通用和高效率传输文本的目的。比如MS Word中所存储和调用的就是内码而非图形文字。英文ASCII字符采用一个字节的内码表示，中文字符如国标字符集中，GB2312、GB12345、GB13000皆用双字节内码，GB18030（27,533汉字）双字节内码汉字为20,902个，其余6,631个汉字用四字节内码。 编码操作： 将信息转换为二进制串的过程。(字符–&gt;字节) 解码操作： 将字符从二进制串中还原的操作。(字节–&gt;字符) 1.1 编码和字符集关系 ASCII字符集: ASCII编码 ISO 8859-*字符集: ISO 8859-*编码 GB2313字符集： GB2312编码 BIG5字符集： BIG5编码 GB18030字符集： GB18030编码 UCS字符集： UCS-2编码，UCS-4编码 Unicode字符集：UTF-7，UTF-8编码，UTF-16编码，Unicode编码（UCS-2），Unicode大端，Unicode小端，UTF-32编码 ANSI: 使用2个字节来代表一个字符的各种汉字延伸编码方式，称为ANSI编码。 在简体中文系统下，ANSI编码代表GB2312编码，在日文操作系统下，ANSI编码代表JIS编码。 2 文件编码每个键盘按键都有一个对应的编码，这个是与硬件相关的、跟厂家相关的（扫描码）。为了使各个硬件厂商间的键码进行兼容，出台了一个通用的键盘编码（虚拟键码），虚拟键码是与硬件无关的，不同厂家使用同一套虚拟键码。(默想冯洛伊曼体系)。 汉字的输入过程：各种输入码—交换码（国标码）—内码—字形码（显示汉字，打印汉字）. 输入过程（你在记事本里面写东东）： 打开记事本，切换输入法，并输入“简单”，这里用到的是外码（也叫输入码），不同输入法编码不一样，自然外码也不一样。 键盘驱动程序检测到键盘输入的硬件信号（扫描码），把键码转换为虚拟键码（ASCII），然后将扫描码和虚拟键码（ASCII）及相关信息通过操作系统发给输入法程序 输入法程序将收到的信息转换为汉字内码，同时将汉字内码对应的输出码（字形码）通过操作系统返回给应用程序 应用程序（notepad）处理消息内容，并作出进一步响应。 点击保存，可以选择编码ANSI为系统默认编码，可选Unicode的一种。 应用程序(notepad)将文件内容进行编码并通过操作系统的文件管理系统保存文件。 输出过程（你用记事本打开你写的东东）： 应用程序打开文件（记事本打开文件），应用程序向操作系统读取文件内容（读到的是汉字内码） 操作系统给应用程序返回字节流（汉字内码） 应用程序探测二进制流的编码，并按得到的编码解码，如果没有检测到特征，则按系统默认编码解码（发现是汉字，找汉字字库找对应的的字形码发给显示驱动程序进行显示）。 显示驱动程序把汉字的点阵打到显示器上。比如在记事本中输入“联通”，然后以ANSI编码，然后关闭再打开，可以看到乱码，因为记事本搞不清楚编码格式，认为是UTF8。 2.0.1 参考 字符，字节和编码 输入法工作原理 输入法工作原理 键盘输入工作原理 键盘输入工作原理 关于输入法的工作原理及编程 输入法的基本原理 关于输入法的工作原理及编程 谈谈Windows程序中的字符编码 Windows基础-[文字编码]&lt;转: 编码术语&gt; 文件编码格式（转） 汉字编码表示与显示 汉字编码与编程相关问题总结：ASCII、机内码、区位码、国标码、Unicode码是如何转换的 3 浏览器编码3.1 URL编码 网址编码在浏览器地址栏输入中文，并回车，浏览器会对URL进行UTF-8编码，并将编码后的结果回写入地址栏。如：输入 http://www.baigoogledu.com/北京，然后回车得到 http://www.baigoogledu.com/%E5%8C%97%E4%BA%AC，是UTF-8编码 查询串编码在查询字符串中输入中文，并回车；浏览器对URL进行UTF-8编码，并且结果不回写。如： http://www.baigoogledu.com/?l=北京得到： http://www.baigoogledu.com/?l=%E5%8C%97%E4%BA%AC JavaScript AJAX，GET，POST可以用firebug的console简单测一下，还是UTF-8 var r = new XMLHttpRequest(); var methods = [&#39;get&#39;, &#39;post&#39;]; var url =&#39;http://www.baigoogledu.com/北京&#39;; for(var method in methods)&#123; r.open(&#39;post&#39;,url,null) r.send() &#125; 3.2 请求相关在HTTP中，与字符集和字符编码相关的消息头是Accept-Charset/Content-Type，另外主区区分Accept-Charset/Accept-Encoding/Accept-Language/Content-Type/Content-Encoding/Content-Language：Accept-Charset：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）；Accept-Encoding：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）；Accept-Language：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。例如：Content-Type: text/html; charset=’gb2312’Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzipContent-Language：WEB服务器告诉浏览器自己响应的对象的语言。 3.3 页面编码HTML文档是作为带有字符编码信息的字节流在网络中传送。编码信息可以在HTTP响应头中指定(header)，也可以在HTML标签中指定（&lt;meta&gt;）。浏览器根据字符编码信息将字节流转换为显示在浏览器上的字符集合。 浏览器获取编码的过程是 如果用户指定了编码，则按用户指定的编码进行解码。 先对文件进行预解析，如果文件存在BOM（Byte Order Mark），则按BOM确定的编码解码。 如果HTTP响应头中存在编码信息，则按响应头中的编码进行解码。 先按浏览器的编码选择算法选择一个编码进行预解析，如果解析出标签中存在字符集设置，则按标签中的字符集进行解码。 按浏览器的默认编码。 3.3.1 参考 网络编程中的编码问题汇总 各种编码UNICODE、UTF-8、ANSI、ASCII、GB2312、GBK详解 浏览器如何解析HTML字符编码 百分号编码 说说http协议中的编码和解码 深入理解浏览器解析机制和XSS向量编码 浏览器编码 关于URL编码 Unicode与JavaScript详解 URL编码与解码 4 终端编码4.1 SSH终端编码使用putty 连接服务器的时候，页面中显示的中文有时候会出现乱码，可以通过更改终端的的编码方式来解决，默认为系统编码。 4.2 mysql 命令行乱码在windows命令行下，插入中文数据或者查询结果中有中文数据的时候，会出现乱码。输入命令 show variables like ‘character_set_%’; 查看当前设置的编码情况在命令行输入 :set names utf8;则等同于set character_set_client=utf8;set character_set_results=utf8;set character_set_connection=utf8;这连续的三条命令。在命令行插入数据之前执行命令set names gbk;或者set names gb2312;再插入 查询数据之前执行命令set names gbk;或者set names gb2312; 完了之后再set names utf8;这样就能正常插入和查询中文并且保持数据库编码为utf8 4.3 windows gvim 中文乱码$VIM_HOME/vimrc文件末尾添加如下几行：let &amp;termencoding=encodingset fileencodings=utf-8,gb2312,gbkset encoding=gbk 5 语言内部编码5.1 python python 2.x 内部使用Unicode字符集 5.1.1 代码编码 python的文件头部可以通过 #-*- coding: utf-8 -*-的方式来指定源代码的编码，通常在源文件中有非ASCII字符时使用。文件头部编码声明决定了python解析源码中的str的编码选择方式，比如头部声明的是utf-8编码，则代码中s=”中文”python就会按照utf-8编码格式来解析，通过repr(s)可以看到字符编码是”\\xe4\\xb8\\xad\\xe6\\x96\\x87”，如果头部声明的编码是gbk编码，则python会对s采用gbk编码解析，结果是”\\xd6\\xd0\\xce\\xc4”。 需要注意的是，文件本身的编码要跟文件头部声明编码一致，不然就会出现问题。文件本身的编码在Linux下面可以在vim下用命令set fenc来查看。如果文件本身编码是gbk，而源码文件头部声明的编码是utf-8，这样如果源码中有中文就会有问题了，因为本身中文str存储是按照gbk编码来的，而python在解析str的时候又以为是utf-8编码，这样就会报SyntaxError: (unicode error) ‘utf8’ codec can’t decode byte错误。 #coding: utf-8 u = u”中文” print repr(u) # u’\\u4e2d\\u6587’ s = &quot;中文&quot; print repr(s) # &#39;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#39; u2 = s.decode(&quot;utf-8&quot;) print repr(u2) # u&#39;\\u4e2d\\u6587&#39; #s2 = u.decode(&quot;utf-8&quot;) #编码错误 #u2 = s.encode(&quot;utf-8&quot;) #解码错误 注意实例中注释掉的2行代码，对于unicode最好不要直接调用decode，str最好不要直接调用encode方法。因为如果是直接调用，则相当于u.encode(default_encoding).decode(\"utf-8\")，default_encoding是python的unicode实现中用的默认编码，即sys.getdefaultencoding()得到的编码,如果你没有设置过，那么默认编码就是ascii，如果你的unicode本身超出了ascii编码范围就会报错。同理，如果对str直接调用encode方法，那么默认会先对str进行解码，即s.decode(default_encoding).encode(“utf-8”),如果str本身是中文，而default_encoding是ascii的话，解码就会出错，从而导致上面这两行会分别报UnicodeEncodeError: 'ascii' codec can't encode characters in position...错误和UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position...错误。 5.1.2 文件读写编码采用python的open()方法打开文件时，read()读取的是str，编码就是文件本身的编码。 5.2 javascriptJavaScript 采用Unicode字符集，使用UCS-2编码，也就是现在UTF-16的一部分 5.2.1 参考 Unicode与JavaScript Unicode HOWTO Python编码和Unicode python 文件编码 字符串编码 文件读写 文件编码控制 编码转换 python 字符编码与解码——unicode、str和中文：UnicodeDecodeError: ‘ascii’ codec can’t decode 【总结】Python 2.x中常见字符编码和解码方面的错误及其解决办法 详解 python 中文编码与处理 python 中文乱码 问题深入分析 Python编码问题详解 Python字符编码详解 python读写文件，和设置文件的字符编码比如utf-8 6 编码检测6.1 vim中使用:set fileencoding 或者set fenc来显示文件编码 6.2 notepad++中使用格式菜单来查看文件编码","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"编码","slug":"编码","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"解码","slug":"解码","permalink":"http://rawbin-.github.io/tags/%E8%A7%A3%E7%A0%81/"},{"name":"乱码","slug":"乱码","permalink":"http://rawbin-.github.io/tags/%E4%B9%B1%E7%A0%81/"},{"name":"字符集","slug":"字符集","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"}]},{"title":"字符集和编码详解","slug":"encoding-decoding/2015-03-16-character-set-encoding","date":"2021-12-31T02:37:59.882Z","updated":"2021-12-31T02:37:59.882Z","comments":true,"path":"encoding-decoding/2015-03-16-character-set-encoding/","link":"","permalink":"http://rawbin-.github.io/encoding-decoding/2015-03-16-character-set-encoding/","excerpt":"","text":"Basic Multilingual Plane, BMPSupplementary Multilingual Plane 1 基本概念 字符：各种文字和符号的统称，包括各国各族各地的文字，标点符号，图形符号，数字等。 字符集： 字符的集合，比如汉字字符集，ASCII字符集，简体中文字符集，罗马字母等。字符集关心的是这个集合需要包含哪些东西，怎么唯一表示这个集合中的每一个元素。 字符编码： 将字符集处理为计算机能够识别和处理的规则。字符编码关注一个字符如何用二进制表示，如何让计算机精确识别。 内码: 内码是指计算机汉字系统中使用的二进制字符编码，是沟通输入、输出与系统平台之间的交换码，通过内码可以达到通用和高效率传输文本的目的。比如MS Word中所存储和调用的就是内码而非图形文字。英文ASCII字符采用一个字节的内码表示，中文字符如国标字符集中，GB2312、GB12345、GB13000皆用双字节内码，GB18030（27,533汉字）双字节内码汉字为20,902个，其余6,631个汉字用四字节内码。 编码操作： 将信息转换为二进制串的过程。 解码操作： 将字符从二进制串中还原的操作。 2 常见字符集 ASCII: ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是基于罗马字母表的一套电脑编码系统。用7位二进制来表示字符，共128个字符。同 ISO 646,ASCII字符集包括英文字母、阿拉伯数字和标点符号等字符。。 扩展ASCII：用8位二进制来表示字符，共256个.ASCII扩展字符集比ASCII字符集扩充出来的符号包括表格符号、计算符号、希腊字母和特殊的拉丁符号。 ISO 8859-* ASCII收录了空格及94个“可印刷字符”，足以给英语使用。但是，其他使用拉丁字母的语言(主要是欧洲国家的语言)，都有一定数量的变音字母，故可以使用ASCII及控制字符以外的区域来储存及表示。除了使用拉丁字母的语言外，使用西里尔字母的东欧语言、希腊语、泰语、现代阿拉伯语、希伯来语等，都可以使用这个形式来储存及表示。 GB2312： GB2312是中国国家标准的简体中文字符集。它所收录的汉字已经覆盖99.75%的使用频率，基本满足了汉字的计算机处理需要。在中国大陆和新加坡获广泛使用。字符集中除常用简体汉字字符外还包括希腊字母、日文平假名及片假名字母、俄语西里尔字母等字符，未收录繁体中文汉字和一些生僻字。 GBK： GBK是GB2312的扩展，是向上兼容的，因此GB2312中的汉字的编码与GBK中汉字的相同。GBK编码是GB2312编码的超集，向下完全兼容GB2312，同时GBK收录了Unicode基本多文种平面中的所有CJK汉字。同 GB2312一样，GBK也支持希腊字母、日文假名字母、俄语字母等字符，但不支持韩语中的表音字符（非汉字字符）。GBK还收录了GB2312不包含的汉字部首符号、竖排标点符号等字符。 BIG5： Big5收录的汉字只包括繁体汉字，不包括简体汉字，一些生僻的汉字也没有收录。GBK收录的日文假名字符、俄文字符Big5也没有收录。因为Big5当中收录的字符有限，因此有很多在Big5基础上扩展的编码，如倚天中文系统。Windows系统上使用的代码页CP950也可以理解为是对Big5的扩展，在Big5的基础上增加了7个汉字和一些符号。Big5编码对应的字符集是GBK字符集的子集，也就是说Big5收录的字符是GBK收录字符的一部分，但相同字符的编码不同。 GB18030： GB 18030字符集标准解决汉字、日文假名、朝鲜语和中国少数民族文字组成的大字符集计算机编码问题。该标准的字符总编码空间超过150万个编码位，收录了27484个汉字，覆盖中文、日文、朝鲜语和中国少数民族文字。满足中国大陆、香港、台湾、日本和韩国等东亚地区信息交换多文种、大字量、多用途、统一编码格式的要求。并且与Unicode 3.0版本兼容，填补Unicode扩展字符字汇“统一汉字扩展A”的内容。并且与以前的国家字符编码标准（GB2312，GB13000.1）兼容。 UCS: 通用字符集(Universal Character Set，UCS)是由ISO制定的ISO 10646(或称ISO/IEC 10646)标准所定义的字符编码方式，采用4字节编码。UCS包含了已知语言的所有字符。除了拉丁语、希腊语、斯拉夫语、希伯来语、阿拉伯语、亚美尼亚语、格鲁吉亚语，还包括中文、日文、韩文这样的象形文字，UCS还包括大量的图形、印刷、数学、科学符号。 Unicode字符集： Unicode字符集编码是Universal Multiple-Octet Coded Character Set 通用多八位编码字符集的简称，是由一个名为 Unicode 学术学会(Unicode Consortium)的机构制订的字符编码系统，支持现今世界各种不同语言的书面文本的交换、处理及显示。 3 编码方式（编码）一种字符集，都会有与其对应的一个或多个编码方式，如下大的编码方式是跟上面的字符集对应的。 ASCII字符集: ASCII编码 ISO 8859-*字符集: ISO 8859-*编码 GB2313字符集： GB2312编码 BIG5字符集： BIG5编码 GB18030字符集： GB18030编码 UCS字符集： UCS-2编码，UCS-4编码 Unicode字符集：UTF-7，UTF-8编码，UTF-16编码，Unicode编码（UCS-2），Unicode大端，Unicode小端，UTF-32编码 ANSI: 使用2个字节来代表一个字符的各种汉字延伸编码方式，称为ANSI编码。 在简体中文系统下，ANSI编码代表GB2312编码，在日文操作系统下，ANSI编码代表JIS编码。 4 编码转换Unicode是内存编码表示方案（是规范），而UTF是如何保存和传输Unicode的方案（是实现）GBK、GB2312等与UTF8之间都必须通过Unicode编码才能相互转换：GBK、GB2312－－Unicode－－UTF8UTF8－－Unicode－－GBK、GB2312 5 字节序UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？ 为了识别 Unicode 文件，Microsoft 建议所有的 Unicode 文件应该以 ZERO WIDTH NOBREAK SPACE（U+FEFF）字符开头。这作为一个“特征符”或“字节顺序标记（byte-order mark，BOM）”来识别文件中使用的编码和字节顺序。 Unicode规范中推荐的标记字节顺序的方法是BOM。BOM不是“Bill Of Material”的BOM表，而是Byte Order Mark。BOM是一个有点小聪明的想法： 在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。 这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。 UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符”ZERO WIDTH NO-BREAK SPACE”的UTF-8编码是EF BB BF（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。 6 编码识别 XML解析读取XML文档时，W3C定义了3条规则： 如果文档中有BOM，就定义了文件编码； 如果文档中没有BOM，就查看XML声明中的编码属性； 如果上述两者都没有，就假定XML文档采用UTF-8编码。 对于Unicode文本最标准的途径是检测文本最开头的几个字节。如： 开头字节&nbsp;&nbsp;&nbsp;&nbsp;&emsp;&emsp;&emsp;&emsp;&emsp;Charset/encoding EF BB BF&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;UTF-8 FE FF&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;&nbsp;UTF-16/UCS-2, little endian(UTF-16LE) FF FE&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;&nbsp;UTF-16/UCS-2, big endian(UTF-16BE) FF FE 00 00&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;UTF-32/UCS-4, little endian. 00 00 FE FF&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;UTF-32/UCS-4, big-endia 7 汉字编码相关英语文字是拼音文字，所有文字均由26个字母拼组而成，所以使用一个字节表示一个字符足够了。但汉字是象形文字，汉字的计算机处理技术比英文字符复杂得多，一般用两个字节表示一个汉字。由于汉字有一万多个，常用的也有六千多个，所以编码采用两字节的低7位共14个二进制位来表示。一般汉字的编码方案要解决4种编码问题。（1）汉字交换码汉字交换码主要是用作汉字信息交换的。以国家标准局1980年颁布的《信息交换用汉字编码字符集基本集》（代号为GB2312-80）规定的汉字交换码作为国家标准汉字编码，简称国标码。国标GB 2312-80规定，所有的国际汉字和符号组成一个94×94的矩阵。在该矩阵中，每一行称为一个“区”，每一列称为一个“位”，这样就形成了94个区号（01～94）和94个位号（01～94）的汉字字符集。国标码中有6763个汉字和628个其他基本图形字符，共计7445个字符。其中规定一级汉字3755个，二级汉字3008个，图形符号682个。一个汉字所在的区号与位号简单地组合在一起就构成了该汉字的“区位码”。在汉字区位码中，高两位为区号，低两位为位号。因此，区位码与汉字或图形符号之间是一一对应的。一个汉字由两个字节代码表示。（2）汉字机内码汉字机内码又称内码或汉字存储码。该编码的作用是统一了各种不同的汉字输入码在计算机内的表示。汉字机内码是计算机内部存储、处理的代码。计算机既要处理汉字，又要处理英文，所以必须能区别汉字字符和英文字符。英文字符的机内码是最高位为0的8位ASCII码。为了区分，把国标码每个字节的最高位由0改为1，其余位不变的编码作为汉字字符的机内码。一个汉字用两个字节的内码表示，计算机显示一个汉字的过程首先是根据其内码找到该汉字字库中的地址，然后将该汉字的点阵字型在屏幕上输出。汉字的输入码是多种多样的，同一个汉字如果采用的编码方案不同，则输入码就有可能不一样，但汉字的机内码是一样的。有专用的计算机内部存储汉字使用的汉字内码，用以将输入时使用的多种汉字输入码统一转换成汉字机内码进行存储，以方便机内的汉字处理。在汉字输入时，根据输入码通过计算机或查找输入码表完成输入码到机内码的转换。如汉字国际码（H）＋8080（H）＝汉字机内码（H）。（3）汉字输入码汉字输入码也叫外码，是为了通过键盘字符把汉字输入计算机而设计的一种编码。英文输入时，想输入什么字符便按什么键，输入码和内码是一致的。而汉字输入规则不同，可能要按几个键才能输入一个汉字。汉字和键盘字符组合的对应方式称为汉字输入编码方案。汉字外码是针对不同汉字输入法而言的，通过键盘按某种输入法进行汉字输入时，人与计算机进行信息交换所用的编码称为“汉字外码”。对于同一汉字而言，输入法不同，其外码也是不同的。例如，对于汉字“啊”，在区位码输入法中的外码是1601，在拼音输入中的外码是a，而在五笔字型输入法中的外码是KBSK。汉字的输入码种类繁多，大致有4种类型，即音码、形码、数字码和音形码。（4）汉字字形码汉字在显示和打印输出时，是以汉字字形信息表示的，即以点阵的方式形成汉字图形。汉字字形码是指确定一个汉字字形点阵的代码（汉字字形码）。一般采用点阵字形表示字符。目前普遍使用的汉字字型码是用点阵方式表示的，称为“点阵字模码”。所谓“点阵字模码”，就是将汉字像图像一样置于网状方格上，每格是存储器中的一个位，16×16点阵是在纵向16点、横向16点的网状方格上写一个汉字，有笔画的格对应1，无笔画的格对应0。这种用点阵形式存储的汉字字型信息的集合称为汉字字模库，简称汉字字库。通常汉字显示使用16×16点阵，而汉字打印可选用24×24点阵、32×32点阵、64×64点阵等。汉字字形点阵中的每个点对应一个二进制位，1字节又等于8个二进制位，所以16×16点阵字形的字要使用32个字节（16×16÷8字节＝32字节）存储，64×64点阵的字形要使用512个字节。在16×16点阵字库中的每一个汉字以32个字节存放，存储一、二级汉字及符号共8836个，需要282.5KB磁盘空间。而用户的文档假定有10万个汉字，却只需要200KB的磁盘空间，这是因为用户文档中存储的只是每个汉字（符号）在汉字库中的地址（内码）。 区位码：在 GB2312 时提出的, GB2312 是一个 94*94 的二维表, 行就是 “区”、列就是 “位”, 譬如 “万” 字在 45 区 82 位, 所以 “万” 字的区位码是: 45 82. 00-09 区(682个): 是符号、数字、英文字符…制表符等;10-15 区: 空白, 留待扩展;16-55 区(3755个): 常用汉字(也有叫一级汉字), 按拼音排序;56-87 区(3008个): 非常用汉字(也有叫二级汉字), 这是按部首排序的;88-94 区: 空白, 留待扩展. 国际码：区位码无法用于汉字通信，因为它可能与通信使用的控制码（00H1FH）（即031，还记得ASCII码特殊字符的范围吗？）发生冲突。于是ISO2022规定每个汉字的区号和位号必须分别加上32（即二进制数00100000，16进制20H），得到对应的国标交换码，简称国标码，交换码。这样我们可以算出(45+32, 82+32):“万” 字的国际码是 77 114($4D72) 77 = 0111 0111114 = 0111 0010 77和114这两个字节还是以0开头，所以还是不能用于ANSI编码里，否则很难分清你到底是要一个“万”字，还是要M和r这两个英文字符。 内码：由于文本中通常混合使用汉字和西文字符，汉字信息如果不予以特别标识，就会与单字节的ASCII码混淆。此问题的解决方法之一是将一个汉字看成是两个扩展ASCII码，使表示GB2312汉字的两个字节的最高位都为1。即国标码加上128（即二进制数10000000,16进制80H）这种高位为1的双字节汉字编码即为GB2312汉字的机内码，简称为内码。20H+80H=A0H。这也就是常说的在区位码的区号和位号上分别加上A0H就得到了GB2312编码的由来。 77 + 128 = 205 = CD114+ 128 = 242 = F2 打开记事本输入 “万” 字，保存(编码选择 ANSI); 然后用二进制编辑器(譬如: UltraEdit) 打开， 会看到: CD F2, 这就是 “万” 字的内码! （当然，已经在计算机里处理了，以最实用的标准为准；而之前两种编码都只是理论上的标准） 总结一下： 从区位码（国家标准定义） —&gt; 区和位分别 +32 得到国际码（不再国际混淆）—&gt; 再分别 +128 得到内码（与ACSII也不再混淆）; 区位码的区和位分别 +160 即可得到内码。用十六进制表示： 区位码 + $A0A0 = 内码。ASCII中032、127共34个是需要兼容的，所以国标码前面应该空出33个编码，区位码是从0194（不是从00开始的哟），所以加32（而非33），空出0~32这33个位置 内码输入法状态下：可以同时用区位码和内码输出，但不能用国标码输出！用户—汉字输入码—键盘—键盘扫描码—BIOS键盘驱动程序—-ASCII码—-汉字输入软件—-汉字内码 计算机中汉字的表示也是用二进制编码，同样是人为编码的。根据应用目的的不同，汉字编码分为外码、交换码、机内码和字形码。 1.外码（输入码）外码也叫输入码，是用来将汉字输入到计算机中的一组键盘符号。常用的输入码有拼音码、五笔字型码、自然码、表形码、认知码、区位码和电报码等，一种好的编码应有编码规则简单、易学好记、操作方便、重码率低、输入速度快等优点，每个人可根据自己的需要进行选择。 2.交换码(国标码)计算机内部处理的信息，都是用二进制代码表示的，汉字也不例外。而二进制代码使用起来是不方便的，于是需要采用信息交换码。中国标准总局1981年制定了中华人民共和国国家标准GB2312–80《信息交换用汉字编码字符集–基本集》，即国标码。区位码是国标码的另一种表现形式，把国标GB2312–80中的汉字、图形符号组成一个94×94的方阵，分为94个“区”，每区包含94个“位”，其中“区”的序号由01至94，“位”的序号也是从01至94。94个区中位置总数=94×94=8836个，其中7445个汉字和图形字符中的每一个占一个位置后，还剩下1391个空位，这1391个位置空下来保留备用。 3.机内码根据国标码的规定，每一个汉字都有了确定的二进制代码，在微机内部汉字代码都用机内码，在磁盘上记录汉字代码也使用机内码。 4.汉字的字形码字形码是汉字的输出码，输出汉字时都采用图形方式，无论汉字的笔画多少，每个汉字都可以写在同样大小的方块中。通常用16×16点阵来显示汉字。 5.汉字地址码汉字地址码是指汉字库中存储汉字字形信息的逻辑地址码。它与汉字内码有着简单的对应关系，以简化内码到地址码的转换。 8 参考 字符编码方式发展历程（强烈推荐） 字符，字节和编码 字符集和字符编码（Charset &amp; Encoding） 字符集与字符集编码简介 字符编码详解 字节那些事儿 中文编码杂谈 UNICODE与UTF-8的转换详解 字符集编码详解 常用字符集编码详解 深入了解字符集和编码问题 字符编码详解——彻底理解掌握编码知识，“乱码”不复存在 Unicode 字符集与它的编码方式 字符集编码详解 各种字符集和编码详解 字符编解码的故事（ASCII，ANSI，Unicode，Utf-8） 实例详细介绍各种字符集编码转换问题 字符编码详解 The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!) 十分钟搞清字符集和字符编码 遇到乱码不怕不怕啦——计算机字符编码详尽讲解 字符编码笔记：ASCII，Unicode和UTF-8 字符编码的奥秘 十分钟搞清字符集和字符编码 字符集编码发展简史 深入了解字符集和编码 谈谈Unicode编码，简要解释UCS、UTF、BMP、BOM等名词 ANSI编码和Unicode编码的不同 各种编码UNICODE、UTF-8、ANSI、ASCII、GB2312、GBK详解 计算机内部编码 说说Unicode，UTF8，UTF16，BOM，Big endian，Little 字符编码深入解析 汉字的存储和编码 汉字在电脑中是如何存储与编码 区位码，国标码，内码之间的区别与联系，以及如何转换 Unicode与JavaScript 彻底搞懂乱码——字符，字节和编码 彻底搞懂字符编码(unicode,mbcs,utf-8,utf-16,utf-32,big endian,little endian…) 带补充 彻底搞懂字符编码(unicode,mbcs,utf-8,utf-16,utf-32,big endian,little endian…) ​ ​","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"编码","slug":"编码","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"字符集","slug":"字符集","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"name":"字节序","slug":"字节序","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/"}]},{"title":"类库（Library） 框架（Framework）区别","slug":"framework/2015-03-10-framework-library","date":"2021-12-31T02:37:59.882Z","updated":"2021-12-31T02:37:59.882Z","comments":true,"path":"framework/2015-03-10-framework-library/","link":"","permalink":"http://rawbin-.github.io/framework/2015-03-10-framework-library/","excerpt":"","text":"今天，在baigoogledu中搜索 “JavaScript框架”，愿意是想得到 Backbone,Angular 这类的结果，然而出来的结果大都是关于:jQuery,Prototype,ExtJS 等等 于是就有一个疑问，这些到底是不是框架，什么是框架，什么是库？？ 于是找了些结果，可以用其中的一句话来概括：你调用类库的代码，而框架调用你的代码。 大致是这么个意思，框架提供的是一种规范和模式，你需要像填空那样去放置你的代码去迎合这个规则，然后得以实现整体功能；而类库则是，提供一系列的功能操作供你选择，代码结构还是有我们自己来控制。 发现对于JavaScript来说他们中的绝大多数都不能称之为框架，而应该是库；而对于AJAX来说又可以成为框架，因为他们大多封装了AJAX调动方式；所以在这个概念上，没有太绝对的区分。 1 参考资料 Web前端框架与类库的思考 类库和框架区别 API Toolkit Framework Library Framwork Library Toolkit区别 difference-between-a-framework-and-a-toolkit Framework vs. Toolkit vs. Library 概念区分 Framework Toolkit Library Framework和Library的区别 工具（Toolkit）结构（framework），库（library），之间的区别","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://rawbin-.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"类库","slug":"类库","permalink":"http://rawbin-.github.io/tags/%E7%B1%BB%E5%BA%93/"}]},{"title":"django admin 相关教程","slug":"framework/2015-03-15-django-ralated","date":"2021-12-31T02:37:59.882Z","updated":"2021-12-31T02:37:59.882Z","comments":true,"path":"framework/2015-03-15-django-ralated/","link":"","permalink":"http://rawbin-.github.io/framework/2015-03-15-django-ralated/","excerpt":"","text":"1 参考 利用 Django admin 完成更多任务 django 开发多语言网站 django 开发多语言网站 django admin扩展－自定义后台管理界面 django post office Django文件上传机制详解 django QuerySet里那些常用又不常见的技巧 Django自定义登陆验证后台 Django自定义User模型和登录验证 Python与Django篇","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"MVC分层架构","slug":"architecture/2015-03-05-mvc-architecture","date":"2021-12-31T02:37:59.881Z","updated":"2021-12-31T02:37:59.881Z","comments":true,"path":"architecture/2015-03-05-mvc-architecture/","link":"","permalink":"http://rawbin-.github.io/architecture/2015-03-05-mvc-architecture/","excerpt":"","text":"1 基础MVCMVC即Model-View-Controller，进行系统分层的一种架构模式。 M即Model 指的是业务层该层是应用程序的主体部分，应用程序中的业务数据和业务逻辑都在该层实现。 V即View 指的是表示层该层时应用程序中显示给用户的界面，如浏览器显示的页面，桌面程序的UI等 C即Controller 指的是控制层该层用来控制表示层和业务层之间的交互，根据用户交互事件控制用户界面显示和更新Model层的数据他们之间的依赖关系如下： ———–&gt;Model&lt;—————– | | &lt;——-Controller&lt;——-View—-&gt; 即View依赖于Controller，同时View和Controller都依赖于Model 2 MVC变种在不同的上下文中，有了不同的Controller的实现，MVC功能也有一些调整。 2.1 MVC-1： M即Model 指的是业务层 封装应用程序的数据 代表应用程序的状态 响应用户查询 实现业务功能 通知视图业务状态更新 V即View 指的是表示层 显示数据 接受数据更新请求 发送用户数据给控制器 C即Controller 指的是控制层 接受用户请求 调用模型相应用户请求 选择视图显示响应结果他们之间的依赖关系如下： ———–&gt;Model&lt;—————– | | &lt;—–Controller&lt;——-&gt;View&lt;—-&gt; 即Model和View是双向依赖关系，View和Controller是双向依赖关系，Controller依赖于View。流程为：View发送用户事件给Controller，Controller接收用户事件，将其转发给Model，Model处理事件，并通知View更新。这种方式无疑增加了View和Model的耦合度，于是为了解耦，有了下面的变种。 2.2 MVC-2 M即Model 指的是业务层 封装应用程序的数据 实现业务功能 V即View 指的是表示层 显示数据 接受数据更新请求 发送用户数据给控制器 C即Controller 指的是控制层 接受用户请求 调用模型相应用户请求 选择视图显示响应结果他们之间的依赖关系如下： ———–&gt;Model—————— | | &lt;—–Controller&lt;——-&gt;View—— 即View和Controller是双向依赖关系，Controller和Model之间是双向依赖关系。流程是：用户交互事件通过Controller来操作Model，Model也通过Controller来控制数据更新。这是分层模式想要达到的效果，真正的解耦。 2.3 MVP(Model-View-Presenter)MVP跟MVC-2类似，仅仅是Controller被Presenter替换掉 2.4 MVVM（Model-View-ViewModel）MVVM跟MVP类似，区别在于MVVM包含了双向数据绑定，即V上的数据变化会直接反映到（同步到）VM上，反之亦然。 3 参考资料 MVVM模式原理分析及实践 MVVM架构 12个JavaScript MVC框架评估 Scaling Isomorphic Javascript Code MVC，MVP 和 MVVM 的图示 对MVC、MVP、MVVM的理解 MVC, MVP, MVVM比较以及区别(上) JavaScript MVC框架PK：Angular、Backbone、CanJS与Ember 从Script到Code Blocks、Code Behind到MVC、MVP、MVVM JavaScript富应用MVC MVVM框架 Web前端开发：为何选择MVVM而非MVC","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"MVC","slug":"MVC","permalink":"http://rawbin-.github.io/tags/MVC/"},{"name":"MVVM","slug":"MVVM","permalink":"http://rawbin-.github.io/tags/MVVM/"},{"name":"MVP","slug":"MVP","permalink":"http://rawbin-.github.io/tags/MVP/"},{"name":"前端框架","slug":"前端框架","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"前端性能优化","slug":"performance/2015-03-05-web-performance","date":"2021-12-31T02:37:59.881Z","updated":"2021-12-31T02:37:59.881Z","comments":true,"path":"performance/2015-03-05-web-performance/","link":"","permalink":"http://rawbin-.github.io/performance/2015-03-05-web-performance/","excerpt":"","text":"1 基本过程先了解打开一个Web页面的过程： 用户输入网址，浏览器接收到用户输入的地址（一般为域名） 浏览器解析输入，获取域名并通过DNS查询，获取该域名的IP查询顺序是浏览器缓存，主机缓存，路由器缓存，ISP（互联网服务提供商）DNS缓存，根域名服务器，顶级域名服务器 浏览器发送HTTP请求到目标主机，获取相应的资源（还有可能被重定向）请求Header中会包含浏览器支持的编码方式，接受的内容，有cookie的话还会发送cookie ——-请求发送—– 服务器处理浏览器请求，返回相应的资源内容 ——-响应接收—– 浏览器接收到资源内容，根据响应Header信息解析资源内容解析过程可能是解码字节流，解压gzip，解码资源文件，如果编码不明确，还要做编码嗅探 根据解码的文件内容，请求其他相关的资源，比如说JavaScript，CSS，图片等，由回到输入网址的过程 浏览器将拿到的资源进行解析，渲染并显示在浏览器窗口中 2 过程级优化 减少HTTP请求次数（网络绝大部分的时间80%花在了传输上）每一趟都跑的很累，少跑一趟能省不少事，这个是大头；同样多的活，跑的趟数少了，每趟干背的东西得多 合并资源（图片，CSS，JS分别合并） 合并图片到CSS文件：使用编码的方式将图片编码到CSS中 尽量使用AJAX GET代替POST 减少传输数据量跑的趟数是少了，但每趟干的活多了，也不是一个很好的事情，要是每趟背的东西也能少，就更好了。 将合并的静态资源文件进行压缩，服务端启用gzip等压缩 减小cookie内容像个未断奶的孩子一样，来回都得背着，背个小孩子总比背个大孩子要轻松 将静态内容和动态内容分开，将需要cookie的内容和不需要cookie的内容分开 避免重复脚本内容，导致的多次下载 启用缓存客户端可以共享的资源就没有必要再次请求了（同时也减少了次数），即使需要请求，也是询问资源是否变化，少背东西总能快些 避免无效请求大老远跑一趟不容易，白跑总不合适，家里老婆等着拿东西下锅呢 杜绝404（图片，CSS，JS等） 避免页面跳转或重定向 避免跑远路 使用CDN 3 环节级优化 减少DNS查询这里只能是在页面中少引用不同域名下的资源，比如打开一个页面从其他十个不同主机下载资源，不过这种慢是第一次，后面会好些 加速浏览器解析 尽早指定页面字符集 将样式表放在页面的前面 避免加载无用内容（CSS，JS） 第一次先加载必要资源，再延迟加载后面才会用到的资源（这次就要用的资源） 加载完成后，提前加载现在还没用到，后面可能用到的资源（下次才会用的资源） 避免使用CSS表达式 用代替@import 避免使用Filter 使用媒体查询按需加载图片 使用CSS动画代替JS动画 使用Webworkers做计算量大的操作 将脚本放在页面的后面 减少DOM元素的数量，减小单个DOM大小 减少DOM访问次数 缓存DOM操作，避免重复查询 避免频繁的IO操作，如cookie，localstorage等操作 4 参考资料 移动web性能优化从入门到进阶 在浏览器中输入Google.com并且按下回车之后发生了什么？ 从输入网址到显示页面：浏览器工作原理拆解分析 Web前端优化最佳实践及工具集锦 大话WEB前端性能优化基本套路 前端性能优化实践 大型网站–前端性能优化和规范 博客园-毫秒必争，前端网页性能最佳实践 JOBBOLE-毫秒必争，前端网页性能最佳实践 关于Yahoo十四条军规与前端性能优化 网站前端性能优化总结 前端性能优化—-yahoo前端性能团队总结的35条黄金定律 Web前端性能优化小结 【译】编写高性能JavaScript 前端性能优化最佳实践 7 天打造前端性能监控系统 Web性能监控自动化探索之路–初识WebPageTest Web前端性能优化全攻略 网站性能优化工具大全 Web前端优化最佳实践及工具集锦 Web网站性能测试工具 WEB前端性能分析–工具篇 Web前端性能分析–实践篇 知乎-前端性能优化 DNS查询原理 DNS解析过程原理【深入浅出详解】 DNS原理及其解析过程【精彩剖析】","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"性能优化","slug":"性能优化","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"HTTP请求","slug":"HTTP请求","permalink":"http://rawbin-.github.io/tags/HTTP%E8%AF%B7%E6%B1%82/"}]},{"title":"JavaScript 跨域问题 浏览器 同源策略","slug":"dev-app/javascript/2015-03-05-javascript-crossorigin","date":"2021-12-31T02:37:59.881Z","updated":"2021-12-31T02:37:59.881Z","comments":true,"path":"dev-app/javascript/2015-03-05-javascript-crossorigin/","link":"","permalink":"http://rawbin-.github.io/dev-app/javascript/2015-03-05-javascript-crossorigin/","excerpt":"","text":"RFC6454 网络访问部分： 一般情况下，禁止一个域从另一个域读取数据，却可以使用某些从其他域拿到的资源。比如说，允许一个域执行、渲染、应用从其他域获取到的脚本、图片、样式；同样，一个域可以展示从其他域获取的内容，比如在frame中显示html文档。网络资源也可以选择性的让其他域来读取自己的信息，比如使用Cross-Origin Resource Sharing，这种情况下访问权是针对单个域授权的。 同源策略允许向另一个域发送数据。但是，在网络上发送任意格式的数据是危险的。正因为如此，用户代理限制文档用指定的协议发送信息，比如说不带用户自定义头的HTTP请求。 广义的同源策略，允许一个域向另一个域发送信息，禁止一个域从另一个域接收信息。禁止接收信息是为了防止恶意站点读取其他站点的机密信息，同时防止正当读取其他站点提供的信息(比如你正在解决的跨域问题^_^)。 在同源策略下，跨站发送信息同样是有危害的，因为它可以被用来做类似CSRF（跨站请求伪造）的攻击。同源策略不能像控制接收信息那样直接禁止发送信息，因为禁止发送信息同时也会禁止跨站超链接。不允许发送信息的话，就没有超链接，每个源只能链接到自己的站点，也就没有了互联网。 同源策略限制消息从一个域发送到另一个域。比如说同源策略允许域间的GET和POST方式的HTTP请求，却禁止域间的PUT和DELETE方式的请求。同时，域在发送请求到自己时可以自定义HTTP请求头，发送请求到其他域不能自定义请求头。 限制读取从其他域接收到的信息有点微妙。比如，HTML&lt;script&gt;元素可以执行从其他域获取的信息，这就意味着站点不应该依赖同源策略来保护类脚本解析形式（比如，JavaScript源代码，JSON 格式，JSONP服务等）的信息的机密性。 同源策略内容，对于A，B两个域： 允许A域执行来自B域的资源 限制A域对B域进行写操作 禁止A域读取B域的资源 同源策略限制的是一个域加载的脚本去获取或操作另一个域上的文档属性。同源策略的控制者是浏览器，浏览器可以控制不同域之间的资源的访问或相互操作，但不控制自己对不同域之间的资源的操作和访问。在浏览器中，&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;等标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。比如打开test.com/index.html的首页，首页可能加载了a.com，b.net下的各种资源，比如说a.com/a.js，b.net/b.js。 浏览器会把跨域的外部资源全部给index.html，这种情况是允许的。同源策略只对网页的HTML文档做了限制，对加载的其他静态资源如javascript、css、图片等仍然认为属于同源。 同源策略应用于XMLHttpRequest生成的HTTP请求，允许客户端JavaScript生成任意的HTTP请求到所属文档的Web服务器，但不允许脚本和其他Web服务器通信。 同源策略规则： 脚本本身的来源与同源策略无关，相关的是脚本所嵌入的文档的来源。假设一个来自主机A的脚本被包含到（使用&lt;script&gt;标记的src属性）宿主B的一个Web页面中。这个脚本的来源是主机B，并且可以完整地访问包含它的文档的内容。如果脚本打开一个新窗口并载入来自主机B的另一个文档，脚本对这个文档的内容也具有完全的访问权限（同源）。如果脚本打开一个新窗口并载入来自主机C的文档（主机B和主机C不同源），则同源策略会阻止脚本访问这个文档。 不严格的同源策略： document.domain不同子域名之间的同源策略，如a.test.com与b.test.com之间的访问，可以使用Document对象的domain属性，这是一个可写的属性，可以将其设为test.com来实现子域名之间的不受同源策略约束的资源共享。 Cross-Origin Resource Sharing是W3C提出的方式，用新定义的”Origin”请求头和”Access-Control-Allow-Origin”相应头来扩展HTTP协议。它允许服务器用头信息显式的列出源或使用通配符*来匹配所有的源并允许由任何地址请求文件。这样可以解除同源策略对XMLHttpRequest的限制。 跨文档消息允许来自一个文档的脚本发消息到另一个文档里的脚本，而不管脚本的来源是否不同，调用Window对象的postMessage()方法，可以异步传递消息事件（可以用onmessage事件句处理程序函数来处理它）到窗口的文档里。一个文档里的脚本还是不能调用其他文档里的方法和读取属性，但他们可以通过这种消息传递技术来实现安全的通信。 1 参考资料 Same Origin Policy-W3C JavaScript的同源策略 Same-origin policy Browser Security Handbook, part 2 Google 同源策略及跨域方法 Same Origin Policy-0 Same Origin Policy-1 Same Origin Policy-2 JavaScript同源策略 同源策略 浅谈跨域 JavaScript同源策略 [CORS：跨域资源共享] W3C的CORS Specification [CORS：跨域资源共享] 同源策略与JSONP 同源策略和跨域访问 深入浅出JSONP–解决ajax跨域问题 jQuery跨域请求，跨域Post提交数据的方法 简单描述JSON跟JSONP的区别以及实战 JavaScript系列—-AJAX机制详解以及跨域通信 详解js跨域问题 优雅绝妙的Javascript跨域问题解决方案 跨域方法汇总 HTML5安全：CORS（跨域资源共享）简介 js中几种实用的跨域方法原理详解 Javascript跨域访问解决方案","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://rawbin-.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"CORS","slug":"CORS","permalink":"http://rawbin-.github.io/tags/CORS/"},{"name":"同源策略","slug":"同源策略","permalink":"http://rawbin-.github.io/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"name":"Same Origin Policy","slug":"Same-Origin-Policy","permalink":"http://rawbin-.github.io/tags/Same-Origin-Policy/"},{"name":"浏览器安全","slug":"浏览器安全","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"}]},{"title":"JavaScript 隐式类型转换 JS类型转换","slug":"language/ecma-javascript/2015-03-05-javascript-type-conversion","date":"2021-12-31T02:37:59.881Z","updated":"2021-12-31T02:37:59.881Z","comments":true,"path":"language/ecma-javascript/2015-03-05-javascript-type-conversion/","link":"","permalink":"http://rawbin-.github.io/language/ecma-javascript/2015-03-05-javascript-type-conversion/","excerpt":"","text":"1 介绍JavaScript作为一种弱类型的语言，我们很多时候不需要直接关心到底是经过怎样的转换过程。JavaScript会在需要我们来探索下到底都是些什么样的过程~~，同时了解在什么样的情况下JavaScript需要什么样的值。 先介绍基本的概念，然后说明各种类型的转换规则，最后说转换的场景。 2 基本概念以下的讲解过程中可能需要用到的概念，这里做一个列表。JavaScript中的类型大致可以分为六类：Undefined，Null，String，Boolean，Number，Object。 其中Undefined，Null，String，Boolean，Number这几种类型的成员叫做原始值。 Object的成员叫对象，包括Array，Function，Math，Date，JSON，RegExp等除了原始值之外的所有的类型的成员。 2.1 toString，valueOf Object toString返回”[object “,class,”]”拼接的字符串，其中class为类名，一般为”[object Object]” valueOf 返回值为对象本身 String toString，valueOf都返回String对象的原始字符串 Array toString join方法返回的结果 valueOf 返回对象原始值 Number toString返回数字的字符串表示 valueOf返回Number对象的原始值 Date toString 返回本地时间字符串 valueOf 返回毫秒时间 Boolean toString 返回”true”或”false” valueOf 返回原始值 3 类型转换这里有二维全部的类型转换表，可以看看。也可以到这里看看单个的表格。 3.1 转换为原始类型 当输入类型为Undefined,Null,String,Boolean,Number 则转换后的结果为原样 当输入类型为Object时，转换方法如下： 指定转换的方式为Number或者String两种方式，不指定默认为Number，日期类型特殊，即使不指定为String，默认也按照String的方式转换。 如果转换为字符串，则优先调用toString方法，如果不存在则调用valueOf方法，如果还是不存在则抛出TypeError异常。 如果转换为数字，则优先调用valueOf方法，如果不存在则调用toString方法，如果还是不存在则抛出TypeError异常。3.2 转换为Boolean值 输入类型Undefined，Null转换为false 输入类型为Boolean值，则结果为原样输入 输入类型为Number，如果参数是+0,-0,,NaN结果为false，否则为true 输入类型为字符串，如果为空字符串结果为false，否则为true 输入类型为Object对象，始终为true 3.3 转换为Number 输入类型为Undefined，返回NaN 输入类型为Null，返回+0，即0 输入类型为Boolean，如果是true，则返回1，否则返回0 输入类型为Number，则返回原样输入 输入类型为String，如果全为数字则返回数字的值，否则返回NaN 输入类型为Object，则先转换为原始值，再转换为Number，否则为NaN 3.4 转换为String 输入类型为Undefined，Null，则输出分别为他们的字符串值”undefined”,”null” 输入类型为Boolean，则返回toString的结果”true”或者”false” 输入类型为Number，则返回输入toString的结果 输入类型为String，则返回原样输入 输入类型为Object，则先将其转换为原始值，再返回toString的结果 3.5 转换为Object 输入类型为Undefined，Null，则抛出TypeError异常 输入类型为Boolean，则返回原始值为输入的Boolean对象 输入类型为Number，则返回原始值为输入的Number对象 输入类型为String，则返回原始值为输入的String对象 输入类型为Object，则返回原样输入。 4 类型转换的场景 转换为Number 运算符 一元+，-运算符 ++，–运算符 按位取反会转换为Int32的有符号整数 *，/, %，-运算 +运算操作数没有一个为字符串，则均转换为数字进行求和运算 移位操作&gt;&gt;,&lt;&lt;会将左操作数转换为Int32,右操作数转换为无符号32位整数 无符号移位运算符&gt;&gt;&gt;,&lt;&lt;&lt;,会将两操作数都转换为无符号32位整数 &lt;, &lt;=, &gt;, &gt;=操作数都不是String类型，则都转换为数值进行运算 ==，!=操作数中只有String和Number类型，或者其中有一个是Boolean 二进制位运算会将操作数转为Int32进行运算 转换为Boolean 运算符 &amp;&amp; || ！运算会先转换为Boolean 条件运算会先转为Boolean 语句 if，while，do-while，for 转换为String 运算符 加号其中一个操作数位字符串，则转换为字符串拼接运算 &lt;, &lt;=, &gt;, &gt;=操作数至少有一个String类型，则都转换为字符串进行运算 转换为原始值 运算符 ==，！= 其中一个操作数为Object类型 转换为对象 语句 for-in 5 应用举例 逻辑运算&amp;&amp;， || 逻辑与表达式的值是第一个不为真的表达式的值或者最后一个表达式的值 逻辑或为第一个值为真的表达式的值，或者最后一个表达式的值 表达式的结果还需要进行转Boolean运算比如 1 == 2 || 3 == 4 || 45 || null，表达式的结果为第一个为真的表达式的值，这里为45（短路规则）如果放到条件语句如if中，需要再进行一步转Boolean的运算 6 参考资料 JavaScript数据类型转换 JavaScript类型转换规则 JavaScript中的隐式转换 JavaScript的数据类型转换 JavaScript数据类型转换那些事 JavaScript学习之类型隐式转换 JavaScript数据类型转换方法汇总 无处不在的隐式转换","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://rawbin-.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"类型转换","slug":"类型转换","permalink":"http://rawbin-.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"隐式类型转换","slug":"隐式类型转换","permalink":"http://rawbin-.github.io/tags/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"}]},{"title":"浏览器工作原理","slug":"browser/2015-03-05-browser-internal","date":"2021-12-31T02:37:59.880Z","updated":"2021-12-31T02:37:59.880Z","comments":true,"path":"browser/2015-03-05-browser-internal/","link":"","permalink":"http://rawbin-.github.io/browser/2015-03-05-browser-internal/","excerpt":"","text":"1 参考资料 览器内核分类 [科普文] 关于浏览器内核的一些小知识，明明白白选浏览器！ 浏览器的JavaScript引擎 前端必读：浏览器内部工作原理 浏览器内部工作原理 浏览器渲染原理及可能出现的bug [ 浏览器原理 ] Repaint 、Reflow 的基本认识和优化 浏览器的工作原理：新式网络浏览器幕后揭秘 从输入网址到显示页面：浏览器工作原理拆解分析 浏览器的渲染原理简介 [译]Google Chrome中的高性能网络 How Rendering Work (in WebKit and Blink) 浏览器详谈及其内部工作机制 —— web开发必读 how browser work","categories":[{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"浏览器原理","slug":"浏览器原理","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"}]},{"title":"前端构建工具 前端自动化工具","slug":"automatic/2015-03-05-frontend-automatic","date":"2021-12-31T02:37:59.880Z","updated":"2021-12-31T02:37:59.880Z","comments":true,"path":"automatic/2015-03-05-frontend-automatic/","link":"","permalink":"http://rawbin-.github.io/automatic/2015-03-05-frontend-automatic/","excerpt":"","text":"1 参考资料 Choosing a Build Tool – Babel, Browserify, Webpack, Grunt and Gulp How to choose a build system for javascript app webpack compared Book of Modern frontend tooling Book of Modern frontend tooling 前端构建工具对比Gulp vs Grunt Yeoman学习与实践笔记 前端构建工具Yeoman Yeoman网站 前端自动化开发工作流模板 Yeoman 学习笔记 Gulp挑战Grunt，背后的哲学 前端自动化开发工具 停不下来的前端，自动化流程 我的前端开发工作流 - 自动化篇 Gulp.js—比Grunt更易用的前端构建工具 前端工程构建工具——Yeoman 自定义Yeoman生成器 Gulp， 比Grunt更好用的前端构建工具 “流式”前端构建工具——gulp.js 简介 大公司里怎样开发和部署前端代码？","categories":[],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://rawbin-.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"自动构建","slug":"自动构建","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"}]},{"title":"Linux 自定义动态链接库 32位，64位","slug":"dev-env/2015-03-05-dev-deploy-env","date":"2021-12-31T02:37:59.880Z","updated":"2021-12-31T02:37:59.880Z","comments":true,"path":"dev-env/2015-03-05-dev-deploy-env/","link":"","permalink":"http://rawbin-.github.io/dev-env/2015-03-05-dev-deploy-env/","excerpt":"","text":"1 解决的问题在64位linux运行可执行文件的时候，出现no such file or directory，文件明明存在，肯定有其他问题。 2 解决路径 查看文件的依赖: ldd xxx ldd，发现找不到动态链接库 查看文件信息： file xxx [file][4]，发现时32位环境编译的 查看文件加载信息： readelf -l xxx |grep interpreter [readelf][4]，发现是存在的 把没有的库加上，安装ia32libs 或者到其他机子上把想要的动态库拿过来 在/etc/ld.so.conf中加入文件路径，最好在/etc/ld.so.conf.d/下新建一个文件，然后将我们的动态链接库的路径写进去 运行ldconfig [ldconfig][5]，将我们的库加载进来 查看文件的依赖: ldd xxx ldd，看看还有没有not found happy 运行~ 建议： 部署这样程序的时候，自己带上自己需要的库，并加载到系统中 3 参考 bash: ***: No such file or directory cannot open shared object file: No such file or directory解决 [Linux 共享库][6] [4]: http://man.linuxde.net/file “file” “readelf”[5]: http://man.linuxde.net/ldconfig “ldconfig”[6]: http://blog.csdn.net/ming470612141/article/details/3348063 “Linux 共享库”","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"动态链接库","slug":"动态链接库","permalink":"http://rawbin-.github.io/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"name":"IA32","slug":"IA32","permalink":"http://rawbin-.github.io/tags/IA32/"}]},{"title":"Django框架流程 请求处理流程 源码分析","slug":"framework/2015-03-05-django-request-source","date":"2021-12-31T02:37:59.880Z","updated":"2021-12-31T02:37:59.880Z","comments":true,"path":"framework/2015-03-05-django-request-source/","link":"","permalink":"http://rawbin-.github.io/framework/2015-03-05-django-request-source/","excerpt":"","text":"1 创建服务器//todo django commands 1.1 python manage.py runserver manage.py 设置DJANGO_SETTINGS_MODULE环境变量为当前项目的settings.py,然后通过django.core.management.execute_from_command_line 继续执行命令（此处为runserver及其相关参数）django-admin commands 使用django命令行的方式，执行django.core.management.commands.runserver, 执行该模块下的Command类的handle方法，通过django.core.servers.basehttp.get_internal_wsgi_application 方法获取一个处理类的名称，这里获取到的是项目setting.py中的WSGI_APPLICATION 配置，一般是项目目录下wsgi.py 里面定义的application，配置为xxx.wsgi.application.wsgi.py中定义的application为django.core.wsgi.get_wsgi_application返回的django.core.handlers.wsgi.WSGIHandler的实例。最后通过调用django.core.servers.basehttp.run方法创建并启动http服务器，并启用监听。 请求到达后，会调用django.core.handlers.wsgi.WSGIHandler的实例 2 参考 wsgiref 源代码分析 WSGI 简介 Wsgi研究 Django 结构及处理流程分析 Django源码分析–引导 Django中的request和response Django 结构及处理流程分析 Django运行方式及处理流程总结 How to write a web framework in Python Why so many Python web frameworks 用Python写一个简单的Web框架 Django 结构及处理流程分析 Django运行方式及处理流程总结 Python与Django篇 Django运行方式及处理流程总结（xianglong.me） Django运行方式及处理流程总结 Django 结构及处理流程分析","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Django 流程","slug":"Django-流程","permalink":"http://rawbin-.github.io/tags/Django-%E6%B5%81%E7%A8%8B/"},{"name":"Django 源码","slug":"Django-源码","permalink":"http://rawbin-.github.io/tags/Django-%E6%BA%90%E7%A0%81/"},{"name":"WSGI","slug":"WSGI","permalink":"http://rawbin-.github.io/tags/WSGI/"}]},{"title":"Linux 自定义动态链接库 32位，64位","slug":"os-app/2015-03-05-dev-deploy-env","date":"2021-12-31T02:37:59.875Z","updated":"2021-12-31T02:37:59.875Z","comments":true,"path":"os-app/2015-03-05-dev-deploy-env/","link":"","permalink":"http://rawbin-.github.io/os-app/2015-03-05-dev-deploy-env/","excerpt":"","text":"1 解决的问题在64位linux运行可执行文件的时候，出现no such file or directory，文件明明存在，肯定有其他问题。 2 解决路径 查看文件的依赖: ldd xxx ldd，发现找不到动态链接库 查看文件信息： file xxx [file][4]，发现时32位环境编译的 查看文件加载信息： readelf -l xxx |grep interpreter [readelf][4]，发现是存在的 把没有的库加上，安装ia32libs 或者到其他机子上把想要的动态库拿过来 在/etc/ld.so.conf中加入文件路径，最好在/etc/ld.so.conf.d/下新建一个文件，然后将我们的动态链接库的路径写进去 运行ldconfig [ldconfig][5]，将我们的库加载进来 查看文件的依赖: ldd xxx ldd，看看还有没有not found happy 运行~ 建议： 部署这样程序的时候，自己带上自己需要的库，并加载到系统中 3 参考 bash: ***: No such file or directory cannot open shared object file: No such file or directory解决 [Linux 共享库][6] [4]: http://man.linuxde.net/file “file” “readelf”[5]: http://man.linuxde.net/ldconfig “ldconfig”[6]: http://blog.csdn.net/ming470612141/article/details/3348063 “Linux 共享库”","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"动态链接库","slug":"动态链接库","permalink":"http://rawbin-.github.io/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"name":"IA32","slug":"IA32","permalink":"http://rawbin-.github.io/tags/IA32/"}]}],"categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"前端开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"服务配置","slug":"前端开发/Web开发/服务配置","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"},{"name":"JavaScript","slug":"前端开发/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"代码规范","slug":"前端开发/Web开发/JavaScript/代码规范","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"DOM","slug":"前端开发/Web开发/JavaScript/DOM","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/DOM/"},{"name":"符号计算","slug":"符号计算","permalink":"http://rawbin-.github.io/categories/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/"},{"name":"值计算","slug":"符号计算/值计算","permalink":"http://rawbin-.github.io/categories/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/%E5%80%BC%E8%AE%A1%E7%AE%97/"},{"name":"对比","slug":"符号计算/值计算/对比","permalink":"http://rawbin-.github.io/categories/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/%E5%80%BC%E8%AE%A1%E7%AE%97/%E5%AF%B9%E6%AF%94/"},{"name":"NodeJS","slug":"前端开发/Web开发/JavaScript/NodeJS","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/NodeJS/"},{"name":"TypeScript","slug":"前端开发/Web开发/JavaScript/NodeJS/TypeScript","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/NodeJS/TypeScript/"},{"name":"自动化","slug":"Web开发/前端开发/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"灰度发布","slug":"前端开发/Web开发/灰度发布","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/"},{"name":"ABTest","slug":"前端开发/Web开发/灰度发布/ABTest","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/ABTest/"},{"name":"Electron","slug":"前端开发/Web开发/JavaScript/Electron","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/JavaScript/Electron/"},{"name":"全栈开发","slug":"前端开发/Web开发/全栈开发","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/"},{"name":"CSS","slug":"前端开发/Web开发/CSS","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/CSS/"},{"name":"JavaScript","slug":"Web开发/前端开发/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"自动化","slug":"Web开发/前端开发/JavaScript/自动化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"JavaScript开发","slug":"Web开发/前端开发/JavaScript开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript%E5%BC%80%E5%8F%91/"},{"name":"网络工具","slug":"Web开发/网络工具","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"},{"name":"软件开发","slug":"软件开发","permalink":"http://rawbin-.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"Web开发","slug":"软件开发/Web开发","permalink":"http://rawbin-.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"软件开发/Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Android开发","slug":"Web开发/Android开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/Android%E5%BC%80%E5%8F%91/"},{"name":"移动端开发","slug":"Web开发/Android开发/移动端开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/Android%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Web安全","slug":"前端开发/Web开发/Web安全","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/Web%E5%AE%89%E5%85%A8/"},{"name":"打包工具","slug":"前端开发/打包工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"},{"name":"前端框架","slug":"前端开发/Web开发/前端框架","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Web前端","slug":"Web开发/前端开发/Web前端","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/categories/JavaScript/"},{"name":"Web开发","slug":"JavaScript/Web开发","permalink":"http://rawbin-.github.io/categories/JavaScript/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"JavaScript/Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/JavaScript/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"Web开发/前端开发/Web前端/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"Codova","slug":"Codova","permalink":"http://rawbin-.github.io/categories/Codova/"},{"name":"Phonegap","slug":"Codova/Phonegap","permalink":"http://rawbin-.github.io/categories/Codova/Phonegap/"},{"name":"Hybrid","slug":"Codova/Phonegap/Hybrid","permalink":"http://rawbin-.github.io/categories/Codova/Phonegap/Hybrid/"},{"name":"Web开发","slug":"Codova/Phonegap/Hybrid/Web开发","permalink":"http://rawbin-.github.io/categories/Codova/Phonegap/Hybrid/Web%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"Codova/Phonegap/Hybrid/Web开发/前端开发","permalink":"http://rawbin-.github.io/categories/Codova/Phonegap/Hybrid/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"HTML5","slug":"Web开发/前端开发/JavaScript/HTML5","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/HTML5/"},{"name":"项目管理","slug":"项目管理","permalink":"http://rawbin-.github.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"Bug管理","slug":"项目管理/Bug管理","permalink":"http://rawbin-.github.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Bug%E7%AE%A1%E7%90%86/"},{"name":"流程管理","slug":"项目管理/Bug管理/流程管理","permalink":"http://rawbin-.github.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Bug%E7%AE%A1%E7%90%86/%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"name":"开发环境","slug":"Web开发/前端开发/开发环境","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"前端工程化","slug":"Web开发/前端开发/前端工程化","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"开发工具","slug":"Web开发/前端开发/前端工程化/开发工具","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"测试","slug":"Web开发/测试","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95/"},{"name":"Web安全","slug":"Web开发/前端开发/Web安全","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%AE%89%E5%85%A8/"},{"name":"风格","slug":"风格","permalink":"http://rawbin-.github.io/categories/%E9%A3%8E%E6%A0%BC/"},{"name":"思路","slug":"风格/思路","permalink":"http://rawbin-.github.io/categories/%E9%A3%8E%E6%A0%BC/%E6%80%9D%E8%B7%AF/"},{"name":"HTTP","slug":"前端开发/Web开发/HTTP","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/HTTP/"},{"name":"代码设计","slug":"代码设计","permalink":"http://rawbin-.github.io/categories/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"},{"name":"程序设计","slug":"代码设计/程序设计","permalink":"http://rawbin-.github.io/categories/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"开发技术","slug":"开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"开发工具","slug":"前端开发/Web开发/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Web前端","slug":"JavaScript/Web前端","permalink":"http://rawbin-.github.io/categories/JavaScript/Web%E5%89%8D%E7%AB%AF/"},{"name":"Web开发","slug":"JavaScript/Web前端/Web开发","permalink":"http://rawbin-.github.io/categories/JavaScript/Web%E5%89%8D%E7%AB%AF/Web%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"开发工具","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"开发环境","slug":"开发工具/开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"React","slug":"Web开发/前端开发/React","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React/"},{"name":"JavaScript","slug":"Web开发/前端开发/React/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React/JavaScript/"},{"name":"开发环境","slug":"开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"操作系统","slug":"开发环境/操作系统","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"操作系统","slug":"操作系统","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"开发环境","slug":"操作系统/开发环境","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"移动开发","slug":"Web开发/前端开发/JavaScript/移动开发","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"HTTP","slug":"HTTP","permalink":"http://rawbin-.github.io/categories/HTTP/"},{"name":"TCP","slug":"HTTP/TCP","permalink":"http://rawbin-.github.io/categories/HTTP/TCP/"},{"name":"开发技术","slug":"开发环境/开发技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"应用技术","slug":"开发环境/开发技术/应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"应用技术","slug":"应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"Git","slug":"开发环境/Git","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Git/"},{"name":"Java开发","slug":"开发技术/Java开发","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Java%E5%BC%80%E5%8F%91/"},{"name":"Web性能优化","slug":"应用技术/Web性能优化","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"操作系统","slug":"应用技术/操作系统","permalink":"http://rawbin-.github.io/categories/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"前端开发","slug":"开发技术/前端开发","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"开发环境","slug":"开发技术/前端开发/开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"应用技术","slug":"开发技术/应用技术","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"开发环境","slug":"开发技术/开发环境","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"开发技术/开发环境/Git","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Git/"},{"name":"应用技术","slug":"前端开发/应用技术","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"开发环境","slug":"前端开发/应用技术/开发环境","permalink":"http://rawbin-.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"算法结构","slug":"算法结构","permalink":"http://rawbin-.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84/"},{"name":"Python","slug":"Web开发/前端开发/Python","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Python/"},{"name":"Web前端","slug":"开发技术/Web前端","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Web%E5%89%8D%E7%AB%AF/"},{"name":"Web开发","slug":"开发技术/Web开发","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"开发技术/Web开发/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Web%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"系统应用","slug":"操作系统/系统应用","permalink":"http://rawbin-.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8/"},{"name":"开发技术","slug":"Web开发/前端开发/开发技术","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"Web开发/前端开发/开发技术/JavaScript","permalink":"http://rawbin-.github.io/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/JavaScript/"},{"name":"JavaScript","slug":"开发技术/JavaScript","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/JavaScript/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机体系结构","slug":"计算机基础/计算机体系结构","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"计算机网络","slug":"计算机基础/计算机体系结构/计算机网络","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机基础/计算机体系结构/计算机网络/HTTP","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"},{"name":"系统工具","slug":"系统工具","permalink":"http://rawbin-.github.io/categories/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/"},{"name":"互联网","slug":"互联网","permalink":"http://rawbin-.github.io/categories/%E4%BA%92%E8%81%94%E7%BD%91/"},{"name":"软件工程","slug":"软件工程","permalink":"http://rawbin-.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"计算机安全","slug":"计算机安全","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"},{"name":"编程语言","slug":"编程语言","permalink":"http://rawbin-.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"http://rawbin-.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"数据库","slug":"数据库","permalink":"http://rawbin-.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"知识积累","slug":"知识积累","permalink":"http://rawbin-.github.io/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"},{"name":"开发工具","slug":"开发环境/开发工具","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"VIM","slug":"开发环境/开发工具/VIM","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VIM/"},{"name":"编程语言","slug":"开发环境/开发工具/编程语言","permalink":"http://rawbin-.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://rawbin-.github.io/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"http://rawbin-.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://rawbin-.github.io/tags/NodeJS/"},{"name":"浏览器","slug":"浏览器","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"管理系统","slug":"管理系统","permalink":"http://rawbin-.github.io/tags/%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"自动化表单","slug":"自动化表单","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A1%A8%E5%8D%95/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"name":"nginx","slug":"nginx","permalink":"http://rawbin-.github.io/tags/nginx/"},{"name":"history mode","slug":"history-mode","permalink":"http://rawbin-.github.io/tags/history-mode/"},{"name":"spa","slug":"spa","permalink":"http://rawbin-.github.io/tags/spa/"},{"name":"puppeteer","slug":"puppeteer","permalink":"http://rawbin-.github.io/tags/puppeteer/"},{"name":"js","slug":"js","permalink":"http://rawbin-.github.io/tags/js/"},{"name":"headless chrome","slug":"headless-chrome","permalink":"http://rawbin-.github.io/tags/headless-chrome/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://rawbin-.github.io/tags/TypeScript/"},{"name":"编程语言","slug":"编程语言","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://rawbin-.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rawbin-.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排列","slug":"排列","permalink":"http://rawbin-.github.io/tags/%E6%8E%92%E5%88%97/"},{"name":"组合","slug":"组合","permalink":"http://rawbin-.github.io/tags/%E7%BB%84%E5%90%88/"},{"name":"音视频","slug":"音视频","permalink":"http://rawbin-.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"自动播放","slug":"自动播放","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE/"},{"name":"性能优化","slug":"性能优化","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"页面加载","slug":"页面加载","permalink":"http://rawbin-.github.io/tags/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD/"},{"name":"页面优化","slug":"页面优化","permalink":"http://rawbin-.github.io/tags/%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/"},{"name":"CSRF","slug":"CSRF","permalink":"http://rawbin-.github.io/tags/CSRF/"},{"name":"XSS","slug":"XSS","permalink":"http://rawbin-.github.io/tags/XSS/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://rawbin-.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"iOS","slug":"iOS","permalink":"http://rawbin-.github.io/tags/iOS/"},{"name":"鸿蒙","slug":"鸿蒙","permalink":"http://rawbin-.github.io/tags/%E9%B8%BF%E8%92%99/"},{"name":"安卓","slug":"安卓","permalink":"http://rawbin-.github.io/tags/%E5%AE%89%E5%8D%93/"},{"name":"Android","slug":"Android","permalink":"http://rawbin-.github.io/tags/Android/"},{"name":"苹果","slug":"苹果","permalink":"http://rawbin-.github.io/tags/%E8%8B%B9%E6%9E%9C/"},{"name":"调试","slug":"调试","permalink":"http://rawbin-.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"移动端","slug":"移动端","permalink":"http://rawbin-.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"页面","slug":"页面","permalink":"http://rawbin-.github.io/tags/%E9%A1%B5%E9%9D%A2/"},{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"http://rawbin-.github.io/tags/HarmonyOS/"},{"name":"Native","slug":"Native","permalink":"http://rawbin-.github.io/tags/Native/"},{"name":"原生","slug":"原生","permalink":"http://rawbin-.github.io/tags/%E5%8E%9F%E7%94%9F/"},{"name":"harmonyos","slug":"harmonyos","permalink":"http://rawbin-.github.io/tags/harmonyos/"},{"name":"Flutter","slug":"Flutter","permalink":"http://rawbin-.github.io/tags/Flutter/"},{"name":"模块化","slug":"模块化","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://rawbin-.github.io/tags/CommonJS/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://rawbin-.github.io/tags/ECMAScript/"},{"name":"小程序","slug":"小程序","permalink":"http://rawbin-.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"组件化","slug":"组件化","permalink":"http://rawbin-.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"WebComponent","slug":"WebComponent","permalink":"http://rawbin-.github.io/tags/WebComponent/"},{"name":"React","slug":"React","permalink":"http://rawbin-.github.io/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"http://rawbin-.github.io/tags/Vue/"},{"name":"CSS","slug":"CSS","permalink":"http://rawbin-.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://rawbin-.github.io/tags/HTML/"},{"name":"css","slug":"css","permalink":"http://rawbin-.github.io/tags/css/"},{"name":"markdown","slug":"markdown","permalink":"http://rawbin-.github.io/tags/markdown/"},{"name":"W3C","slug":"W3C","permalink":"http://rawbin-.github.io/tags/W3C/"},{"name":"代码规范","slug":"代码规范","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"滚动穿透","slug":"滚动穿透","permalink":"http://rawbin-.github.io/tags/%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F/"},{"name":"弹层滚动","slug":"弹层滚动","permalink":"http://rawbin-.github.io/tags/%E5%BC%B9%E5%B1%82%E6%BB%9A%E5%8A%A8/"},{"name":"禁止滚动","slug":"禁止滚动","permalink":"http://rawbin-.github.io/tags/%E7%A6%81%E6%AD%A2%E6%BB%9A%E5%8A%A8/"},{"name":"canvas","slug":"canvas","permalink":"http://rawbin-.github.io/tags/canvas/"},{"name":"手写","slug":"手写","permalink":"http://rawbin-.github.io/tags/%E6%89%8B%E5%86%99/"},{"name":"手绘","slug":"手绘","permalink":"http://rawbin-.github.io/tags/%E6%89%8B%E7%BB%98/"},{"name":"iPhone X适配","slug":"iPhone-X适配","permalink":"http://rawbin-.github.io/tags/iPhone-X%E9%80%82%E9%85%8D/"},{"name":"小黑条适配","slug":"小黑条适配","permalink":"http://rawbin-.github.io/tags/%E5%B0%8F%E9%BB%91%E6%9D%A1%E9%80%82%E9%85%8D/"},{"name":"安全区适配","slug":"安全区适配","permalink":"http://rawbin-.github.io/tags/%E5%AE%89%E5%85%A8%E5%8C%BA%E9%80%82%E9%85%8D/"},{"name":"爬虫","slug":"爬虫","permalink":"http://rawbin-.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"DOM位置,DOM事件,屏幕位置","slug":"DOM位置-DOM事件-屏幕位置","permalink":"http://rawbin-.github.io/tags/DOM%E4%BD%8D%E7%BD%AE-DOM%E4%BA%8B%E4%BB%B6-%E5%B1%8F%E5%B9%95%E4%BD%8D%E7%BD%AE/"},{"name":"符号计算","slug":"符号计算","permalink":"http://rawbin-.github.io/tags/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/"},{"name":"值计算","slug":"值计算","permalink":"http://rawbin-.github.io/tags/%E5%80%BC%E8%AE%A1%E7%AE%97/"},{"name":"值对比","slug":"值对比","permalink":"http://rawbin-.github.io/tags/%E5%80%BC%E5%AF%B9%E6%AF%94/"},{"name":"跨平台,跨端,解决方案,Web跨平台,Web跨端","slug":"跨平台-跨端-解决方案-Web跨平台-Web跨端","permalink":"http://rawbin-.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0-%E8%B7%A8%E7%AB%AF-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Web%E8%B7%A8%E5%B9%B3%E5%8F%B0-Web%E8%B7%A8%E7%AB%AF/"},{"name":"Nest","slug":"Nest","permalink":"http://rawbin-.github.io/tags/Nest/"},{"name":"Node","slug":"Node","permalink":"http://rawbin-.github.io/tags/Node/"},{"name":"Node.js","slug":"Node-js","permalink":"http://rawbin-.github.io/tags/Node-js/"},{"name":"PM2","slug":"PM2","permalink":"http://rawbin-.github.io/tags/PM2/"},{"name":"项目结构","slug":"项目结构","permalink":"http://rawbin-.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"},{"name":"项目模板","slug":"项目模板","permalink":"http://rawbin-.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/"},{"name":"部署","slug":"部署","permalink":"http://rawbin-.github.io/tags/%E9%83%A8%E7%BD%B2/"},{"name":"自动化","slug":"自动化","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"运维","slug":"运维","permalink":"http://rawbin-.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"容器化","slug":"容器化","permalink":"http://rawbin-.github.io/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"可伸缩","slug":"可伸缩","permalink":"http://rawbin-.github.io/tags/%E5%8F%AF%E4%BC%B8%E7%BC%A9/"},{"name":"Shell","slug":"Shell","permalink":"http://rawbin-.github.io/tags/Shell/"},{"name":"字符串处理","slug":"字符串处理","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"},{"name":"客户端","slug":"客户端","permalink":"http://rawbin-.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"桌面端","slug":"桌面端","permalink":"http://rawbin-.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF/"},{"name":"灰度发布","slug":"灰度发布","permalink":"http://rawbin-.github.io/tags/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/"},{"name":"ABTest","slug":"ABTest","permalink":"http://rawbin-.github.io/tags/ABTest/"},{"name":"Electron","slug":"Electron","permalink":"http://rawbin-.github.io/tags/Electron/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"热更新","slug":"热更新","permalink":"http://rawbin-.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"在线更新","slug":"在线更新","permalink":"http://rawbin-.github.io/tags/%E5%9C%A8%E7%BA%BF%E6%9B%B4%E6%96%B0/"},{"name":"PDF","slug":"PDF","permalink":"http://rawbin-.github.io/tags/PDF/"},{"name":"字体","slug":"字体","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E4%BD%93/"},{"name":"状态","slug":"状态","permalink":"http://rawbin-.github.io/tags/%E7%8A%B6%E6%80%81/"},{"name":"状态管理","slug":"状态管理","permalink":"http://rawbin-.github.io/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"name":"异步编程","slug":"异步编程","permalink":"http://rawbin-.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"name":"迭代器","slug":"迭代器","permalink":"http://rawbin-.github.io/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"生成器","slug":"生成器","permalink":"http://rawbin-.github.io/tags/%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"跨端","slug":"跨端","permalink":"http://rawbin-.github.io/tags/%E8%B7%A8%E7%AB%AF/"},{"name":"组件通信","slug":"组件通信","permalink":"http://rawbin-.github.io/tags/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"},{"name":"事件循环","slug":"事件循环","permalink":"http://rawbin-.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"Javascript","slug":"Javascript","permalink":"http://rawbin-.github.io/tags/Javascript/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"http://rawbin-.github.io/tags/Event-Loop/"},{"name":"动态页面","slug":"动态页面","permalink":"http://rawbin-.github.io/tags/%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2/"},{"name":"动态表单","slug":"动态表单","permalink":"http://rawbin-.github.io/tags/%E5%8A%A8%E6%80%81%E8%A1%A8%E5%8D%95/"},{"name":"配置规范","slug":"配置规范","permalink":"http://rawbin-.github.io/tags/%E9%85%8D%E7%BD%AE%E8%A7%84%E8%8C%83/"},{"name":"前端","slug":"前端","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Web开发","slug":"Web开发","permalink":"http://rawbin-.github.io/tags/Web%E5%BC%80%E5%8F%91/"},{"name":"大前端","slug":"大前端","permalink":"http://rawbin-.github.io/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"全栈","slug":"全栈","permalink":"http://rawbin-.github.io/tags/%E5%85%A8%E6%A0%88/"},{"name":"后端","slug":"后端","permalink":"http://rawbin-.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"CSS2","slug":"CSS2","permalink":"http://rawbin-.github.io/tags/CSS2/"},{"name":"中文翻译","slug":"中文翻译","permalink":"http://rawbin-.github.io/tags/%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/"},{"name":"页面布局","slug":"页面布局","permalink":"http://rawbin-.github.io/tags/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"},{"name":"动画","slug":"动画","permalink":"http://rawbin-.github.io/tags/%E5%8A%A8%E7%94%BB/"},{"name":"居中","slug":"居中","permalink":"http://rawbin-.github.io/tags/%E5%B1%85%E4%B8%AD/"},{"name":"垂直居中","slug":"垂直居中","permalink":"http://rawbin-.github.io/tags/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"},{"name":"水平居中","slug":"水平居中","permalink":"http://rawbin-.github.io/tags/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://rawbin-.github.io/tags/Vue-js/"},{"name":"虚拟DOM","slug":"虚拟DOM","permalink":"http://rawbin-.github.io/tags/%E8%99%9A%E6%8B%9FDOM/"},{"name":"diff算法","slug":"diff算法","permalink":"http://rawbin-.github.io/tags/diff%E7%AE%97%E6%B3%95/"},{"name":"Git","slug":"Git","permalink":"http://rawbin-.github.io/tags/Git/"},{"name":"仓库","slug":"仓库","permalink":"http://rawbin-.github.io/tags/%E4%BB%93%E5%BA%93/"},{"name":"瘦身","slug":"瘦身","permalink":"http://rawbin-.github.io/tags/%E7%98%A6%E8%BA%AB/"},{"name":"浏览器兼容","slug":"浏览器兼容","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"},{"name":"polyfill","slug":"polyfill","permalink":"http://rawbin-.github.io/tags/polyfill/"},{"name":"特性检测","slug":"特性检测","permalink":"http://rawbin-.github.io/tags/%E7%89%B9%E6%80%A7%E6%A3%80%E6%B5%8B/"},{"name":"源码分析","slug":"源码分析","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"jQuery","slug":"jQuery","permalink":"http://rawbin-.github.io/tags/jQuery/"},{"name":"EasyUI","slug":"EasyUI","permalink":"http://rawbin-.github.io/tags/EasyUI/"},{"name":"Combobox","slug":"Combobox","permalink":"http://rawbin-.github.io/tags/Combobox/"},{"name":"Datagrid","slug":"Datagrid","permalink":"http://rawbin-.github.io/tags/Datagrid/"},{"name":"ngrok","slug":"ngrok","permalink":"http://rawbin-.github.io/tags/ngrok/"},{"name":"内网穿透工具","slug":"内网穿透工具","permalink":"http://rawbin-.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/"},{"name":"源码阅读","slug":"源码阅读","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"命令行配置","slug":"命令行配置","permalink":"http://rawbin-.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE/"},{"name":"命令行代理","slug":"命令行代理","permalink":"http://rawbin-.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86/"},{"name":"终端代理","slug":"终端代理","permalink":"http://rawbin-.github.io/tags/%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86/"},{"name":"Java","slug":"Java","permalink":"http://rawbin-.github.io/tags/Java/"},{"name":"第三方包","slug":"第三方包","permalink":"http://rawbin-.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/"},{"name":"Vue Router","slug":"Vue-Router","permalink":"http://rawbin-.github.io/tags/Vue-Router/"},{"name":"Vuex","slug":"Vuex","permalink":"http://rawbin-.github.io/tags/Vuex/"},{"name":"微前端","slug":"微前端","permalink":"http://rawbin-.github.io/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"前端架构","slug":"前端架构","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"},{"name":"npm","slug":"npm","permalink":"http://rawbin-.github.io/tags/npm/"},{"name":"cnpm","slug":"cnpm","permalink":"http://rawbin-.github.io/tags/cnpm/"},{"name":"sinppia","slug":"sinppia","permalink":"http://rawbin-.github.io/tags/sinppia/"},{"name":"npm私有仓库","slug":"npm私有仓库","permalink":"http://rawbin-.github.io/tags/npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"},{"name":"npm私有源","slug":"npm私有源","permalink":"http://rawbin-.github.io/tags/npm%E7%A7%81%E6%9C%89%E6%BA%90/"},{"name":"Webpack","slug":"Webpack","permalink":"http://rawbin-.github.io/tags/Webpack/"},{"name":"Web安全","slug":"Web安全","permalink":"http://rawbin-.github.io/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"前端安全","slug":"前端安全","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"name":"四舍五入","slug":"四舍五入","permalink":"http://rawbin-.github.io/tags/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5/"},{"name":"开发工具","slug":"开发工具","permalink":"http://rawbin-.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"JavaScript引擎","slug":"JavaScript引擎","permalink":"http://rawbin-.github.io/tags/JavaScript%E5%BC%95%E6%93%8E/"},{"name":"V8","slug":"V8","permalink":"http://rawbin-.github.io/tags/V8/"},{"name":"混合开发","slug":"混合开发","permalink":"http://rawbin-.github.io/tags/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"},{"name":"hybrid","slug":"hybrid","permalink":"http://rawbin-.github.io/tags/hybrid/"},{"name":"SSO","slug":"SSO","permalink":"http://rawbin-.github.io/tags/SSO/"},{"name":"单点登录","slug":"单点登录","permalink":"http://rawbin-.github.io/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"name":"Cli","slug":"Cli","permalink":"http://rawbin-.github.io/tags/Cli/"},{"name":"打包工具","slug":"打包工具","permalink":"http://rawbin-.github.io/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"},{"name":"性能","slug":"性能","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"缓存","slug":"缓存","permalink":"http://rawbin-.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"HTTP","slug":"HTTP","permalink":"http://rawbin-.github.io/tags/HTTP/"},{"name":"HOC","slug":"HOC","permalink":"http://rawbin-.github.io/tags/HOC/"},{"name":"Mock","slug":"Mock","permalink":"http://rawbin-.github.io/tags/Mock/"},{"name":"多页打包","slug":"多页打包","permalink":"http://rawbin-.github.io/tags/%E5%A4%9A%E9%A1%B5%E6%89%93%E5%8C%85/"},{"name":"Hybrid","slug":"Hybrid","permalink":"http://rawbin-.github.io/tags/Hybrid/"},{"name":"Codova","slug":"Codova","permalink":"http://rawbin-.github.io/tags/Codova/"},{"name":"Phonegap","slug":"Phonegap","permalink":"http://rawbin-.github.io/tags/Phonegap/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://rawbin-.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"校验","slug":"校验","permalink":"http://rawbin-.github.io/tags/%E6%A0%A1%E9%AA%8C/"},{"name":"面试题","slug":"面试题","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"面试","slug":"面试","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"HTML5","slug":"HTML5","permalink":"http://rawbin-.github.io/tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"http://rawbin-.github.io/tags/CSS3/"},{"name":"ES6","slug":"ES6","permalink":"http://rawbin-.github.io/tags/ES6/"},{"name":"IE8","slug":"IE8","permalink":"http://rawbin-.github.io/tags/IE8/"},{"name":"CORS","slug":"CORS","permalink":"http://rawbin-.github.io/tags/CORS/"},{"name":"响应式布局","slug":"响应式布局","permalink":"http://rawbin-.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"},{"name":"自适应布局","slug":"自适应布局","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"},{"name":"流式布局","slug":"流式布局","permalink":"http://rawbin-.github.io/tags/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"},{"name":"固定布局","slug":"固定布局","permalink":"http://rawbin-.github.io/tags/%E5%9B%BA%E5%AE%9A%E5%B8%83%E5%B1%80/"},{"name":"布局","slug":"布局","permalink":"http://rawbin-.github.io/tags/%E5%B8%83%E5%B1%80/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://rawbin-.github.io/tags/Jenkins/"},{"name":"CI","slug":"CI","permalink":"http://rawbin-.github.io/tags/CI/"},{"name":"Deploy","slug":"Deploy","permalink":"http://rawbin-.github.io/tags/Deploy/"},{"name":"JIRA","slug":"JIRA","permalink":"http://rawbin-.github.io/tags/JIRA/"},{"name":"Confluence","slug":"Confluence","permalink":"http://rawbin-.github.io/tags/Confluence/"},{"name":"浏览器原理","slug":"浏览器原理","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"反向代理","slug":"反向代理","permalink":"http://rawbin-.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"},{"name":"静态服务器","slug":"静态服务器","permalink":"http://rawbin-.github.io/tags/%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"clipboard","slug":"clipboard","permalink":"http://rawbin-.github.io/tags/clipboard/"},{"name":"File API","slug":"File-API","permalink":"http://rawbin-.github.io/tags/File-API/"},{"name":"前端开发","slug":"前端开发","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"后端开发","slug":"后端开发","permalink":"http://rawbin-.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"移动端调试","slug":"移动端调试","permalink":"http://rawbin-.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"},{"name":"YKit","slug":"YKit","permalink":"http://rawbin-.github.io/tags/YKit/"},{"name":"模拟数据","slug":"模拟数据","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE/"},{"name":"测试数据","slug":"测试数据","permalink":"http://rawbin-.github.io/tags/%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/"},{"name":"Selenium","slug":"Selenium","permalink":"http://rawbin-.github.io/tags/Selenium/"},{"name":"Xvfb","slug":"Xvfb","permalink":"http://rawbin-.github.io/tags/Xvfb/"},{"name":"PhantomJS","slug":"PhantomJS","permalink":"http://rawbin-.github.io/tags/PhantomJS/"},{"name":"Headless Chrome","slug":"Headless-Chrome","permalink":"http://rawbin-.github.io/tags/Headless-Chrome/"},{"name":"FEKit","slug":"FEKit","permalink":"http://rawbin-.github.io/tags/FEKit/"},{"name":"Lighthouse","slug":"Lighthouse","permalink":"http://rawbin-.github.io/tags/Lighthouse/"},{"name":"chrome-launcher","slug":"chrome-launcher","permalink":"http://rawbin-.github.io/tags/chrome-launcher/"},{"name":"性能测试","slug":"性能测试","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"压力测试","slug":"压力测试","permalink":"http://rawbin-.github.io/tags/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"},{"name":"测试工具","slug":"测试工具","permalink":"http://rawbin-.github.io/tags/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"name":"性能调优","slug":"性能调优","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"},{"name":"规范","slug":"规范","permalink":"http://rawbin-.github.io/tags/%E8%A7%84%E8%8C%83/"},{"name":"逆向工程","slug":"逆向工程","permalink":"http://rawbin-.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"软件破解","slug":"软件破解","permalink":"http://rawbin-.github.io/tags/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"},{"name":"编码解码","slug":"编码解码","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/"},{"name":"网络攻防","slug":"网络攻防","permalink":"http://rawbin-.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"},{"name":"安全编码","slug":"安全编码","permalink":"http://rawbin-.github.io/tags/%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81/"},{"name":"安全设计","slug":"安全设计","permalink":"http://rawbin-.github.io/tags/%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1/"},{"name":"前端攻防","slug":"前端攻防","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E6%94%BB%E9%98%B2/"},{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://rawbin-.github.io/tags/WebAssembly/"},{"name":"引擎","slug":"引擎","permalink":"http://rawbin-.github.io/tags/%E5%BC%95%E6%93%8E/"},{"name":"v8","slug":"v8","permalink":"http://rawbin-.github.io/tags/v8/"},{"name":"selenium","slug":"selenium","permalink":"http://rawbin-.github.io/tags/selenium/"},{"name":"appium","slug":"appium","permalink":"http://rawbin-.github.io/tags/appium/"},{"name":"phantomjs","slug":"phantomjs","permalink":"http://rawbin-.github.io/tags/phantomjs/"},{"name":"slimerjs","slug":"slimerjs","permalink":"http://rawbin-.github.io/tags/slimerjs/"},{"name":"casperjs","slug":"casperjs","permalink":"http://rawbin-.github.io/tags/casperjs/"},{"name":"字符集","slug":"字符集","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"name":"async","slug":"async","permalink":"http://rawbin-.github.io/tags/async/"},{"name":"event-loop","slug":"event-loop","permalink":"http://rawbin-.github.io/tags/event-loop/"},{"name":"内存模型","slug":"内存模型","permalink":"http://rawbin-.github.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"name":"堆栈","slug":"堆栈","permalink":"http://rawbin-.github.io/tags/%E5%A0%86%E6%A0%88/"},{"name":"源码","slug":"源码","permalink":"http://rawbin-.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"代码优化","slug":"代码优化","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"},{"name":"高性能","slug":"高性能","permalink":"http://rawbin-.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"},{"name":"IO模型","slug":"IO模型","permalink":"http://rawbin-.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"},{"name":"进程","slug":"进程","permalink":"http://rawbin-.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"http://rawbin-.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"协程","slug":"协程","permalink":"http://rawbin-.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"管程","slug":"管程","permalink":"http://rawbin-.github.io/tags/%E7%AE%A1%E7%A8%8B/"},{"name":"纤程","slug":"纤程","permalink":"http://rawbin-.github.io/tags/%E7%BA%A4%E7%A8%8B/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://rawbin-.github.io/tags/HTTPS/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"http://rawbin-.github.io/tags/OpenSSL/"},{"name":"NodeJS历史","slug":"NodeJS历史","permalink":"http://rawbin-.github.io/tags/NodeJS%E5%8E%86%E5%8F%B2/"},{"name":"JavaScript历史","slug":"JavaScript历史","permalink":"http://rawbin-.github.io/tags/JavaScript%E5%8E%86%E5%8F%B2/"},{"name":"证书","slug":"证书","permalink":"http://rawbin-.github.io/tags/%E8%AF%81%E4%B9%A6/"},{"name":"自签名证书","slug":"自签名证书","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/"},{"name":"openssl","slug":"openssl","permalink":"http://rawbin-.github.io/tags/openssl/"},{"name":"风格","slug":"风格","permalink":"http://rawbin-.github.io/tags/%E9%A3%8E%E6%A0%BC/"},{"name":"思路","slug":"思路","permalink":"http://rawbin-.github.io/tags/%E6%80%9D%E8%B7%AF/"},{"name":"HTTP2","slug":"HTTP2","permalink":"http://rawbin-.github.io/tags/HTTP2/"},{"name":"设计原则","slug":"设计原则","permalink":"http://rawbin-.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"name":"代码设计","slug":"代码设计","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"},{"name":"可维护代码","slug":"可维护代码","permalink":"http://rawbin-.github.io/tags/%E5%8F%AF%E7%BB%B4%E6%8A%A4%E4%BB%A3%E7%A0%81/"},{"name":"Browser","slug":"Browser","permalink":"http://rawbin-.github.io/tags/Browser/"},{"name":"Web发展","slug":"Web发展","permalink":"http://rawbin-.github.io/tags/Web%E5%8F%91%E5%B1%95/"},{"name":"Web历史","slug":"Web历史","permalink":"http://rawbin-.github.io/tags/Web%E5%8E%86%E5%8F%B2/"},{"name":"CMD","slug":"CMD","permalink":"http://rawbin-.github.io/tags/CMD/"},{"name":"SeaJS","slug":"SeaJS","permalink":"http://rawbin-.github.io/tags/SeaJS/"},{"name":"模块化规范","slug":"模块化规范","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/"},{"name":"工程化","slug":"工程化","permalink":"http://rawbin-.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"图片识别","slug":"图片识别","permalink":"http://rawbin-.github.io/tags/%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/"},{"name":"webpack","slug":"webpack","permalink":"http://rawbin-.github.io/tags/webpack/"},{"name":"mocha","slug":"mocha","permalink":"http://rawbin-.github.io/tags/mocha/"},{"name":"单元测试","slug":"单元测试","permalink":"http://rawbin-.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"工作流","slug":"工作流","permalink":"http://rawbin-.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"name":"包管理","slug":"包管理","permalink":"http://rawbin-.github.io/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"},{"name":"Inspect","slug":"Inspect","permalink":"http://rawbin-.github.io/tags/Inspect/"},{"name":"性能分析","slug":"性能分析","permalink":"http://rawbin-.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"eslint","slug":"eslint","permalink":"http://rawbin-.github.io/tags/eslint/"},{"name":"规范检查","slug":"规范检查","permalink":"http://rawbin-.github.io/tags/%E8%A7%84%E8%8C%83%E6%A3%80%E6%9F%A5/"},{"name":"Babel","slug":"Babel","permalink":"http://rawbin-.github.io/tags/Babel/"},{"name":"代码转换","slug":"代码转换","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2/"},{"name":"命令行","slug":"命令行","permalink":"http://rawbin-.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"数据库","slug":"数据库","permalink":"http://rawbin-.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"ORM","slug":"ORM","permalink":"http://rawbin-.github.io/tags/ORM/"},{"name":"rsync","slug":"rsync","permalink":"http://rawbin-.github.io/tags/rsync/"},{"name":"ssh","slug":"ssh","permalink":"http://rawbin-.github.io/tags/ssh/"},{"name":"React Native","slug":"React-Native","permalink":"http://rawbin-.github.io/tags/React-Native/"},{"name":"Router","slug":"Router","permalink":"http://rawbin-.github.io/tags/Router/"},{"name":"redux","slug":"redux","permalink":"http://rawbin-.github.io/tags/redux/"},{"name":"垂直水平居中","slug":"垂直水平居中","permalink":"http://rawbin-.github.io/tags/%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/"},{"name":"MacOS","slug":"MacOS","permalink":"http://rawbin-.github.io/tags/MacOS/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://rawbin-.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"Bash","slug":"Bash","permalink":"http://rawbin-.github.io/tags/Bash/"},{"name":"Git Bash","slug":"Git-Bash","permalink":"http://rawbin-.github.io/tags/Git-Bash/"},{"name":"点击穿透","slug":"点击穿透","permalink":"http://rawbin-.github.io/tags/%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/"},{"name":"滑动穿透","slug":"滑动穿透","permalink":"http://rawbin-.github.io/tags/%E6%BB%91%E5%8A%A8%E7%A9%BF%E9%80%8F/"},{"name":"穿透","slug":"穿透","permalink":"http://rawbin-.github.io/tags/%E7%A9%BF%E9%80%8F/"},{"name":"UTC","slug":"UTC","permalink":"http://rawbin-.github.io/tags/UTC/"},{"name":"Date","slug":"Date","permalink":"http://rawbin-.github.io/tags/Date/"},{"name":"Flux","slug":"Flux","permalink":"http://rawbin-.github.io/tags/Flux/"},{"name":"Redux","slug":"Redux","permalink":"http://rawbin-.github.io/tags/Redux/"},{"name":"VPN","slug":"VPN","permalink":"http://rawbin-.github.io/tags/VPN/"},{"name":"MTU","slug":"MTU","permalink":"http://rawbin-.github.io/tags/MTU/"},{"name":"丢包","slug":"丢包","permalink":"http://rawbin-.github.io/tags/%E4%B8%A2%E5%8C%85/"},{"name":"http","slug":"http","permalink":"http://rawbin-.github.io/tags/http/"},{"name":"tcp","slug":"tcp","permalink":"http://rawbin-.github.io/tags/tcp/"},{"name":"keep-alive","slug":"keep-alive","permalink":"http://rawbin-.github.io/tags/keep-alive/"},{"name":"chrome","slug":"chrome","permalink":"http://rawbin-.github.io/tags/chrome/"},{"name":"扩展","slug":"扩展","permalink":"http://rawbin-.github.io/tags/%E6%89%A9%E5%B1%95/"},{"name":"BackstopJS","slug":"BackstopJS","permalink":"http://rawbin-.github.io/tags/BackstopJS/"},{"name":"PhantomCSS","slug":"PhantomCSS","permalink":"http://rawbin-.github.io/tags/PhantomCSS/"},{"name":"回归测试","slug":"回归测试","permalink":"http://rawbin-.github.io/tags/%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95/"},{"name":"windows","slug":"windows","permalink":"http://rawbin-.github.io/tags/windows/"},{"name":"chmod","slug":"chmod","permalink":"http://rawbin-.github.io/tags/chmod/"},{"name":"PPT","slug":"PPT","permalink":"http://rawbin-.github.io/tags/PPT/"},{"name":"演示文稿","slug":"演示文稿","permalink":"http://rawbin-.github.io/tags/%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF/"},{"name":"Slides","slug":"Slides","permalink":"http://rawbin-.github.io/tags/Slides/"},{"name":"NW","slug":"NW","permalink":"http://rawbin-.github.io/tags/NW/"},{"name":"Node-Webkit","slug":"Node-Webkit","permalink":"http://rawbin-.github.io/tags/Node-Webkit/"},{"name":"chai","slug":"chai","permalink":"http://rawbin-.github.io/tags/chai/"},{"name":"Browserify","slug":"Browserify","permalink":"http://rawbin-.github.io/tags/Browserify/"},{"name":"javascript","slug":"javascript","permalink":"http://rawbin-.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"http://rawbin-.github.io/tags/nodejs/"},{"name":"git","slug":"git","permalink":"http://rawbin-.github.io/tags/git/"},{"name":"submodule","slug":"submodule","permalink":"http://rawbin-.github.io/tags/submodule/"},{"name":"fetch","slug":"fetch","permalink":"http://rawbin-.github.io/tags/fetch/"},{"name":"ajax","slug":"ajax","permalink":"http://rawbin-.github.io/tags/ajax/"},{"name":"技术栈","slug":"技术栈","permalink":"http://rawbin-.github.io/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"Chrome","slug":"Chrome","permalink":"http://rawbin-.github.io/tags/Chrome/"},{"name":"Events","slug":"Events","permalink":"http://rawbin-.github.io/tags/Events/"},{"name":"事件","slug":"事件","permalink":"http://rawbin-.github.io/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"Promise","slug":"Promise","permalink":"http://rawbin-.github.io/tags/Promise/"},{"name":"Spring","slug":"Spring","permalink":"http://rawbin-.github.io/tags/Spring/"},{"name":"Velocity","slug":"Velocity","permalink":"http://rawbin-.github.io/tags/Velocity/"},{"name":"Velocity-tools","slug":"Velocity-tools","permalink":"http://rawbin-.github.io/tags/Velocity-tools/"},{"name":"移除注释","slug":"移除注释","permalink":"http://rawbin-.github.io/tags/%E7%A7%BB%E9%99%A4%E6%B3%A8%E9%87%8A/"},{"name":"网站速度检测","slug":"网站速度检测","permalink":"http://rawbin-.github.io/tags/%E7%BD%91%E7%AB%99%E9%80%9F%E5%BA%A6%E6%A3%80%E6%B5%8B/"},{"name":"延时检测","slug":"延时检测","permalink":"http://rawbin-.github.io/tags/%E5%BB%B6%E6%97%B6%E6%A3%80%E6%B5%8B/"},{"name":"Win10","slug":"Win10","permalink":"http://rawbin-.github.io/tags/Win10/"},{"name":"VIA","slug":"VIA","permalink":"http://rawbin-.github.io/tags/VIA/"},{"name":"耳机","slug":"耳机","permalink":"http://rawbin-.github.io/tags/%E8%80%B3%E6%9C%BA/"},{"name":"扬声器","slug":"扬声器","permalink":"http://rawbin-.github.io/tags/%E6%89%AC%E5%A3%B0%E5%99%A8/"},{"name":"node","slug":"node","permalink":"http://rawbin-.github.io/tags/node/"},{"name":"nvm","slug":"nvm","permalink":"http://rawbin-.github.io/tags/nvm/"},{"name":"n","slug":"n","permalink":"http://rawbin-.github.io/tags/n/"},{"name":"nvmw","slug":"nvmw","permalink":"http://rawbin-.github.io/tags/nvmw/"},{"name":"数值","slug":"数值","permalink":"http://rawbin-.github.io/tags/%E6%95%B0%E5%80%BC/"},{"name":"int","slug":"int","permalink":"http://rawbin-.github.io/tags/int/"},{"name":"float","slug":"float","permalink":"http://rawbin-.github.io/tags/float/"},{"name":"fekit","slug":"fekit","permalink":"http://rawbin-.github.io/tags/fekit/"},{"name":"mock","slug":"mock","permalink":"http://rawbin-.github.io/tags/mock/"},{"name":"内存泄露","slug":"内存泄露","permalink":"http://rawbin-.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"},{"name":"github","slug":"github","permalink":"http://rawbin-.github.io/tags/github/"},{"name":"diff","slug":"diff","permalink":"http://rawbin-.github.io/tags/diff/"},{"name":"merge","slug":"merge","permalink":"http://rawbin-.github.io/tags/merge/"},{"name":"beyondcompare","slug":"beyondcompare","permalink":"http://rawbin-.github.io/tags/beyondcompare/"},{"name":"node-inspector","slug":"node-inspector","permalink":"http://rawbin-.github.io/tags/node-inspector/"},{"name":"input","slug":"input","permalink":"http://rawbin-.github.io/tags/input/"},{"name":"file","slug":"file","permalink":"http://rawbin-.github.io/tags/file/"},{"name":"change","slug":"change","permalink":"http://rawbin-.github.io/tags/change/"},{"name":"velocity","slug":"velocity","permalink":"http://rawbin-.github.io/tags/velocity/"},{"name":"前端工程","slug":"前端工程","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"},{"name":"面向对象","slug":"面向对象","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"面向过程","slug":"面向过程","permalink":"http://rawbin-.github.io/tags/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"},{"name":"表单值存取","slug":"表单值存取","permalink":"http://rawbin-.github.io/tags/%E8%A1%A8%E5%8D%95%E5%80%BC%E5%AD%98%E5%8F%96/"},{"name":"browserify","slug":"browserify","permalink":"http://rawbin-.github.io/tags/browserify/"},{"name":"编码","slug":"编码","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"解码","slug":"解码","permalink":"http://rawbin-.github.io/tags/%E8%A7%A3%E7%A0%81/"},{"name":"URL","slug":"URL","permalink":"http://rawbin-.github.io/tags/URL/"},{"name":"复制","slug":"复制","permalink":"http://rawbin-.github.io/tags/%E5%A4%8D%E5%88%B6/"},{"name":"粘贴","slug":"粘贴","permalink":"http://rawbin-.github.io/tags/%E7%B2%98%E8%B4%B4/"},{"name":"copy","slug":"copy","permalink":"http://rawbin-.github.io/tags/copy/"},{"name":"paste","slug":"paste","permalink":"http://rawbin-.github.io/tags/paste/"},{"name":"点击下载","slug":"点击下载","permalink":"http://rawbin-.github.io/tags/%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD/"},{"name":"Selection","slug":"Selection","permalink":"http://rawbin-.github.io/tags/Selection/"},{"name":"Range","slug":"Range","permalink":"http://rawbin-.github.io/tags/Range/"},{"name":"asynchronous","slug":"asynchronous","permalink":"http://rawbin-.github.io/tags/asynchronous/"},{"name":"promise","slug":"promise","permalink":"http://rawbin-.github.io/tags/promise/"},{"name":"bigpipe","slug":"bigpipe","permalink":"http://rawbin-.github.io/tags/bigpipe/"},{"name":"pipeline","slug":"pipeline","permalink":"http://rawbin-.github.io/tags/pipeline/"},{"name":"DOM","slug":"DOM","permalink":"http://rawbin-.github.io/tags/DOM/"},{"name":"property","slug":"property","permalink":"http://rawbin-.github.io/tags/property/"},{"name":"attribute","slug":"attribute","permalink":"http://rawbin-.github.io/tags/attribute/"},{"name":"严格模式","slug":"严格模式","permalink":"http://rawbin-.github.io/tags/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"},{"name":"日期选择器","slug":"日期选择器","permalink":"http://rawbin-.github.io/tags/%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"DateTimePicker","slug":"DateTimePicker","permalink":"http://rawbin-.github.io/tags/DateTimePicker/"},{"name":"Hijacking","slug":"Hijacking","permalink":"http://rawbin-.github.io/tags/Hijacking/"},{"name":"KMP","slug":"KMP","permalink":"http://rawbin-.github.io/tags/KMP/"},{"name":"gyp","slug":"gyp","permalink":"http://rawbin-.github.io/tags/gyp/"},{"name":"forever","slug":"forever","permalink":"http://rawbin-.github.io/tags/forever/"},{"name":"桌面应用","slug":"桌面应用","permalink":"http://rawbin-.github.io/tags/%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"},{"name":"node-webkit","slug":"node-webkit","permalink":"http://rawbin-.github.io/tags/node-webkit/"},{"name":"robotjs","slug":"robotjs","permalink":"http://rawbin-.github.io/tags/robotjs/"},{"name":"hex","slug":"hex","permalink":"http://rawbin-.github.io/tags/hex/"},{"name":"tideSDK","slug":"tideSDK","permalink":"http://rawbin-.github.io/tags/tideSDK/"},{"name":"appjs.AIR","slug":"appjs-AIR","permalink":"http://rawbin-.github.io/tags/appjs-AIR/"},{"name":"兼容性","slug":"兼容性","permalink":"http://rawbin-.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"测试","slug":"测试","permalink":"http://rawbin-.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Python","slug":"Python","permalink":"http://rawbin-.github.io/tags/Python/"},{"name":"Unicode","slug":"Unicode","permalink":"http://rawbin-.github.io/tags/Unicode/"},{"name":"str","slug":"str","permalink":"http://rawbin-.github.io/tags/str/"},{"name":"HTTP调试","slug":"HTTP调试","permalink":"http://rawbin-.github.io/tags/HTTP%E8%B0%83%E8%AF%95/"},{"name":"请求","slug":"请求","permalink":"http://rawbin-.github.io/tags/%E8%AF%B7%E6%B1%82/"},{"name":"响应","slug":"响应","permalink":"http://rawbin-.github.io/tags/%E5%93%8D%E5%BA%94/"},{"name":"touch","slug":"touch","permalink":"http://rawbin-.github.io/tags/touch/"},{"name":"click","slug":"click","permalink":"http://rawbin-.github.io/tags/click/"},{"name":"android","slug":"android","permalink":"http://rawbin-.github.io/tags/android/"},{"name":"MediaElement","slug":"MediaElement","permalink":"http://rawbin-.github.io/tags/MediaElement/"},{"name":"Video","slug":"Video","permalink":"http://rawbin-.github.io/tags/Video/"},{"name":"Flash","slug":"Flash","permalink":"http://rawbin-.github.io/tags/Flash/"},{"name":"跨域","slug":"跨域","permalink":"http://rawbin-.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"打印机","slug":"打印机","permalink":"http://rawbin-.github.io/tags/%E6%89%93%E5%8D%B0%E6%9C%BA/"},{"name":"剪贴板","slug":"剪贴板","permalink":"http://rawbin-.github.io/tags/%E5%89%AA%E8%B4%B4%E6%9D%BF/"},{"name":"部分打印","slug":"部分打印","permalink":"http://rawbin-.github.io/tags/%E9%83%A8%E5%88%86%E6%89%93%E5%8D%B0/"},{"name":"二维码","slug":"二维码","permalink":"http://rawbin-.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"},{"name":"Cisco VPN","slug":"Cisco-VPN","permalink":"http://rawbin-.github.io/tags/Cisco-VPN/"},{"name":"管理员权限","slug":"管理员权限","permalink":"http://rawbin-.github.io/tags/%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90/"},{"name":"非内置管理员","slug":"非内置管理员","permalink":"http://rawbin-.github.io/tags/%E9%9D%9E%E5%86%85%E7%BD%AE%E7%AE%A1%E7%90%86%E5%91%98/"},{"name":"Administrator","slug":"Administrator","permalink":"http://rawbin-.github.io/tags/Administrator/"},{"name":"My97Datepicker","slug":"My97Datepicker","permalink":"http://rawbin-.github.io/tags/My97Datepicker/"},{"name":"Modular","slug":"Modular","permalink":"http://rawbin-.github.io/tags/Modular/"},{"name":"模块化编译","slug":"模块化编译","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E8%AF%91/"},{"name":"日期时间选择器","slug":"日期时间选择器","permalink":"http://rawbin-.github.io/tags/%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://rawbin-.github.io/tags/bootstrap/"},{"name":"样式冲突","slug":"样式冲突","permalink":"http://rawbin-.github.io/tags/%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81/"},{"name":"睡眠","slug":"睡眠","permalink":"http://rawbin-.github.io/tags/%E7%9D%A1%E7%9C%A0/"},{"name":"休眠","slug":"休眠","permalink":"http://rawbin-.github.io/tags/%E4%BC%91%E7%9C%A0/"},{"name":"无法唤醒","slug":"无法唤醒","permalink":"http://rawbin-.github.io/tags/%E6%97%A0%E6%B3%95%E5%94%A4%E9%86%92/"},{"name":"加载","slug":"加载","permalink":"http://rawbin-.github.io/tags/%E5%8A%A0%E8%BD%BD/"},{"name":"优化","slug":"优化","permalink":"http://rawbin-.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"XMPP","slug":"XMPP","permalink":"http://rawbin-.github.io/tags/XMPP/"},{"name":"HTTP-BIND","slug":"HTTP-BIND","permalink":"http://rawbin-.github.io/tags/HTTP-BIND/"},{"name":"Cookie","slug":"Cookie","permalink":"http://rawbin-.github.io/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"http://rawbin-.github.io/tags/Session/"},{"name":"P3P","slug":"P3P","permalink":"http://rawbin-.github.io/tags/P3P/"},{"name":"Ajax","slug":"Ajax","permalink":"http://rawbin-.github.io/tags/Ajax/"},{"name":"广告","slug":"广告","permalink":"http://rawbin-.github.io/tags/%E5%B9%BF%E5%91%8A/"},{"name":"AJAX","slug":"AJAX","permalink":"http://rawbin-.github.io/tags/AJAX/"},{"name":"服务器推","slug":"服务器推","permalink":"http://rawbin-.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8/"},{"name":"cookie","slug":"cookie","permalink":"http://rawbin-.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://rawbin-.github.io/tags/session/"},{"name":"Web前端","slug":"Web前端","permalink":"http://rawbin-.github.io/tags/Web%E5%89%8D%E7%AB%AF/"},{"name":"前端基础","slug":"前端基础","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"原型","slug":"原型","permalink":"http://rawbin-.github.io/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"作用域","slug":"作用域","permalink":"http://rawbin-.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"闭包","slug":"闭包","permalink":"http://rawbin-.github.io/tags/%E9%97%AD%E5%8C%85/"},{"name":"defer","slug":"defer","permalink":"http://rawbin-.github.io/tags/defer/"},{"name":"avalon","slug":"avalon","permalink":"http://rawbin-.github.io/tags/avalon/"},{"name":"this","slug":"this","permalink":"http://rawbin-.github.io/tags/this/"},{"name":"设计模式","slug":"设计模式","permalink":"http://rawbin-.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"IE","slug":"IE","permalink":"http://rawbin-.github.io/tags/IE/"},{"name":"Internet Explorer","slug":"Internet-Explorer","permalink":"http://rawbin-.github.io/tags/Internet-Explorer/"},{"name":"HTML4","slug":"HTML4","permalink":"http://rawbin-.github.io/tags/HTML4/"},{"name":"XMLHTTPRequest","slug":"XMLHTTPRequest","permalink":"http://rawbin-.github.io/tags/XMLHTTPRequest/"},{"name":"禁用缓存","slug":"禁用缓存","permalink":"http://rawbin-.github.io/tags/%E7%A6%81%E7%94%A8%E7%BC%93%E5%AD%98/"},{"name":"参考资料","slug":"参考资料","permalink":"http://rawbin-.github.io/tags/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"name":"jekyll","slug":"jekyll","permalink":"http://rawbin-.github.io/tags/jekyll/"},{"name":"中文路径","slug":"中文路径","permalink":"http://rawbin-.github.io/tags/%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84/"},{"name":"ruby","slug":"ruby","permalink":"http://rawbin-.github.io/tags/ruby/"},{"name":"webrick","slug":"webrick","permalink":"http://rawbin-.github.io/tags/webrick/"},{"name":"本地预览","slug":"本地预览","permalink":"http://rawbin-.github.io/tags/%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88/"},{"name":"模块加载器","slug":"模块加载器","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"name":"ECMAScript2015","slug":"ECMAScript2015","permalink":"http://rawbin-.github.io/tags/ECMAScript2015/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"http://rawbin-.github.io/tags/ECMAScript6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://rawbin-.github.io/tags/ES2015/"},{"name":"网页定位","slug":"网页定位","permalink":"http://rawbin-.github.io/tags/%E7%BD%91%E9%A1%B5%E5%AE%9A%E4%BD%8D/"},{"name":"鼠标定位","slug":"鼠标定位","permalink":"http://rawbin-.github.io/tags/%E9%BC%A0%E6%A0%87%E5%AE%9A%E4%BD%8D/"},{"name":"页面位置","slug":"页面位置","permalink":"http://rawbin-.github.io/tags/%E9%A1%B5%E9%9D%A2%E4%BD%8D%E7%BD%AE/"},{"name":"测试框架","slug":"测试框架","permalink":"http://rawbin-.github.io/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"name":"系统工具","slug":"系统工具","permalink":"http://rawbin-.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/"},{"name":"高效","slug":"高效","permalink":"http://rawbin-.github.io/tags/%E9%AB%98%E6%95%88/"},{"name":"便捷","slug":"便捷","permalink":"http://rawbin-.github.io/tags/%E4%BE%BF%E6%8D%B7/"},{"name":"Hexo","slug":"Hexo","permalink":"http://rawbin-.github.io/tags/Hexo/"},{"name":"静态博客","slug":"静态博客","permalink":"http://rawbin-.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"name":"Wiki","slug":"Wiki","permalink":"http://rawbin-.github.io/tags/Wiki/"},{"name":"CMS","slug":"CMS","permalink":"http://rawbin-.github.io/tags/CMS/"},{"name":"知识管理","slug":"知识管理","permalink":"http://rawbin-.github.io/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"},{"name":"名词解释","slug":"名词解释","permalink":"http://rawbin-.github.io/tags/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"name":"文本模板","slug":"文本模板","permalink":"http://rawbin-.github.io/tags/%E6%96%87%E6%9C%AC%E6%A8%A1%E6%9D%BF/"},{"name":"模板引擎","slug":"模板引擎","permalink":"http://rawbin-.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"},{"name":"CSS框架","slug":"CSS框架","permalink":"http://rawbin-.github.io/tags/CSS%E6%A1%86%E6%9E%B6/"},{"name":"样式框架","slug":"样式框架","permalink":"http://rawbin-.github.io/tags/%E6%A0%B7%E5%BC%8F%E6%A1%86%E6%9E%B6/"},{"name":"图片预览","slug":"图片预览","permalink":"http://rawbin-.github.io/tags/%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88/"},{"name":"图片上传","slug":"图片上传","permalink":"http://rawbin-.github.io/tags/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"},{"name":"JavaScript画图","slug":"JavaScript画图","permalink":"http://rawbin-.github.io/tags/JavaScript%E7%94%BB%E5%9B%BE/"},{"name":"前端画图","slug":"前端画图","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E7%94%BB%E5%9B%BE/"},{"name":"JavaScript图表","slug":"JavaScript图表","permalink":"http://rawbin-.github.io/tags/JavaScript%E5%9B%BE%E8%A1%A8/"},{"name":"jQuery源码","slug":"jQuery源码","permalink":"http://rawbin-.github.io/tags/jQuery%E6%BA%90%E7%A0%81/"},{"name":"文件上传","slug":"文件上传","permalink":"http://rawbin-.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"异步上传","slug":"异步上传","permalink":"http://rawbin-.github.io/tags/%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0/"},{"name":"CSS详解","slug":"CSS详解","permalink":"http://rawbin-.github.io/tags/CSS%E8%AF%A6%E8%A7%A3/"},{"name":"CSS属性","slug":"CSS属性","permalink":"http://rawbin-.github.io/tags/CSS%E5%B1%9E%E6%80%A7/"},{"name":"CSS兼容","slug":"CSS兼容","permalink":"http://rawbin-.github.io/tags/CSS%E5%85%BC%E5%AE%B9/"},{"name":"CSS Hack","slug":"CSS-Hack","permalink":"http://rawbin-.github.io/tags/CSS-Hack/"},{"name":"nrm","slug":"nrm","permalink":"http://rawbin-.github.io/tags/nrm/"},{"name":"619","slug":"619","permalink":"http://rawbin-.github.io/tags/619/"},{"name":"VPN错误","slug":"VPN错误","permalink":"http://rawbin-.github.io/tags/VPN%E9%94%99%E8%AF%AF/"},{"name":"快捷键","slug":"快捷键","permalink":"http://rawbin-.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"Sublime Text 2","slug":"Sublime-Text-2","permalink":"http://rawbin-.github.io/tags/Sublime-Text-2/"},{"name":"插件推荐","slug":"插件推荐","permalink":"http://rawbin-.github.io/tags/%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"name":"编辑器","slug":"编辑器","permalink":"http://rawbin-.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"Web调试","slug":"Web调试","permalink":"http://rawbin-.github.io/tags/Web%E8%B0%83%E8%AF%95/"},{"name":"设计图","slug":"设计图","permalink":"http://rawbin-.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%9B%BE/"},{"name":"流程图","slug":"流程图","permalink":"http://rawbin-.github.io/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"},{"name":"UML","slug":"UML","permalink":"http://rawbin-.github.io/tags/UML/"},{"name":"前端框架","slug":"前端框架","permalink":"http://rawbin-.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Web框架","slug":"Web框架","permalink":"http://rawbin-.github.io/tags/Web%E6%A1%86%E6%9E%B6/"},{"name":"渗透","slug":"渗透","permalink":"http://rawbin-.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"OWASP","slug":"OWASP","permalink":"http://rawbin-.github.io/tags/OWASP/"},{"name":"Web架构","slug":"Web架构","permalink":"http://rawbin-.github.io/tags/Web%E6%9E%B6%E6%9E%84/"},{"name":"网站架构","slug":"网站架构","permalink":"http://rawbin-.github.io/tags/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"name":"PHP","slug":"PHP","permalink":"http://rawbin-.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://rawbin-.github.io/tags/PHP%E5%86%85%E6%A0%B8/"},{"name":"VirtualEnv","slug":"VirtualEnv","permalink":"http://rawbin-.github.io/tags/VirtualEnv/"},{"name":"VSS","slug":"VSS","permalink":"http://rawbin-.github.io/tags/VSS/"},{"name":"RSS","slug":"RSS","permalink":"http://rawbin-.github.io/tags/RSS/"},{"name":"PSS","slug":"PSS","permalink":"http://rawbin-.github.io/tags/PSS/"},{"name":"USS","slug":"USS","permalink":"http://rawbin-.github.io/tags/USS/"},{"name":"内存占用参数","slug":"内存占用参数","permalink":"http://rawbin-.github.io/tags/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%8F%82%E6%95%B0/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://rawbin-.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"OSI","slug":"OSI","permalink":"http://rawbin-.github.io/tags/OSI/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://rawbin-.github.io/tags/TCP-IP/"},{"name":"PhotoShop","slug":"PhotoShop","permalink":"http://rawbin-.github.io/tags/PhotoShop/"},{"name":"四色黑","slug":"四色黑","permalink":"http://rawbin-.github.io/tags/%E5%9B%9B%E8%89%B2%E9%BB%91/"},{"name":"单色黑","slug":"单色黑","permalink":"http://rawbin-.github.io/tags/%E5%8D%95%E8%89%B2%E9%BB%91/"},{"name":"内存管理","slug":"内存管理","permalink":"http://rawbin-.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"Linux性能检测","slug":"Linux性能检测","permalink":"http://rawbin-.github.io/tags/Linux%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B/"},{"name":"iostat","slug":"iostat","permalink":"http://rawbin-.github.io/tags/iostat/"},{"name":"vmstat","slug":"vmstat","permalink":"http://rawbin-.github.io/tags/vmstat/"},{"name":"服务器监控","slug":"服务器监控","permalink":"http://rawbin-.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7/"},{"name":"Linux","slug":"Linux","permalink":"http://rawbin-.github.io/tags/Linux/"},{"name":"文本处理","slug":"文本处理","permalink":"http://rawbin-.github.io/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"},{"name":"日志分析","slug":"日志分析","permalink":"http://rawbin-.github.io/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"name":"grep","slug":"grep","permalink":"http://rawbin-.github.io/tags/grep/"},{"name":"awk","slug":"awk","permalink":"http://rawbin-.github.io/tags/awk/"},{"name":"LDAP","slug":"LDAP","permalink":"http://rawbin-.github.io/tags/LDAP/"},{"name":"OpenLDAP","slug":"OpenLDAP","permalink":"http://rawbin-.github.io/tags/OpenLDAP/"},{"name":"Linux系统命令","slug":"Linux系统命令","permalink":"http://rawbin-.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"},{"name":"Linux系统管理","slug":"Linux系统管理","permalink":"http://rawbin-.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"},{"name":"数据库比较","slug":"数据库比较","permalink":"http://rawbin-.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E8%BE%83/"},{"name":"关系型数据库","slug":"关系型数据库","permalink":"http://rawbin-.github.io/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://rawbin-.github.io/tags/NoSQL/"},{"name":"分布式文件系统","slug":"分布式文件系统","permalink":"http://rawbin-.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"学习经验","slug":"学习经验","permalink":"http://rawbin-.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/"},{"name":"大数据","slug":"大数据","permalink":"http://rawbin-.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"数据分析","slug":"数据分析","permalink":"http://rawbin-.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://rawbin-.github.io/tags/Hadoop/"},{"name":"代码审查","slug":"代码审查","permalink":"http://rawbin-.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/"},{"name":"IEEE 745","slug":"IEEE-745","permalink":"http://rawbin-.github.io/tags/IEEE-745/"},{"name":"浮点数","slug":"浮点数","permalink":"http://rawbin-.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"},{"name":"JSON","slug":"JSON","permalink":"http://rawbin-.github.io/tags/JSON/"},{"name":"XML","slug":"XML","permalink":"http://rawbin-.github.io/tags/XML/"},{"name":"Nginx","slug":"Nginx","permalink":"http://rawbin-.github.io/tags/Nginx/"},{"name":"Web服务器","slug":"Web服务器","permalink":"http://rawbin-.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"seajs","slug":"seajs","permalink":"http://rawbin-.github.io/tags/seajs/"},{"name":"requirejs","slug":"requirejs","permalink":"http://rawbin-.github.io/tags/requirejs/"},{"name":"AMD","slug":"AMD","permalink":"http://rawbin-.github.io/tags/AMD/"},{"name":"Python 网页截图","slug":"Python-网页截图","permalink":"http://rawbin-.github.io/tags/Python-%E7%BD%91%E9%A1%B5%E6%88%AA%E5%9B%BE/"},{"name":"自动截图","slug":"自动截图","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E6%88%AA%E5%9B%BE/"},{"name":"Markdown","slug":"Markdown","permalink":"http://rawbin-.github.io/tags/Markdown/"},{"name":"GitHub","slug":"GitHub","permalink":"http://rawbin-.github.io/tags/GitHub/"},{"name":"Jekyll","slug":"Jekyll","permalink":"http://rawbin-.github.io/tags/Jekyll/"},{"name":"博客","slug":"博客","permalink":"http://rawbin-.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"站点","slug":"站点","permalink":"http://rawbin-.github.io/tags/%E7%AB%99%E7%82%B9/"},{"name":"Jekyll Bootstrap","slug":"Jekyll-Bootstrap","permalink":"http://rawbin-.github.io/tags/Jekyll-Bootstrap/"},{"name":"VIM","slug":"VIM","permalink":"http://rawbin-.github.io/tags/VIM/"},{"name":"Git SSH 配置","slug":"Git-SSH-配置","permalink":"http://rawbin-.github.io/tags/Git-SSH-%E9%85%8D%E7%BD%AE/"},{"name":"乱码","slug":"乱码","permalink":"http://rawbin-.github.io/tags/%E4%B9%B1%E7%A0%81/"},{"name":"字节序","slug":"字节序","permalink":"http://rawbin-.github.io/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"name":"框架","slug":"框架","permalink":"http://rawbin-.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"类库","slug":"类库","permalink":"http://rawbin-.github.io/tags/%E7%B1%BB%E5%BA%93/"},{"name":"MVC","slug":"MVC","permalink":"http://rawbin-.github.io/tags/MVC/"},{"name":"MVVM","slug":"MVVM","permalink":"http://rawbin-.github.io/tags/MVVM/"},{"name":"MVP","slug":"MVP","permalink":"http://rawbin-.github.io/tags/MVP/"},{"name":"HTTP请求","slug":"HTTP请求","permalink":"http://rawbin-.github.io/tags/HTTP%E8%AF%B7%E6%B1%82/"},{"name":"同源策略","slug":"同源策略","permalink":"http://rawbin-.github.io/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"name":"Same Origin Policy","slug":"Same-Origin-Policy","permalink":"http://rawbin-.github.io/tags/Same-Origin-Policy/"},{"name":"浏览器安全","slug":"浏览器安全","permalink":"http://rawbin-.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"},{"name":"类型转换","slug":"类型转换","permalink":"http://rawbin-.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"隐式类型转换","slug":"隐式类型转换","permalink":"http://rawbin-.github.io/tags/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"自动构建","slug":"自动构建","permalink":"http://rawbin-.github.io/tags/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"},{"name":"动态链接库","slug":"动态链接库","permalink":"http://rawbin-.github.io/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"name":"IA32","slug":"IA32","permalink":"http://rawbin-.github.io/tags/IA32/"},{"name":"Django 流程","slug":"Django-流程","permalink":"http://rawbin-.github.io/tags/Django-%E6%B5%81%E7%A8%8B/"},{"name":"Django 源码","slug":"Django-源码","permalink":"http://rawbin-.github.io/tags/Django-%E6%BA%90%E7%A0%81/"},{"name":"WSGI","slug":"WSGI","permalink":"http://rawbin-.github.io/tags/WSGI/"}]}